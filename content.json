{"meta":{"title":"TYS的博客","subtitle":"算法小白努力学习中","description":"","author":"tys","url":"http://abeltian.top","root":"/"},"pages":[{"title":"categories","date":"2020-12-14T12:29:49.000Z","updated":"2021-09-10T08:53:11.522Z","comments":true,"path":"categories/index.html","permalink":"http://abeltian.top/categories/index.html","excerpt":"","text":""},{"title":"books","date":"2020-12-14T12:31:21.000Z","updated":"2021-09-10T08:53:11.521Z","comments":true,"path":"books/index.html","permalink":"http://abeltian.top/books/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-14T12:31:27.000Z","updated":"2021-09-10T08:53:11.520Z","comments":true,"path":"about/index.html","permalink":"http://abeltian.top/about/index.html","excerpt":"","text":""},{"title":"links","date":"2020-12-14T12:31:13.000Z","updated":"2021-09-10T08:53:11.524Z","comments":true,"path":"links/index.html","permalink":"http://abeltian.top/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-14T12:30:36.000Z","updated":"2021-09-10T08:53:11.524Z","comments":true,"path":"tags/index.html","permalink":"http://abeltian.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"深度学习/医学图像处理的会议","date":"2022-01-03T09:55:03.295Z","updated":"2022-01-03T09:56:31.644Z","comments":true,"path":"2022/01/03/深度学习/医学图像处理的会议/","link":"","permalink":"http://abeltian.top/2022/01/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E4%BC%9A%E8%AE%AE/","excerpt":"","text":"医学图像处理的会议https://2022.midl.io/call-for-papers.html Medical Imaging with Deep Learning MIDL 长论文 提交deadline 12月 短论文三页 4月22号。","categories":[],"tags":[]},{"title":"工作安排","slug":"深度学习/工作计划1","date":"2022-01-01T02:29:10.000Z","updated":"2022-01-19T04:31:59.867Z","comments":true,"path":"2022/01/01/深度学习/工作计划1/","link":"","permalink":"http://abeltian.top/2022/01/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%921/","excerpt":"","text":"工作内容2021.12.23-12.25 重叠与密集细胞区域的检测文献调研。 调研了两篇密集区域目标检测的文章 PS-RCNN 两个阶段来分别检测未遮挡与严重遮挡的目标 迭代检测的方法，将历史的特征图卷积后作为第二次的输入 查看一下目前faster-rcnn的所有密集、重叠区域检测结果的情况，挑选出了一些检测结果差的样本。 2021.12.25~2021.12.31 密集、重叠细胞区域存在的检测难点，严重遮挡的细胞智能提供较少的视觉信息，检测得到的置信度低，容易被NMS最大值抑制去除。其中一种解决方案是Soft-NMS，Soft-NMS按照检测框之间的重合程度(IOU)进行置信度衰减，但是衰减的形式为人工设计，具有较大的局限性，且置信度降低的检测框后续也可能因不满足置信度阈值的要求而被去除。 针对密集、重叠细胞区域存在的检测失效的问题，拟采用迭代检测的方法来检测两组具有不同遮挡的细胞实例。第一轮检测没有遮挡或者轻微遮挡的细胞，在实例分割分支会得到的已检测到细胞的mask，之后采用该mask去覆盖原特征图的相应位置得到masked feature。在第二轮检测中使用masked feature去检测被遗漏的遮挡较严重的细胞。通过这样的迭代检测方式去提升网络对被遮挡细胞的检测能力。 在该迭代检测的方法中，需要细胞边界的mask信息，因此需要使用语义分割进行细胞的位置标注。 先完成结果写入到labelme的json的形式，完成结果的迭代，目前完成细胞质标注约500余张，版本一迭代完成，形成了闭环，下图为mask-rcnn推断的结果，红色为细胞，绿色为细胞核。 跑一下带有mask的检测网络如mask-rcnn 1python tools&#x2F;train.py configs&#x2F;mask_rcnn&#x2F;mask_rcnn_r50_fpn_2x_coco.py --work-dir .&#x2F;work_dir&#x2F;mask_rcnn_new&#x2F; 12.29检测结果出现了问题 只检测细胞边检 只检测细胞核边界 同时检测，目前存在失效的问题 不知道为什么 考虑结合语义分割网络，目前已找到问题未修改dataset coco数据集合与网络输出的分类类别，在结果写入json中出现了seg重复定义的bug。","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"","slug":"深度学习/mmdetection_seg","date":"2021-12-31T03:27:38.047Z","updated":"2021-12-31T12:32:50.666Z","comments":true,"path":"2021/12/31/深度学习/mmdetection_seg/","link":"","permalink":"http://abeltian.top/2021/12/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection_seg/","excerpt":"","text":"mmdetection遇到的问题 只检测细胞边检 只检测细胞核边界 同时检测，目前存在失效的问题 不知道为什么 考虑结合语义分割网络 目前怀疑的问题是dataset的类别没有进行改动","categories":[],"tags":[]},{"title":"数据集准备","slug":"深度学习/制作包含mask的coco数据集","date":"2021-12-29T02:29:10.000Z","updated":"2022-01-19T04:33:14.836Z","comments":true,"path":"2021/12/29/深度学习/制作包含mask的coco数据集/","link":"","permalink":"http://abeltian.top/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%88%B6%E4%BD%9C%E5%8C%85%E5%90%ABmask%E7%9A%84coco%E6%95%B0%E6%8D%AE%E9%9B%86/","excerpt":"","text":"制作包含mask的coco数据集1. coco数据集格式coco数据集的官网https://cocodataset.org/ 1234567891011&quot;annotations&quot;: [&#123; &quot;id&quot;: int, &quot;image_id&quot;: int, &quot;category_id&quot;: int, &quot;segmentation&quot;: RLE or [polygon], &quot;area&quot;: float, &quot;bbox&quot;: [x,y,width,height], &quot;iscrowd&quot;: 0 or 1,&#125;] 标注的信息 cocoapi提供了将polygon转为rle格式的代码 annToRLE labelme中通过group来判断边界框与mask的归属性。 2. 训练Mask-RCNNpycococreator 跑通了mask-rcnn跑出的分割结果是与图片大小相同的mask 3. mmdet中对COCO类的包装coco中imgToAnns记录了某一个img_id对应所有的ann_id _parse_ann_info包含了一张图片的所有的bbox与segm信息 result2json将检测与分割的结果写为coco的json格式。 model.show_result展示检测结果 4. 标注的标准对于处于边界的细胞，完整程度要大于5/6 对于细胞质非常小，几乎不可见的细胞种类，不标注细胞核，直接标注为细胞cell 参考文献https://patrickwasp.com/create-your-own-coco-style-dataset/ https://github.com/waspinator/pycococreator/","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"mmdetection网络训练","slug":"深度学习/mmdetection训练","date":"2021-12-20T02:29:10.000Z","updated":"2022-01-19T04:28:19.424Z","comments":true,"path":"2021/12/20/深度学习/mmdetection训练/","link":"","permalink":"http://abeltian.top/2021/12/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection%E8%AE%AD%E7%BB%83/","excerpt":"","text":"mmdetection训练如何制作数据集https://github.com/spytensor/prepare_detection_dataset 将labelme格式的数据转化为coco格式数据，需要对文件进行改写。 // 修改类别，修改image字段 修改area 1annotation[&#x27;area&#x27;] = annotation[&#x27;bbox&#x27;][2] * annotation[&#x27;bbox&#x27;][3] json编辑器dadroit 通过目录的软连接将数据创建到data文件夹下 https://blog.csdn.net/duanyajun987/article/details/97659685 修改mmdetection/mmdet/datasets/coco.py CLASSES mmdetection/mmdet/core/evaluation/class_names.py 修改 1234def coco_classes(): return [ &#39;Prim&#39;, &#39;Lym&#39;, &#39;Mono&#39;, &#39;Plas&#39;, &#39;Red&#39;,&#39;Promy&#39;,&#39;Myelo&#39;,&#39;Late&#39;,&#39;Rods&#39;,&#39;Lobu&#39;,&#39;Eosl&#39; ] 修改configs/models/retinanet_r50_fpn.py 1num_classes=11, 训练数据集 1python tools/train.py configs/retinanet/retinanet_r50_fpn_1x_coco.py --work-dir work_dirs --resume-from work_dirs/latest.pth --gpus 2 多卡训练 1bash ./tools/dist_train.sh configs/retinanet/retinanet_r50_fpn_1x_coco.py 2 --work-dir work_dirs --resume-from work_dirs/latest.pth 查看显卡使用情况 1watch -n 1 -d nvidia-smi 真正的训练文件mmdet/apis/train.py 修改epoch configs/_base_/schedules/schedules_1x.py的runner = dict(type=&#39;EpochBasedRunner&#39;, max_epochs=240)修改epoch数量 修改batchsizeconfigs/datasets/coco_detection.py samples_per_gpu参数 123456789101112131415161718data &#x3D; dict( samples_per_gpu&#x3D;2, workers_per_gpu&#x3D;2, train&#x3D;dict( type&#x3D;dataset_type, ann_file&#x3D;data_root + &#39;annotations&#x2F;instances_train2017.json&#39;, img_prefix&#x3D;data_root + &#39;train2017&#x2F;&#39;, pipeline&#x3D;train_pipeline), val&#x3D;dict( type&#x3D;dataset_type, ann_file&#x3D;data_root + &#39;annotations&#x2F;instances_val2017.json&#39;, img_prefix&#x3D;data_root + &#39;val2017&#x2F;&#39;, pipeline&#x3D;test_pipeline), test&#x3D;dict( type&#x3D;dataset_type, ann_file&#x3D;data_root + &#39;annotations&#x2F;instances_val2017.json&#39;, img_prefix&#x3D;data_root + &#39;val2017&#x2F;&#39;, pipeline&#x3D;test_pipeline)) test1python tools/test.py configs/retinanet/retinanet_r50_fpn_1x_coco.py checkpoints/retinanet_r50_fpn_1x_coco_20200130-c2398f9e.pth --show 1python tools/test.py configs/retinanet/retinanet_r50_fpn_1x_coco.py work_dirs/latest.pth --out test_result/latest.pkl --eval bbox --show-dir detect_results mmdetection 结果炫酷可视化 TSNE热力图(好看的colorbarhttps://www.cnblogs.com/zb-ml/p/13561449.html) docker环境1docker run -dit --name sty_cell --gpus all -p 10022:22 --shm-size=16g -v /mnt/sda/sty/data:/Data nvidia/cuda:11.2.2-cudnn8-devel-ubuntu18.04 创建docker环境，安装anaconda，安装mmcv mmdet 训练faster-rcnn修改 /mmdet/datasets/coco.py 1CLASSES = ( &#x27;Prim&#x27;, &#x27;Lym&#x27;, &#x27;Mono&#x27;, &#x27;Plas&#x27;, &#x27;Red&#x27;,&#x27;Promy&#x27;,&#x27;Myelo&#x27;,&#x27;Late&#x27;,&#x27;Rods&#x27;,&#x27;Lobu&#x27;,&#x27;Eosl&#x27;) 修改config/_base_/models/faster_rcnn_r50_fpn.py 1num_classes=11 指定GPU训练数据集 1CUDA_VISIBLE_DEVICES&#x3D;1 python tools&#x2F;train.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py --work-dir work_dir&#x2F;faster_rcnn","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"mmdetection结果评估","slug":"深度学习/mmdetection 结果评价函数","date":"2021-12-20T02:29:10.000Z","updated":"2022-01-19T04:28:06.645Z","comments":true,"path":"2021/12/20/深度学习/mmdetection 结果评价函数/","link":"","permalink":"http://abeltian.top/2021/12/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection%20%E7%BB%93%E6%9E%9C%E8%AF%84%E4%BB%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"mmdetection 结果评价函数{‘bboxes’: array([[119., 111., 244., 252.]], dtype=float32), ‘labels’: array([8]), ‘bboxes_ignore’: array([], shape=(0, 4), dtype=float32), ‘masks’: [[[119.0, 111.0, 244.0, 252.0]]], ‘seg_map’: ‘ER0437_233.png’} 1python tools&#x2F;test.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py work_dir&#x2F;faster_rcnn&#x2F;epoch_80.pth --work-dir . --out .&#x2F;tmp.pkl 1python tools&#x2F;analysis_tools&#x2F;analyze_results.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py .&#x2F;tmp.pkl .&#x2F;results 1python tools&#x2F;train.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py --work-dir&#x2F; .&#x2F;work_dirs&#x2F;faster_rcnn1 COCO数据集标注文件有三种信息 annotations标注的列表 123456789101112&#123; &quot;id&quot;: 1655, &quot;image_id&quot;: 1011, &quot;category_id&quot;: 1, &quot;bbox&quot;: [ 38.760299625468164, 84.26966292134831, 100.1198501872659, 90.47940074906366 ], &quot;area&quot;: 9058.784048029847&#125; categories标注列表 1234&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Prim&quot; &#125; images列表 123456&#123; &quot;height&quot;: 363, &quot;width&quot;: 360, &quot;id&quot;: 0, &quot;file_name&quot;: &quot;ER0437_233.jpg&quot;&#125; coco_eval做了些什么？ 首先创建哈希表，_gts与_dts键位image_id与category_id，值为标注与预测bbox与类别信息。 分析结果对结果进行分析 mmdetection检测结果单纯用Precision与Recall评价检测器并不公平，AP计算了不同Recall下的Precision，综合性地评价了检测器，PR曲线，对所有BBox给出的置信度从高到低进行排序，当把置信度取某一个值S时，依次对前n个大于置信度的BBox计算Precison与Recall得到一组(P, R)结果。在计算AP时，都要对P-R曲线做一次修正，将P值修正为当r&gt;R时最大的P $$ Precision = \\frac{TP}{TP + FP} \\ Recall = \\frac{TP}{TP + FN} \\ AP = \\int_{0}^{1} \\max({P(r) | r \\ge R}) dR $$ 对于BBox是TP还是FP的算法判断，如某一个BBox预测的label为1，则需要计算其与该图片中所有label为1的GT Box的IOU值，当大于iou_thres时，则该预测box为TP，否则为FP。当某一个GT被置信度最大的BBox匹配后，会从GT Box集合中移除。 TP + FN为测试集中该种类的样本的个数，因此不需要计算FN的个数，一个BBox与GT BOX是一一对应的，最后未检出的GT为FN 类别平衡问题，mAP，所有类别的检测性能(AP)取平均，就是检测算法在这个IOU下的性能。 位置偏差 不同场景下对预测位置准确度的要求不同。 mmAP，设置一组iou阈值，每一个IOU https://zhuanlan.zhihu.com/p/60707912 画出不同IOU下的PR曲线。 可以计算一个mAP，对这些性能取平均，在coco数据集中，mAP的计算针对10个IOU阈值下的AP取平均值np.linspace(0.5, 0.95, 10)。 https://blog.csdn.net/lppfwl/article/details/108018950 https://zhuanlan.zhihu.com/p/55575423","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"","slug":"深度学习/# 训练结果","date":"2021-11-29T04:11:03.074Z","updated":"2021-11-29T13:03:34.045Z","comments":true,"path":"2021/11/29/深度学习/# 训练结果/","link":"","permalink":"http://abeltian.top/2021/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/#%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/","excerpt":"","text":"训练结果使用AdamW余弦退火算法，参数如下的训练结果12021.11.29 今日跑完了transformer-fg 结果一般 到了80%的准确度后未提升。训练faster-rcnn 计算map各个分类下的曲线 明日计划完成faster-rcnn输出的特征热力图，与各个分类的map曲线，画一下分类Token的TSNE降维后的数据。 文献调研，调研一下骨髓血细胞分类的历史文献，并做PPT。","categories":[],"tags":[]},{"title":"Ant Design UI框架","slug":"深度学习/Ant Design UI框架学习","date":"2021-10-26T02:29:10.000Z","updated":"2022-01-19T04:25:38.937Z","comments":true,"path":"2021/10/26/深度学习/Ant Design UI框架学习/","link":"","permalink":"http://abeltian.top/2021/10/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Ant%20Design%20UI%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Ant Design UI框架学习https://www.jianshu.com/p/700777ea9db0 采用钩子函数useState，使该函数成为有状态函数组件","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"pytorch tensor张量","slug":"深度学习/Pytorch Tensor","date":"2021-10-19T02:29:10.000Z","updated":"2022-01-19T04:30:05.042Z","comments":true,"path":"2021/10/19/深度学习/Pytorch Tensor/","link":"","permalink":"http://abeltian.top/2021/10/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch%20Tensor/","excerpt":"","text":"Pytorch Tensorhttps://zhuanlan.zhihu.com/p/64551412 $\\qquad$Tensor多维数组底层实现是使用一块连续内存的1维数组，Tensor在元信息里保存了多维数组的形状，在访问元素时，通过多维度索引转化成1维数组相对于数组起始位置的偏移量即可找到对应的数据。 $\\qquad$某些Tensor操作（如transpose、permute、narrow、expand）与原Tensor是共享内存中的数据，不会改变底层数组的存储，但原来在语义上相邻、内存里也相邻的元素在执行这样的操作后，在语义上相邻，但在内存不相邻，即不连续了（is not contiguous）。 12345def window_partition(x, window_size): B, H, W, C = x.shape x = x.view(B, H // window_size, window_size, W // window_size, window_size, C) windows = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C) return windows 以上述代码为例，在permute后，只是改变了tensor的元信息，现坐标相对于一维数组的变化，上述代码permute后，每个坐标对应的stride会发生改变。stride可以理解为每个下标的权重。 数组 t 在内存中实际以一维数组形式存储，通过 flatten 方法查看 t 的一维展开形式，实际存储形式与一维展开一致。","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"骨髓血细胞检测","slug":"文献阅读/骨髓血细胞检测","date":"2021-10-14T13:53:31.000Z","updated":"2021-10-20T11:30:55.992Z","comments":true,"path":"2021/10/14/文献阅读/骨髓血细胞检测/","link":"","permalink":"http://abeltian.top/2021/10/14/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/%E9%AA%A8%E9%AB%93%E8%A1%80%E7%BB%86%E8%83%9E%E6%A3%80%E6%B5%8B/","excerpt":"","text":"文献阅读Morphogo: An Automatic Bone Marrow Cell Classification System on Digital Images Analyzed by Artificial Intelligence骨髓血细胞检测难点 正常骨髓中的细胞类别较多，包含处于不同发育阶段从早期到功能成熟的的间充质细胞、内皮细胞和造血细胞 Human-level recognition of blast cells in acute myeloid leukaemia with convolutional neural networks 数字化过程，使用低倍镜，选择单层细胞且无重叠区域，每个细胞的形态学特征可以更好的被识别，将细胞划分与 AML 的形态学分类相关的子类别。对于每个AOI，使用100倍的油浸镜挑选并标注100个左右的白细胞。 观察者间的差异，多人对同一批数据进行标注。 观察者内部的差异与自我一致性，多个月后同一人重新标注。 采用Resnext网络，采用五折交叉验证进行训练，对于数据集采用随机划分的方式。可以按病人进行划分，避免训练与测试集的相关性，但是检测结果差别不大。 类别不均衡问题采用旋转，随机水平或者垂直反转来扩充数据集。 评价指标，准确率、敏感性、特异性。positave与negative是指是否属于某一个特定类别的数量。TP与TF为网络正确判定是否属于该类别图像的数量。 gold standard annotation 最佳标注的一种描述。通过该细胞与其他区域细胞的对比确定该细胞的类别。 描述网络检测结果 混淆矩阵，特征图 Hierarchical Vision Transformer using Shifted Windows 自然语言处理与视觉任务的差别，视觉目标尺寸变化较大 ，而自然语言处理中的word token大小固定。对于高分图像，self-attention计算复杂度是图像的大小的平方时间复杂度。 shift of the window VIT缺点 在密集的视觉任务或高分辨图像中，不适合作为通用的backbone https://zhuanlan.zhihu.com/p/411311520 Squeeze-and-Excitation Networks convolutional filters are expected to be informative combinations by fusing spatial and channel-wise information together within local receptive fields. 自适应的调整通道间的相应，通过对通道间的相关性进行建模。","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"mmcv组件Runner","slug":"深度学习/mmcv组件Runner","date":"2021-10-13T08:47:04.000Z","updated":"2022-01-19T04:37:20.240Z","comments":true,"path":"2021/10/13/深度学习/mmcv组件Runner/","link":"","permalink":"http://abeltian.top/2021/10/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmcv%E7%BB%84%E4%BB%B6Runner/","excerpt":"","text":"MMCV组件RunnerRunner负责所有框架的训练过程调度。 配合各类的Hook，对外提供灵活的扩展能力。 123456789101112def val(self, data_loader, **kwargs): self.model.eval() self.mode = &#x27;val&#x27; self.data_loader = data_loader self.call_hook(&#x27;before_val_epoch&#x27;) time.sleep(2) # Prevent possible deadlock during epoch transition for i, data_batch in enumerate(self.data_loader): self._inner_iter = i self.call_hook(&#x27;before_val_iter&#x27;) self.run_iter(data_batch, train_mode=False) self.call_hook(&#x27;after_val_iter&#x27;) self.call_hook(&#x27;after_val_epoch&#x27;) 在测是流程中，call_hook函数来按照优先级执行hook的不同阶段(e.g. after_val_epoch)的功能。 123def call_hook(self, fn_name): for hook in self._hooks: getattr(hook, fn_name)(self) 如何修改mmdetection中的验证流程代码在配置中默认validate变量为true 注册eval hooks，Hook类为EvalHook 在runner的流程中，在一个epoch后会执行EvalHook的after_train_epoch代码，其调用_do_evaluate 12345def _do_evaluate(self, runner): &quot;&quot;&quot;perform evaluation and save ckpt.&quot;&quot;&quot; results = self.test_fn(runner.model, self.dataloader) runner.log_buffer.output[&#x27;eval_iter_num&#x27;] = len(self.dataloader) key_score = self.evaluate(runner, results) 之后调用runner类的evaluate函数，调用datasets的evaluate函数，并将结果写入到runner.logger中，其是一个OrderedDict()字典结构(按照key插入顺序输出)，并将ready状态设置为True 修改自己数据集的evalute函数，如imagenet数据集的evaluate函数","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"mmclassification","slug":"深度学习/mmclassification","date":"2021-10-10T11:47:16.000Z","updated":"2022-01-19T04:37:20.264Z","comments":true,"path":"2021/10/10/深度学习/mmclassification/","link":"","permalink":"http://abeltian.top/2021/10/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmclassification/","excerpt":"","text":"mmclassification训练train生成imagenet数据集 修改模型配置文件resnext50_32x4d.py修改输出类别 修改datasets imagenet.py CLASSES列表变量 1CLASSES &#x3D; [&#39;Prim&#39;, &#39;Lym&#39;, &#39;Mono&#39;, &#39;Plas&#39;, &#39;Red&#39;, &#39;Promy&#39;, &#39;Myelo&#39;, &#39;Late&#39;, &#39;Rods&#39;, &#39;Lobu&#39;, &#39;Eosl&#39;] 1python tools/train.py configs/resnet/resnet50_b32x8_imagenet.py --work-dir work_dirs swin_transformer1python tools/train.py configs/swin_transformer/swin_small_224_b16x64_300e_imagenet.py --work-dir work_dirs_swin test1python tools/test.py configs/resnet/resnet50_b32x8_imagenet.py work_dirs/latest.pth --out result_test/resnet.pkl --metrics precision --out-items all 分析结果 1python tools&#x2F;analysis_tools&#x2F;analyze_results.py configs&#x2F;swin_transformer&#x2F;swin_small_224_b16x64_300e_imagenet.py result_test&#x2F;resnet.pkl --out-dir result_test 训练swin_transformer 1python tools&#x2F;train.py configs&#x2F;swin_transformer&#x2F;swin_small_224_b16x64_300e_imagenet.py --work-dir work_dir_swin --resume-from work_dirss&#x2F;latest.pth 测试swin_transformer 1python tools/test.py configs/swin_transformer/swin_small_224_b16x64_300e_imagenet.py work_dirs_swin/epoch_122.pth --out result_test/swin.pkl --metrics precision --out-items all 分析结果 1python tools/analysis_tools/analyze_results.py configs/swin_transformer/swin_small_224_b16x64_300e_imagenet.py result_test/swin.pkl --out-dir result_test 训练在mmdetection上修改vit-transformer，尝试修改成为transformer-FG 1python tools&#x2F;train.py configs&#x2F;vision_transformer&#x2F;vit-base-p16_ft-64xb64_in1k-384.py --work-dir work_dir&#x2F;vit_fine_grained --resume-from work_dir&#x2F;vit&#x2F;latest.pth","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"","slug":"深度学习/骨髓血细胞分类标准","date":"2021-10-09T08:54:33.465Z","updated":"2021-10-09T12:32:21.686Z","comments":true,"path":"2021/10/09/深度学习/骨髓血细胞分类标准/","link":"","permalink":"http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%AA%A8%E9%AB%93%E8%A1%80%E7%BB%86%E8%83%9E%E5%88%86%E7%B1%BB%E6%A0%87%E5%87%86/","excerpt":"","text":"骨髓血细胞分类标准嗜酸、碱、中主要是针对细胞染色而言的， 嗜酸性：组织和细胞成分对酸性染料（如伊红）的亲和性 嗜碱性：组织和细胞成分对碱性染料（含有阳离子着色基团的染料，如苏木精、结晶紫、美蓝等）的亲和性。 淋巴细胞，胞体小，胞质少，胞核规则，染色质致密。 单核细胞 胞体较大，胞核有折叠，染色质偏细，较疏松 中英文对照 Neutrophils Eosinophlis basophils myeloblast promyelocyte myelocyte metamyelocyte 嗜中性粒细胞 嗜酸性粒细胞 嗜碱性粒细胞 原始粒细胞 早幼粒细胞 中幼粒细胞 晚幼粒细胞 https://www.bilibili.com/video/BV1tT4y1F76L?p=1","categories":[],"tags":[]},{"title":"","slug":"深度学习/ssh配置文件与使用","date":"2021-10-09T08:54:33.463Z","updated":"2021-10-09T08:54:33.463Z","comments":true,"path":"2021/10/09/深度学习/ssh配置文件与使用/","link":"","permalink":"http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ssh%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"ssh配置文件与使用https://www.cnblogs.com/xjshi/p/9146296.html","categories":[],"tags":[]},{"title":"损失函数","slug":"深度学习/loss函数","date":"2021-10-09T02:29:10.000Z","updated":"2022-01-19T04:26:13.981Z","comments":true,"path":"2021/10/09/深度学习/loss函数/","link":"","permalink":"http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/loss%E5%87%BD%E6%95%B0/","excerpt":"","text":"loss函数BCE Loss适用于二分类$$-ylog(\\hat{y}) - (1 - y) log(1 - \\hat{y})$$ CE loss当是多分类时，经过softmax后，只需要让GT对应类别输出尽量为1即可 Focal lossmmdet/models/losses/focal_loss.py","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"卷积与梯度","slug":"深度学习/卷积与梯度","date":"2021-10-04T02:39:42.000Z","updated":"2021-10-09T08:54:33.464Z","comments":true,"path":"2021/10/04/深度学习/卷积与梯度/","link":"","permalink":"http://abeltian.top/2021/10/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E4%B8%8E%E6%A2%AF%E5%BA%A6/","excerpt":"","text":"Pytorch 卷积与梯度反向传播pytorch计算图https://zhuanlan.zhihu.com/p/33378444 https://towardsdatascience.com/pytorch-autograd-understanding-the-heart-of-pytorchs-magic-2686cd94ec95 https://zhuanlan.zhihu.com/p/69175484 这篇写的比较全，光说不练，假把式；光练不说，傻把式；连说带练~~真！把！式！’” https://blog.csdn.net/cedi9117/article/details/106955001/ pytorch tensor计算 将梯度想象为小格子，因此同一层节点梯度是相加的，不同层的节点梯度是相乘的 理解一下$$z = f + g \\dz = k(df + dg) \\z = f * g * h \\z + dz = (f + df)(g + dg)(h + dh) 忽略高阶项$$https://zhuanlan.zhihu.com/p/27783097 Pytorch是利用Variable与Function来构建计算图的。Variable就像是计算图中的节点，保存计算结果（包括前向传播的激活值，反向传播的梯度），而Function就像计算图中的边，实现Variable的计算，并输出新的Variable。 torch.autograd.Funtion 矩阵求导 https://zhuanlan.zhihu.com/p/262751195 利用pytorch实现卷积运算 https://zhuanlan.zhihu.com/p/349683405，爱因斯坦求和标记","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"python项目框架学习","slug":"深度学习/python项目框架学习","date":"2021-09-28T09:36:18.000Z","updated":"2022-01-19T04:29:01.808Z","comments":true,"path":"2021/09/28/深度学习/python项目框架学习/","link":"","permalink":"http://abeltian.top/2021/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"python代码组织结构https://blog.csdn.net/weixin_38256474/article/details/81228492 python 模块包(module package)，当目录中包含了__init__.py时，当用import导入该目录时，会执行__init__.py中的代码。该文件的作用相当于将自身整个文件夹当作一个包来管理。 from xxx import *是如何实现的，__init__.py中的__all__变量关联了一个模块列表，制定哪些模块会被import进当前的作用域中。 python 命名空间 local namespace 函数或类方法 global namespace 当前模块 build_in namespace build_in空间 对于闭包，若在local namespace找不到变量，则下一个查找目标是父函数的local namespace 模块内置属性 __name__直接运行本模块，值为__main__, import module为模块名字 __file__当前module的绝对路径 __dict__,__doc__,__package__,__path__ python import运行机制 step1：创建一个新的、空的module对象（它可能包含多个module）；step2：将该module对象 插入sys.modules中；step3：装载module的代码（如果需要，需先编译）；step4：执行新的module中对应的代码。 导入模块分为三类，第一类：导入 Python 内置模块，第二类：导入相关的第三方库模块，第三类：导入程序本地的模块 (即当前应用的模块)。导入不同类别模块时，需要使用空行进行分开。 123456789# 内置模块import time import os# 第三方模块import flask# 本地模块from .xxx import xxx 绝对导入，从项目的根文件夹到要导入模块的完整路径。 相对导入，相对当前模块路径要导入资源的位置。 隐式相对导入(python3中不推荐) import module vs from . import module python装饰器函数https://www.cnblogs.com/f-ck-need-u/p/10198247.html https://www.cnblogs.com/f-ck-need-u/p/10205168.html 闭包如果想要在内函数中修改外函数的值，需要使用 nonlocal 关键字声明变量，闭包主要用于装饰器的实现。 装饰器 在mmdetection中的使用装饰器的关键特性是在被装饰的函数被定义之后立刻执行，通常是在导入(import, from xx import xxx)，即python模块加载时。 内置属性__call__ 该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。 __repr__ 会返回和调用者有关的 “类名+object at+内存地址”信息。print(object)，类实例化对象的自我描述信息","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"pytorch与mmcv源码学习","slug":"深度学习/pytorch与mmcv源码学习","date":"2021-09-27T13:16:44.000Z","updated":"2022-01-19T04:30:36.995Z","comments":true,"path":"2021/09/27/深度学习/pytorch与mmcv源码学习/","link":"","permalink":"http://abeltian.top/2021/09/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E4%B8%8Emmcv%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"MMCV官方文档https://mmcv.readthedocs.io/en/latest/api.html#module-mmcv.cnn mmdetection中使用了注册机制，使用字典进行字符串向类的映射，在norm.py中，使用了如下的代码，以norm layer为例。 123456789/mmcv/cnn/bricks/registry.pyNORM_LAYERS = Registry(&#x27;norm layer&#x27;)/mmcv/cnn/bricks/norm.pyNORM_LAYERS.register_module(&#x27;BN&#x27;, module=nn.BatchNorm2d)NORM_LAYERS.register_module(&#x27;BN1d&#x27;, module=nn.BatchNorm1d)NORM_LAYERS.register_module(&#x27;BN2d&#x27;, module=nn.BatchNorm2d)registry类实现在mmcv/runner/utils/registry.py文件中 build_norm_layer函数，通过type”BN”返回提前注册的类nn.BatchNorm2d，并用该类根据输入的num_features构造相应的归一化层，默认需要梯度(requires_grad=True)。 Pytorch源码学习nn.Module torch.utils.checkpoint 不缓存中间变量，时间换显存空间 ResNet源码阅读 在mmcv的resnet.py文件中，对于resnet18与34，对应的block为BasicBlock，而50层以上的block为Bottleneck卷积层分为stem与四个stage，stride=(1, 2, 2, 2)，stride=2是第一个3x3的卷积层。在reset中，只有第一个块的stride是2，其余均为1。 self.downsample在第一层需要对原输入x进行大小与通道数的调整，后续的block不需要进行该操作。 12if self.downsample is not None: identity = self.downsample(x) 代码中的dcn为可变形卷积(deformable convlution) _freeze_stage，将前几个stage的梯度更新设置为false，model设置为eval()模式。 block 每一个模块有num_blocks，对于blocks之间的连接，只有第一个block是进行残差学习。 在每一个block连接中，inplanes = planes * expansion，在每一个res_layer之间的连接中，planes = base_channels * 2 ** i ，在res_layer结束后，将inplanes设置为当前的planes * expansion model.eval()eval将dropout层设置为无效，batchnorm层的running_mean、running_var不更新。BatchNorm层的均值与方差采用momentum进行更新$\\hat{x}_{new} = (1 - momentum) \\times \\hat{x} + momentum \\times x_t$。 drop_out实现原理 12345678def dropout(X,drop_prob): X = X.float() assert 0&lt;=drop_prob&lt;=1 keep_prob = 1-drop_prob if keep_prob==0: return torch.torch.zeros_like(X) mask = (torch.rand(X.shape)&lt;keep_prob).float() return mask * X / keep_prob","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"2021秋季lccup战队赛","slug":"数据结构与算法/2021lccup","date":"2021-09-26T08:48:23.000Z","updated":"2021-10-09T08:54:33.460Z","comments":true,"path":"2021/09/26/数据结构与算法/2021lccup/","link":"","permalink":"http://abeltian.top/2021/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2021lccup/","excerpt":"","text":"比赛的时候是用C++写的，也是按照这个思路，按照行、列、主对角线、次对角线进行分类。这样可以将二维的坐标压缩到一维进行判断，且行，列，对角线的判断方法完全相同。 判断黑棋第一步赢，与白棋第二步赢比较简单。 黑棋第一步赢，则放入后黑棋后，连起来为五个黑子。这样的位置大于等于一个即可 白棋第二步赢，则首先不存在黑棋一步赢的情况，放入白棋后连续白子超过五个，这样的位置需要大于等于两个，因为黑棋第一步可以堵入一个位置。 判断黑棋第三步赢，则相对复杂些 如果白棋存在五连的情况，第一步首先要填入白棋的位置，然后按照黑棋一步赢的情况查找可行位置，不过这种位置需要大于等于两个 填入某个黑色棋子后，可以五连的位置大于等于两个，采用defaultdict(set)来记录某个位置对应可行位置的集合 如果是三或四个棋子，则坐标的max - min一定要小于等于4，这几个棋子才有可能五连。然后枚举所有可行的最小的位置(区间[max - 4, min])，并定义为start，查找不在[start, start + 4]的空位置，按棋子个数为3，4分情况讨论。 比赛时候没有想到上述做法，而是直接进行枚举所有三个，四个棋子的情况。三个棋子时有$C_5^3$共10种情况，代码写的很长，还漏了边界case。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution: def gobang(self, pieces: List[List[int]]) -&gt; str: black = [defaultdict(set) for _ in range(4)] white = [defaultdict(set) for _ in range(4)] # 行、列、主对角线，次对角线 def add_pieces(x, y, c): p = black if c == 1: p = white p[0][x].add(y) p[1][y].add(x) p[2][x - y].add(y) p[3][x + y].add(y) def get_pos(x, y, k): if k == 0: return x, y elif k == 1: return y, x elif k == 2: return x + y, y else: return x - y, y def find_pos(p, q, space): pos = defaultdict(set) for k in range(4): for idx, se in p[k].items(): vec = sorted(list(se)) for i in range(len(vec) - space + 1): start, end = vec[i], vec[i + space - 1] if end - start &gt; 4: continue # s为所有可能五连的起点 for s in range(end - 4, start + 1): arr = [v for v in range(s, s + 5) if v not in vec[i:i + space] and v not in q[k][idx]] if len(arr) == 2 and space == 3: x1, y1 = get_pos(idx, arr[0], k) x2, y2 = get_pos(idx, arr[1], k) pos[(x1, y1)].add((x2, y2)) pos[(x2, y2)].add((x1, y1)) if len(arr) == 1 and space == 4: x, y = get_pos(idx, arr[0], k) pos[(x, y)].add((x, y)) return pos for x, y, c in pieces: add_pieces(x, y, c) # 黑棋第一步赢，则可放入位置大于等于1 b1_pos = find_pos(black, white, 4) if len(b1_pos) &gt;= 1: return &#x27;Black&#x27; # 白棋第二步赢，则可放入位置大于1 w2_pos = find_pos(white, black, 4) if len(w2_pos) &gt; 1: return &#x27;White&#x27; # 白棋如果存在可赢的位置，则需要填入黑棋 if len(w2_pos) == 1: for x, y in w2_pos.keys(): add_pieces(x, y, 0) b3_pos = find_pos(black, white, 4) if len(b3_pos) &gt; 1: return &#x27;Black&#x27; else: b3_pos = find_pos(black, white, 3) for p, cnt in b3_pos.items(): if len(cnt) &gt;= 2: print(p, cnt) return &#x27;Black&#x27; return &#x27;None&#x27;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"initialize神经网络","slug":"深度学习/initialize神经网络","date":"2021-09-26T08:48:23.000Z","updated":"2021-10-02T05:49:06.313Z","comments":true,"path":"2021/09/26/深度学习/initialize神经网络/","link":"","permalink":"http://abeltian.top/2021/09/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/initialize%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"https://www.jianshu.com/p/f2d800388d1c 神经网络是个系统工程，数据、参数、模型内部结构、训练策略、学习率等等，这些因素不管哪一部分出错，它都不会报错，只是会输出一些不是你想要的结果。Batch Normalization 输出的blob大小为(N, C, H, W)，在每一层Normalization就是基于N * H * W个数值求平均，以及方差。","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"retinaNet网络","slug":"深度学习/retinaNet网络","date":"2021-09-23T07:43:25.000Z","updated":"2022-01-19T04:30:48.683Z","comments":true,"path":"2021/09/23/深度学习/retinaNet网络/","link":"","permalink":"http://abeltian.top/2021/09/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/retinaNet%E7%BD%91%E7%BB%9C/","excerpt":"","text":"RetinaNethttps://zhuanlan.zhihu.com/p/346198300 什么是anchorhttps://zhuanlan.zhihu.com/p/55824651 Head模块路径mmdetection/mmdet/models/dense_heads/retina_head.py head包含两个子网络 分类与锚框回归分支，两个分支不共享权重，但分支内五个FPN输出特征图权重是共享的。head中的卷积网络为五层，前四层的通道数均为256，最后一层的通道数量 分类为self.num_anchors * self.cls_out_channels，回归为self.num_anchors * 4 1234if self.use_sigmoid_cls: self.cls_out_channels = num_classeselse: self.cls_out_channels = num_classes + 1 mmcv.cnn.conv_module包含了卷积、norm、activate三个层。 BBox AssignerRetinaNet属于anchor-based算法，在bbox分配前需要得到特征图每个位置的anchor列表 参数配置定义 12345678910anchor_generator=dict( type=&#x27;AnchorGenerator&#x27;, # anchor基准大小 octave_base_scale=4, # 每个特征图anchor有三个尺度 2 ** 0、 2 **(1 / 3) = 1.2599、2 ** (2 / 3) = 1.5874 scales_per_octave=3, # 每个特征图anchor有三种宽高比 ratios=[0.5, 1.0, 2.0], # 特征图对于原图的stride strides=[8, 16, 32, 64, 128]), 生成anchor_generator对象，对于生成的9个anchor，组内的大小为octave_base_scale * strides在乘上相应的尺度因子。x坐标从左往右递增，y坐标从上往下递增，最左上方可见像素的坐标是（0，0） Anchor Generator代码位置mmdet/core/anchor/anchor_generator.py 核心函数gen_single_level_base_anchors 12345def gen_single_level_base_anchors(self, base_size, scales, # 尺度因子 这里包含了octave_base_scale的系数 ratios, # 高宽比 center=None): 生成9个anchor 分成三组，每组内的ratio高宽比相同。 _meshgrid函数快速根据一维x，y坐标生成二维的索引坐标 1234567 x = torch.tensor(np.array(range(2))) y = x.clone() xx = x.repeat(y.shape[0]) yy = y.view(-1, 1).repeat(1, x.shape[0]).view(-1)# xx tensor([0, 1, 0, 1])# yy tensor([0, 0, 1, 1]) shifts = torch.stack([shift_xx, shift_yy, shift_xx, shift_yy], dim=-1) 对第最后一个维度进行拼接 mmdetection中的Retinanet类在mmdetection中并未对Retinanet做特殊实现，只是用参数初始化了父类SingleStageDetector ，实现文件为mmdet/models/detectors/single_stage.py 1234567891011class RetinaNet(SingleStageDetector): def __init__(self, backbone, neck, bbox_head, train_cfg=None, test_cfg=None, pretrained=None, init_cfg=None): super(RetinaNet, self).__init__(backbone, neck, bbox_head, train_cfg, test_cfg, pretrained, init_cfg)","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"}]},{"title":"检测网络","slug":"深度学习/检测网路","date":"2021-09-20T09:28:01.000Z","updated":"2022-01-19T04:32:29.710Z","comments":true,"path":"2021/09/20/深度学习/检测网路/","link":"","permalink":"http://abeltian.top/2021/09/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%A3%80%E6%B5%8B%E7%BD%91%E8%B7%AF/","excerpt":"","text":"目标检测中常见的网络结构FCN 网络Fully Convolutional Networks for Semantic Segmentation，深度学习在图像分割的代表作，FCN中所有层都是卷积层，故称全卷积网络。 https://zhuanlan.zhihu.com/p/31428783 CNN语义分割基本套路 降采样，上采样，裁减。convlution + deconvlution/ resize 多尺度特征融合：特征点逐点相加/特征channel维度拼接 获得像素级别的segement map 对每一个像素点进行类别判断。 FPN 网络https://zhuanlan.zhihu.com/p/92005927 具有侧向连接（lateral connections）的网络结构，构建不同尺寸具有高级语义信息的特征图。 融合低分辨率具有较强语义信息的特征图、高分辨率语义信息较弱，但空间信息丰富的特征图。 RPN网络https://zhuanlan.zhihu.com/p/31426458 Faster RCNN使用RPN网络生成检测框，能极大提升检测框的生成速度。 anchor定义, 特征图上的每个点，对应原图像上的一块区域。 定义anchor $A = (A_x, A_y, A_w, A_h)$，$GT = (G_x, G_y, G_w, G_h)$，寻找一种变换$F(A) = G$，该变换为平移与缩放$$G_x = x_a + w_a * d_x \\G_y = y_a + h_a * d_y \\G_w = w_a * e^{d_w} \\G_h = h_a * e^{d_h}$$ 当A与GT相差较小时，认为该变换参数是可以采用线性回归来建模$d_* = W^T * \\phi$，其中$\\phi$是特征图输出的特征向量 positive anchor与ground truth变换之间的平移量$t_x, t_y$，尺度因子$t_w, t_h$如下：$$t_x = (x - x_a) / w_a \\t_y = (y - y_a) / h_a \\t_w = log(w / w_a) \\t_h = log(h / h_a)$$对于回归分支，输入的是CNN特征，监督变量是anchor与GT的差距$t_x, t_y, t_w, t_h$，训练损失函数$$Loss = \\sum_i^N|t_^i - W_^T * \\phi(A^i)| + \\lambda||W_*||$$https://mp.weixin.qq.com/s/IJUMCOBhgXHv7VC1YT4q_g https://cloud.tencent.com/developer/article/1441555 ResNet残差学习网络 https://zhuanlan.zhihu.com/p/79378841 z","categories":[],"tags":[{"name":"deep learing","slug":"deep-learing","permalink":"http://abeltian.top/tags/deep-learing/"}]},{"title":"ST表","slug":"数据结构与算法/ST表","date":"2021-09-10T08:55:32.000Z","updated":"2021-10-02T05:49:06.312Z","comments":true,"path":"2021/09/10/数据结构与算法/ST表/","link":"","permalink":"http://abeltian.top/2021/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ST%E8%A1%A8/","excerpt":"","text":"题目https://www.luogu.com.cn/problem/P3865 给定一个长度为N的数列和M次询问，求出每一次询问的区间内数字最大值。 令f[i][j]表示区间$[i, i + 2^j - 1]$的最大值。根据倍增的思想，可以写出状态转移方程$f[i][j] = max(f[i][j - 1], f[i + 2^{j - 1}][j - 1])$ 因此对于每个询问[l, r]，我们将其分为两部分$[l, l + 2^s - 1], [r - 2^s + 1, r]$，其中$s = log_2(r - l + 1)$ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;static constexpr int MAXN = 1e5 + 5;int f[MAXN][21];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout); #endif int n, m, l, r, s; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; arr(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; f[i][0] = arr[i]; &#125; for (int j = 1; j &lt;= 20; j++) &#123; for (int i = 0; i + (1 &lt;&lt; (j - 1)) &lt; n; i++) &#123; f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r; s = log2(r - l + 1); cout &lt;&lt; max(f[l][s], f[r - (1 &lt;&lt; s) + 1][s]) &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"点在多边形内部","slug":"计算几何/点在多边形内部","date":"2021-05-21T12:36:37.000Z","updated":"2021-09-10T08:53:11.519Z","comments":true,"path":"2021/05/21/计算几何/点在多边形内部/","link":"","permalink":"http://abeltian.top/2021/05/21/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/","excerpt":"","text":"点在多边形内部射线法，从判断点向上做一条射线，当与多边形交点个数为奇数个时，则点在多边形内部。 边界条件(点在顶点上，点在边上，通过叉积等于0与点积小于等于0来判断） 边界条件，凸顶点判断一次，凹顶点判断两次 边界条件，当连线与边重叠时，不进行判断，点一定在多边形外部。 1((c.x &gt;= a.x &amp;&amp; c.x &lt; b.x) || (c.x &gt;= b.x &amp;&amp; c.x &lt; a.x)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;using LL = long long;struct Point &#123;public: int x, y; Point(int _x, int _y) : x(_x), y(_y) &#123;&#125; Point operator - (const Point&amp; rhs) &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125;&#125;;int dot(const Point&amp; a, const Point&amp; b) &#123; return a.x * b.x + a.y * b.y;&#125;int cross(const Point&amp; a, const Point&amp; b) &#123; return a.x * b.y - b.x * a.y;&#125;vector&lt;Point&gt; arr;bool in(Point c) &#123; int n = arr.size(); int ans = 0; for (int i = 0, j = n - 1; i &lt; n; j = i++) &#123; Point a = arr[j], b = arr[i]; if (dot(c - a, c - b) &lt;= 0 &amp;&amp; cross(c - a, c - b) == 0) return 0; if (((c.x &gt;= a.x &amp;&amp; c.x &lt; b.x) || (c.x &gt;= b.x &amp;&amp; c.x &lt; a.x)) &amp;&amp; c.y &lt; a.y + 1.0 * (b.y - a.y) / (b.x - a.x) * (c.x - a.x)) &#123; ans = !ans; &#125; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout); #endif int n, q, x, y; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; arr.push_back(&#123;x, y&#125;); &#125; cin &gt;&gt; q; int ans = 0; for (int i = 0; i &lt; q; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; if (in(&#123;x, y&#125;)) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"素数方法","slug":"数论/关于素数的一些方法","date":"2021-05-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.517Z","comments":true,"path":"2021/05/20/数论/关于素数的一些方法/","link":"","permalink":"http://abeltian.top/2021/05/20/%E6%95%B0%E8%AE%BA/%E5%85%B3%E4%BA%8E%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"关于素数的一些方法假设N为1e5，对1到N中所有的数做质因子分解。 12345678910111213141516171819static constexpr int N = 1e5 + 5;unordered_map&lt;int, int&gt; prime[N];bool isp[N];&#123; memset(isp, true, sizeof(isp)); for (int i = 2; i &lt; N; ++i) &#123; if (isp[i]) &#123; for (int j = i; j &lt; N; j += i) &#123; int cur = j, cnt = 0; while (cur % i == 0) &#123; cur /= i; ++cnt; &#125; prime[j][i] = cnt; isp[j] = false; &#125; &#125; &#125;&#125; 找到1到N中所有数的因数 123456vector&lt;int&gt; fact[N];for (int i = 1; i &lt; N; ++i) &#123; for (int j = 2 * i; j &lt; N; j += i) &#123; fact[j].push_back(i); &#125;&#125; 找到[1:m]中满足$gcd(n, p) = x$的$p$的数量。 $$gcd(n, p) = x \\\\n = a \\cdot x, p = b \\cdot x \\\\gcd(a, b) = 1$$找到[1:b]中gcd(a, b) = 1中数字的数量，计算[1:b]中gcd(a, b) != 1的数量, prime[a]为a的质因数分解。 12345678910111213141516171819int find(int a, int b) &#123; int ans = 0; vector&lt;int&gt; arr; for (auto it : prime[a]) &#123; arr.push_back(it.first); &#125; int sz = arr.size(); for (int i = 1; i &lt; (1 &lt;&lt; sz); ++i) &#123; int mul = 1, sign = -1; for (int j = 0; j &lt; sz; ++j) &#123; if (i &gt;&gt; j &amp; 1) &#123; mul *= arr[j]; sign *= -1; &#125; &#125; ans += sign * b / mul; &#125; return b - ans;&#125; 例题：https://codeforces.com/problemset/problem/1139/D 其中cnt为1到m中gcd(p, x) = y的p的数量。$$f[x] = 1 + \\frac{cnt}{m}f[y] + \\frac{\\frac{m}{x}}{m}f[x]$$","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"组合数学DP","slug":"组合数学/组合数学DP","date":"2021-05-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.518Z","comments":true,"path":"2021/05/20/组合数学/组合数学DP/","link":"","permalink":"http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6DP/","excerpt":"","text":"组合数学DP一个挺有意思的题目 https://cses.fi/problemset/task/1717 There are n children at a Christmas party, and each of them has brought a gift. The idea is that everybody will get a gift brought by someone else. In how many ways can the gifts be distributed?","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"错排公式","slug":"组合数学/错排公式","date":"2021-05-20T02:29:10.000Z","updated":"2022-01-19T04:22:50.054Z","comments":true,"path":"2021/05/20/组合数学/错排公式/","link":"","permalink":"http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/","excerpt":"","text":"错排公式错排问题，考虑$n$个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。记作$n$个元素的错排数为$D(n)$。 递推公式： 选择书的编号为m，剩下n - 1个位置，假设选择k k放入m的位置 则转化为$D(n - 2)$的错排方案数 第m本书在位置k不动，此时k不能放在第m个位置，其他n - 2本书也不在自己原本的位置，等价于求$n - 1$个数的错排 $$D(n) = (n - 1) *[D(n- 1) + D(n - 2)]$$ https://cses.fi/problemset/task/1717","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"Transformer Embedding","slug":"文献阅读/Transformer中的Embedding","date":"2021-05-20T02:29:10.000Z","updated":"2022-01-19T04:23:46.050Z","comments":true,"path":"2021/05/20/文献阅读/Transformer中的Embedding/","link":"","permalink":"http://abeltian.top/2021/05/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Transformer%E4%B8%AD%E7%9A%84Embedding/","excerpt":"","text":"Transformer中的Embeddinghttps://blog.csdn.net/qq_35799003/article/details/84780289 将词汇表中的每个单词进行one-hot编码存在的问题 稀疏向量过大，导致模型无法训练。向量间缺少距离的度量。 解决方案采用Embedding，将高纬稀疏向量映射到低维空间，同时保留语义关系。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"JAVA注解","slug":"JAVA/java注解","date":"2021-04-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.498Z","comments":true,"path":"2021/04/20/JAVA/java注解/","link":"","permalink":"http://abeltian.top/2021/04/20/JAVA/java%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"java注解注解可以被编译器打包进入class文件，是一种用作标注的元数据。 由编译器使用的注解@Override让编译器检查该方法是否正确地实现了覆写。这类注解不会被编译进入.class文件，在编译后就被扔掉了 由工具类处理.class文件使用的注解。 程序运行期能够读取的注解，加载后一直存在于JVM中，例如@PostConstruct方法在调用构造方法后自动被调用。 1.定义注解java语言使用@interface语法来定义注解(Annotation) 2.使用注解通常注解如何使用由程序自己决定。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"wilson定理","slug":"数论/wilson定理","date":"2021-04-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.516Z","comments":true,"path":"2021/04/20/数论/wilson定理/","link":"","permalink":"http://abeltian.top/2021/04/20/%E6%95%B0%E8%AE%BA/wilson%E5%AE%9A%E7%90%86/","excerpt":"","text":"wilson定理正整数n &gt; 1， 则n是一个素数当且仅当$(n - 1)! \\equiv -1 (mod\\ n)$ 如果n为非质数，假设集合A为${1, x_1, x_2,\\cdots x_{m - 1}, n - 1}$与n互质。 对于任意$x_i$，则$x_i \\cdot A$集合为${x_i,\\ x_i\\cdot x_1,\\ x_i \\cdot x_2,\\ \\cdots,\\ x_i \\cdot x_{m - 1},\\ x_i \\cdot (n - 1)}$, 对于其中$x_i\\cdot A$中任意一个元素其膜n的值互不相同，且为集合A中的元素，因此存在$x_i * x_j \\equiv 1 (mod\\ n)$，因为1和n - 1模n逆元为其本身，$x_i$的逆元为$x_j$$$(1\\times x_1 \\times x_2 \\times \\cdots x_m \\times n - 1) \\cdot (1\\times x_1 \\times x_2 \\times \\cdots x_m \\times n - 1) \\equiv (1 * 1) \\times (x_i * x_j) \\cdots \\times ((n - 1) * (n - 1)) \\equiv 1 (mod \\ n) \\\\令(1\\times x_1 \\times x_2 \\times \\cdots x_m \\times n - 1) = y \\\\y^2\\equiv 1 (mod\\ n)\\\\y \\equiv 1 (mod\\ n)\\ 或\\ y \\equiv n - 1 (mod\\ n)$$ $$x_i*x_j \\equiv x_i * x_k (mod\\ n) \\\\x_i * (x_j - x_k) \\equiv 0 (mod\\ n) \\\\(x_j - x_k) \\equiv 0 (mod\\ n) \\\\x_j = x_k$$","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"欧拉函数","slug":"数据结构与算法/欧拉函数","date":"2021-03-07T12:53:42.000Z","updated":"2021-09-10T08:53:11.513Z","comments":true,"path":"2021/03/07/数据结构与算法/欧拉函数/","link":"","permalink":"http://abeltian.top/2021/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"欧拉函数欧拉函数是小于或等于n的正整数中与n互质的数目，$\\phi(1) = 1$。 通式：$$\\phi(x)= x \\mathop{\\Pi}\\limits_{i = 1}^{n}(1 - \\frac{1}{p_i})$$若n是质数的p的k次幂，$\\phi(n) = p^k - p^{k - 1}$，因为除了p的倍数$p * (1,2\\dots p^{k - 1})$以外，其他数均与n互质。 线性筛，每个合数通过其最小的质因数筛掉。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"凸包","slug":"数据结构与算法/凸包","date":"2021-03-01T08:43:21.000Z","updated":"2021-09-10T08:53:11.507Z","comments":true,"path":"2021/03/01/数据结构与算法/凸包/","link":"","permalink":"http://abeltian.top/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%87%B8%E5%8C%85/","excerpt":"","text":"凸包二维凸包， 凸多边形是指所有内角大小都在$[0, \\pi]$范围内的简单多边形。在平面上能包含所有给定点的最小凸多边形叫做凸包。 Andrew算法$\\quad\\quad$首先将点集按照x坐标(第一关键字)，y坐标进行升序排列。显然排序后最小的元素和最大的元素一定在凸包上。他们之间的部分可以分成上下两条链分别求解。求下链时只要从小到大遍历排序后的点列，求上链从大到小遍历即可。 $\\quad\\quad$在凸包上，我们从一个点出发逆时针走，轨迹总是左拐的，如果出现右拐，则说明该段不在凸包上。采用栈来记录轨迹上已经走过的点，如果即将入栈的点$P$和栈顶点$S_1$构成的向量方向相较$S_2, S_1$构成向量的方向向右旋转，即叉积$\\vec{S_2S_1} \\times\\vec{S_1P} &lt; 0$，则弹出栈顶，直到$\\vec{S_2S_1} \\times\\vec{S_1P} \\geq 0$或栈内仅包含一个元素。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Point &#123; int x, y; Point(int _x, int _y) : x(_x), y(_y) &#123;&#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x == rhs.x ? y &lt; rhs.y : x &lt; rhs.x; &#125; Point operator - (const Point&amp; rhs) &#123; Point ret(0, 0); ret.x = x - rhs.x; ret.y = y - rhs.y; return ret; &#125; int operator ^ (const Point&amp; rhs) &#123; return x * rhs.y - y * rhs.x; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; outerTrees(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; vector&lt;Point&gt; arr; int n = points.size(); for (int i = 0; i &lt; n; ++i) &#123; arr.push_back(&#123;points[i][0], points[i][1]&#125;); &#125; sort(arr.begin(), arr.end()); int tp = 0; vector&lt;bool&gt; used(n, 0); vector&lt;int&gt; st(n + 5); for (int i = 0; i &lt; n; ++i) &#123; while (tp &gt;= 2 &amp;&amp; ((arr[st[tp]] - arr[st[tp - 1]]) ^ (arr[i] - arr[st[tp]])) &lt; 0) &#123; used[st[tp--]] = false; &#125; st[++tp] = i; used[i] = true; &#125; used[0] = false; for (int i = n - 1; i &gt;= 0; --i) &#123; if (used[i]) continue; while (tp &gt;= 2 &amp;&amp; ((arr[st[tp]] - arr[st[tp - 1]]) ^ (arr[i] - arr[st[tp]])) &lt; 0) &#123; used[st[tp--]] = false; &#125; st[++tp] = i; used[i] = true; &#125; vector&lt;vector&lt;int&gt;&gt; ret; for (int i = 1; i &lt; tp; ++i) &#123; ret.push_back(&#123;arr[st[i]].x, arr[st[i]].y&#125;); &#125; return ret; &#125;&#125;; 复杂度分析 时间复杂度，排序$O(n\\log n)$，上下链求解$O(2n)$ 空间复杂度，栈的最大深度为O(n)","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"跳表","slug":"数据结构与算法/跳表","date":"2021-02-27T03:46:47.000Z","updated":"2021-09-10T08:53:11.515Z","comments":true,"path":"2021/02/27/数据结构与算法/跳表/","link":"","permalink":"http://abeltian.top/2021/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/","excerpt":"","text":"跳表(Probabilistic Alternative to Balanced Trees)​ 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳表的期望空间复杂度为$O(n)$，跳表的查询，插入和删除操作的期望时间复杂度都为$O(logn)$。 ​ 链表加多级索引的结构就是跳表。跳表的每一层都是一个有序链表，每层位于第i层的节点有p的概率出现在第i+1层，p为常数。 复杂度证明空间复杂度​ 第一层的期望值为$n$, 第二层的期望值为$np$, 第三层的期望值为$np^2$，因此空间复杂度的期望值为$\\sum\\limits_{i = 0}^{+\\infty}np^i=\\frac{n}{1 - p}$。因为p为常数，因此跳表期望的空间复杂度为$O(n)$。 时间复杂度 跳表最后一层节点的个数为$\\frac{1}{p}$，因为再上一层的期望值为1(无意义)。因此层数m为$$np^{m - 1}=\\frac{1}{p} \\\\(\\frac{1}{p})^m=n \\\\m = \\log_{\\frac{1}{p}}n$$​ 跳表skiplist的平均查找长度，查找长度指的是查找路径上跨越的跳数，查找过程中的比较次数等于查找长度加1（每比较一次要么向下一层，要么到本层的右侧节点)。每个节点在进行插入的时候，它的层数是由随机函数randomLevel()计算出来的，随机的计算不依赖于其它的节点，每个节点是独立同分布的，每次插入过程都是完全独立的。 ​ 为了计算查找长度，我们将逆向还原查找过程，从右下方第一层最后到达的那个节点开始，沿着查找路径向左，向上回溯。假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。 如果某一个节点有上层节点的话，则我们需要向上走，整个查找过程类似楼梯的形状，每个节点第一被访问一定是位于其最顶层。 如果节点x有第i+1，那么我们需要向上走，这种情况概率为p 如果节点没有第i+1层指针，那么我们需要向左走，这种情况的概率为1-p 用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度，因此有$$C(k) = (1 - p)*(C(k) + 1) + p * (C(k - 1) + 1) \\\\C(k) = \\frac{1}{p} + C(k - 1) \\\\C(k) = \\frac{k}{p}$$n个节点跳表的层数为$\\log_{\\frac{1}{p}}n$， 因此所需时间为$\\frac{\\log_{\\frac{1}{p}}n}{p}$，即平均时间复杂度为$O(\\log n)$ 代码实现数据结构SkipListNode，skiplist真正有数据只有下面一层的数据节点，每个节点的后继就是level[0], 12345struct SkipListNode &#123; int val; vector&lt;SkipListNode *&gt; level; SkipListNode (int _val, int sz=32) : val(_val), level(sz, nullptr) &#123;&#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Skiplist &#123;private: SkipListNode *head, *tail; int level, length;public: static constexpr int MAXL = 32; static constexpr int P = 4; static constexpr int S = 0xFFFF; static constexpr int PS = S / 4; Skiplist() &#123; level = length = 0; tail = new SkipListNode(INT_MAX, 0); head = new SkipListNode(INT_MAX); for (int i = 0; i &lt; MAXL; ++i) &#123; head-&gt;level[i] = tail; &#125; &#125; SkipListNode* find(int val) &#123; SkipListNode *p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123; p = p-&gt;level[i]; &#125; &#125; p = p-&gt;level[0]; return p; &#125; bool search(int target) &#123; SkipListNode *p = find(target); return p-&gt;val == target; &#125; void add(int val) &#123; vector&lt;SkipListNode *&gt; update(MAXL); SkipListNode *p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123; p = p-&gt;level[i]; &#125; update[i] = p; &#125; int lv = randomLevel(); if (lv &gt; level) &#123; lv = ++level; update[lv - 1] = head; &#125; SkipListNode *newNode = new SkipListNode(val, lv); for (int i = lv - 1; i &gt;= 0; --i) &#123; p = update[i]; newNode-&gt;level[i] = p-&gt;level[i]; p-&gt;level[i] = newNode; &#125; ++length; &#125; bool erase(int val) &#123; vector&lt;SkipListNode *&gt; update(MAXL + 1); SkipListNode *p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123; p = p-&gt;level[i]; &#125; update[i] = p; &#125; p = p-&gt;level[0]; if (p-&gt;val != val) return false; for (int i = 0; i &lt; level; ++i) &#123; if (update[i]-&gt;level[i] != p) &#123; break; &#125; update[i]-&gt;level[i] = p-&gt;level[i]; &#125; while (level &gt; 0 &amp;&amp; head-&gt;level[level - 1] == tail) --level; --length; return true; &#125; int randomLevel() &#123; int lv = 1; while (lv &lt; MAXL &amp;&amp; (rand() &amp; S) &lt; PS) ++lv; return lv; &#125;&#125;; 参考文章http://zhangtielei.com/posts/blog-redis-skiplist.html ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf https://oi-wiki.org/ds/skiplist/#_4","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"JAVA反射","slug":"JAVA/JAVA反射","date":"2021-02-24T12:51:45.000Z","updated":"2021-09-10T08:53:11.498Z","comments":true,"path":"2021/02/24/JAVA/JAVA反射/","link":"","permalink":"http://abeltian.top/2021/02/24/JAVA/JAVA%E5%8F%8D%E5%B0%84/","excerpt":"","text":"JAVA 反射反射是为了解决运行期，对某个对象一无所知的情况下，调用其方法，JVM为每一个加载的class创建一个Class类型的实例，并关联起来。 通过Class实例获取class信息的方法称为反射(Reflection) 1. 访问字段 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。**** 2.调用方法3.调用构造方法、获取继承关系4.动态代理","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/tags/JAVA/"}]},{"title":"JAVA_Spring","slug":"JAVA/JAVA-Spring","date":"2021-02-24T12:17:40.000Z","updated":"2021-09-10T08:53:11.497Z","comments":true,"path":"2021/02/24/JAVA/JAVA-Spring/","link":"","permalink":"http://abeltian.top/2021/02/24/JAVA/JAVA-Spring/","excerpt":"","text":"IOC(Inversion of Control控制反转)应用本身不负责依赖对象的创建和维护，依赖对象的创建和维护是由外部容器负责的称为控制反转。 IOC容器管理的对象称为Bean，Bean是由Spring容器初始化，装配及管理的对象。 DI(Dependency Injection依赖注入)","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/categories/JAVA/"}],"tags":[{"name":"JAVA Spring","slug":"JAVA-Spring","permalink":"http://abeltian.top/tags/JAVA-Spring/"}]},{"title":"设计模式","slug":"JAVA/设计模式","date":"2021-02-22T12:03:14.000Z","updated":"2021-09-10T08:53:11.498Z","comments":true,"path":"2021/02/22/JAVA/设计模式/","link":"","permalink":"http://abeltian.top/2021/02/22/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式设计模式本质上是面向对象设计原则的实际运用。 1.1设计模式分类 创建型模式 结构型模式 行为型模式 UML 类图2.设计模式 代理模式：https://www.cnblogs.com/daniels/p/8242592.html 中介隔离作用， 代理类对象可以在客户类和委托对象之间起到中介的作用。 开闭原则，增加功能。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。可以通过给代理类增加额外的功能来扩展委托类的功能。 java动态代理 https://blog.csdn.net/yaomingyang/article/details/80981004","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://abeltian.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Miller-Rabin素数探测","slug":"数据结构与算法/Miller-Rabin素数探测","date":"2021-02-15T13:30:13.000Z","updated":"2021-09-10T08:53:11.502Z","comments":true,"path":"2021/02/15/数据结构与算法/Miller-Rabin素数探测/","link":"","permalink":"http://abeltian.top/2021/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Miller-Rabin%E7%B4%A0%E6%95%B0%E6%8E%A2%E6%B5%8B/","excerpt":"","text":"Miller-Rabin素数探测费马小定理，如果p为质数，且$gcd(a,p)=1$，那么$a^{p - 1} \\equiv 1 (mod\\ p)$， 如果p为质数，且a，p互质，那么a的p-1次方除以p的余数等于1。 二次探测定理， 如果p是素数，且x是小于p的正整数，且$x^2 \\equiv 1 (mod\\ p)$，那么$x = 1$或者$x =p - 1$。 Miller-Rabin素数探测，将p-1(偶数)表示为$d \\times 2^r$，其中d为奇数，如果p为素数，那么存在某个$0 \\le i &lt; r$使得$a^{d*2^{r - i}} mod\\ n = n - 1$，或者$a^d = 1$。 12345678910111213141516171819202122232425262728293031323334353637using ll = long long;vector&lt;int&gt; prime&#123;2, 3, 5&#125;;ll qpow(ll a, ll b, ll p) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125;// 如果是long long会发生溢出，则需要在模运算意义下计算快速积int TwiceDetect(ll a, ll b, ll p) &#123; int r = __builtin_ctz(b); ll d = b &gt;&gt; t; ll x, y; x = y = qpow(a, d, p); while (r--) &#123; y = x * x % p; if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != p - 1) return 1; //是合数返回1 x = y; &#125; return y != 1;&#125;bool miller_rabin(ll p) &#123; if (p == 2) return true; if (p &lt; 2 || p % 2 == 0) return false; for (int i = 0; i &lt; 3; ++i) &#123; ll base = prime[i]; if (p == base) return true; if (TwiceDetect(base, p - 1, p)) return 0; &#125; return 1;&#125;","categories":[],"tags":[{"name":"Data Stucture","slug":"Data-Stucture","permalink":"http://abeltian.top/tags/Data-Stucture/"}]},{"title":"线段树I","slug":"数据结构与算法/线段树I","date":"2021-02-05T10:03:40.000Z","updated":"2021-09-10T08:53:11.515Z","comments":true,"path":"2021/02/05/数据结构与算法/线段树I/","link":"","permalink":"http://abeltian.top/2021/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91I/","excerpt":"","text":"线段树线段树本质上开了O(4n)的空间来维护了数组区间的性质。根节点从下标1开始 1234567891011void build(int p, int l, int r) &#123; // p为当前l, r区间对应的下标， l为当前区键的左侧下标，r为右侧下标 if (l == r) &#123; //更新a[p] return; &#125; int mid = l + (r - l) / 2; build(p &lt;&lt; 1, l , mid); build(p &lt;&lt; 1 | 1, mid + 1, r); a[p] = f(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1])&#125; 惰性更新，当更新区间包含了当前的区间[l, r]，只需要更新当前的节点并进行标记。 123void update(int p, int l, int r, int ul, int ur, int val) &#123; &#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"可持久化并查集","slug":"数据结构与算法/可持久化并查集","date":"2021-02-04T09:15:35.000Z","updated":"2021-09-10T08:53:11.508Z","comments":true,"path":"2021/02/04/数据结构与算法/可持久化并查集/","link":"","permalink":"http://abeltian.top/2021/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"可持久化并查集可持久化并查集 = 可持久化 + 并查集 = 主席树 + 并查集 leetcode 1724 检查边长度限制的路径是否存在 II 主席树方便用来维护历史的版本信息，可以支持回退， 访问之前版本的数据结构。 并查集，常用的两种优化方法是路径压缩，按秩合并。在可持久化并查集中只会用到按秩合并，即深度小的点向深度大的点合并，保证单次查询的时间复杂度为$ologn$ 可持久化并查集进本操作，状态定义 1234int tot;int rt[N] // 保存每一个版本的头结点int ls[N &lt;&lt; 5], rs[N &lt;&lt; 5] // 每个节点的左右孩子int fa[N &lt;&lt; 5], sz[N &lt;&lt; 5] // 节点的父亲、树的高度 建立基础主席树 12345678910void build(int &amp;t, int l, int r) &#123; t = ++tot; if (l == r) &#123; fa[t] = l; return; &#125; int mid = l + (r - l) / 2; build(ls[t], l, mid); build(rs[t], mid + 1, r);&#125; 查找某一个元素在主席树中的下标 1234567int query(int t, int l, int r, int x) &#123; // t为某一历史版本的根节点下标， x为待查找的元素 if (l == r) return t; int mid = l + (r - l) / 2; if (x &lt;= mid) return query(ls[t], l, mid, x); else return query(rs[t], mid + 1, r, x);&#125; 查找版本号为t元素x的祖先 12345int find(int t, int l, int r, int x) &#123; int p = query(t, l, r, x); // 查询x的下标 if (fa[p] == x) return x; return find(t, l, r, fa[p]);&#125; 按秩合并 1234567891011121314int unite(int pre, int l, int r, int x, int father) &#123; // 修改x节点的父亲为father int t = ++tot; ls[t] = ls[pre], rs[t] = rs[pre]; if (l == r) &#123; fa[t] = father; sz[t] = sz[pre]; return t; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) ls[t] = unite(ls[pre], l, mid, x, father); else rs[t] = unite(rs[pre], mid + 1, r, x, father); return t;&#125; 更新合并后父节点的深度 123456789void update(int t, int l, int r, int x) &#123; if (l == r) &#123; sz[t]++; return; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) update(ls[t], l, mid, x); else update(rs[t], mid + 1, r, x);&#125; 全部代码如下, java用时329ms通过了全部测试用例， 但是用c++超时了…..不开o2优化太坑人了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#pragma GCC optimize(2)class DistanceLimitedPathsExist &#123;public: static constexpr int N = 10005; int tot, n; int rt[N], ls[N &lt;&lt; 5], rs[N &lt;&lt; 5], fa[N &lt;&lt; 5], sz[N &lt;&lt; 5]; vector&lt;int&gt; dis; void build(int &amp;t, int l, int r) &#123; t = ++tot; if (l == r) &#123; fa[t] = l; return; &#125; int mid = l + (r - l) / 2; build(ls[t], l, mid); build(rs[t], mid + 1, r); &#125; int query(int t, int l, int r, int x) &#123; if (l == r) return t; int mid = l + (r - l) / 2; if (x &lt;= mid) return query(ls[t], l, mid, x); else return query(rs[t], mid + 1, r, x); &#125; int find(int t, int l, int r, int x) &#123; int p = query(t, l, r, x); if (fa[p] == x) return p; return find(t, l, r, fa[p]); &#125; int unite(int pre, int l, int r, int x, int father) &#123; // 修改x节点的父亲为father int t = ++tot; ls[t] = ls[pre], rs[t] = rs[pre]; if (l == r) &#123; fa[t] = father; sz[t] = sz[pre]; return t; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) ls[t] = unite(ls[pre], l, mid, x, father); else rs[t] = unite(rs[pre], mid + 1, r, x, father); return t; &#125; void update(int t, int l, int r, int x) &#123; if (l == r) &#123; sz[t]++; return; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) update(ls[t], l, mid, x); else update(rs[t], mid + 1, r, x); &#125; DistanceLimitedPathsExist(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edgeList) &#123; tot = 0; this-&gt;n = n; memset(rt, 0, sizeof(rt)); memset(ls, 0, sizeof(ls)); memset(rs, 0, sizeof(rs)); memset(fa, 0, sizeof(fa)); memset(sz, 0, sizeof(sz)); sort(edgeList.begin(), edgeList.end(), [](auto a, auto b) &#123; return a[2] &lt; b[2]; &#125;); build(rt[0], 0, n - 1); for (int i = 0; i &lt; edgeList.size(); ++i) &#123; rt[i + 1] = rt[i]; int x = edgeList[i][0], y = edgeList[i][1]; int posx = find(rt[i], 0, n - 1, x), posy = find(rt[i], 0, n - 1, y); if (fa[posx] != fa[posy]) &#123; if (sz[posx] &gt; sz[posy]) swap(posx, posy); rt[i + 1] = unite(rt[i], 0, n - 1, fa[posx], fa[posy]); if (sz[posx] == sz[posy]) update(rt[i + 1], 0, n - 1, fa[posy]); &#125; dis.push_back(edgeList[i][2]); &#125; &#125; bool query(int p, int q, int limit) &#123; int num = upper_bound(dis.begin(), dis.end(), limit - 1) - dis.begin(); int version = rt[num]; int posx = find(version, 0, n - 1, p); int posy = find(version, 0, n - 1, q); if (fa[posx] == fa[posy]) return true; else return false; &#125;&#125;;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"主席树","slug":"数据结构与算法/主席树","date":"2021-02-03T02:28:14.000Z","updated":"2021-09-10T08:53:11.505Z","comments":true,"path":"2021/02/03/数据结构与算法/主席树/","link":"","permalink":"http://abeltian.top/2021/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"主席树（可持久化线段树）问题描述： 给定N个数（int范围内），一共M次询问，每次都要询问区间[[l,r]的第k大的数。 其中N, M, l, r均不超过$2\\times10^5$，保证询问有答案 ​ 主席树本名可持久化线段树，也就是说，主席树是基于线段树发展而来的一种数据结构。其前缀”可持久化”意在给线段树增加一些历史点来维护历史数据，使得我们能在较短时间内查询历史数据，图示如下。 当每插入一个数据时，会修改$logn$个节点，因为主席树的左右子树节点编号不能够计算得到，而是需要记录下来。 1234static constexpr int N = 200010int rt[N] // 记录插入第i个数后的根节点int ls[N &lt;&lt; 5], rs[N &lt;&lt; 5] // 记录左儿子，右儿子int sum[N &lt;&lt; 5] // 记录当前节点区间的元素个数 将数组复制一份，进行排序，去掉重复的数字离散化。 以离散化后的数组为基础建立一个全零的线段树，称为基础主席树 对原数据中每一个[1,i]区间统计，有序地插入新节点，i每增加1，就会多一个数，仅需对主席树对应的节点增加1即可 对于查询[l, r]中第k小值的操作，找到[l, r]对应的根节点，按照线段树操作的方法即可 建立基础主席树 1234567void build(int &amp;u, int l, int r) &#123; u = ++tot; if (l == r) return; int mid = l + (r - l) / 2; build(ls[u], l, mid); build(rs[u], mid + 1, r);&#125; 向主席树中加入元素 12345678910int modify(int pre, int l, int r, int x) &#123; int cur = ++tot; ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre] + 1; if (l == r) return cur; int mid = l + (r - l) / 2; if (x &lt;= mid) ls[cur] = modify(ls[cur], l, mid); else rs[cur] = modify(rs[cur], mid + 1, r); return cur; &#125; 查询区间第k大，注意区间下标是从1开始 12345678int query(int u, int v, int l, int r, int k) &#123; int ans = 0, x = sum[ls[v]] - sum[ls[u]]; int mid = l + (r - l) / 2; if (l == r) return l; if (k &lt;= x) ans = query(ls[u], ls[v], l, mid, k); else ans = query(rs[u], rs[v], mid + 1, r, k - x); return ans;&#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"数据库","slug":"数据结构与算法/数据库","date":"2021-02-02T09:39:39.000Z","updated":"2021-09-10T08:53:11.510Z","comments":true,"path":"2021/02/02/数据结构与算法/数据库/","link":"","permalink":"http://abeltian.top/2021/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"一片介绍rank() dense_rank()很好的文章https://blog.csdn.net/u011726005/article/details/94592866","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://abeltian.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"博弈--极大极小博弈树","slug":"数据结构与算法/极大极小博弈树","date":"2021-01-31T10:04:02.000Z","updated":"2021-09-10T08:53:11.511Z","comments":true,"path":"2021/01/31/数据结构与算法/极大极小博弈树/","link":"","permalink":"http://abeltian.top/2021/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%8D%9A%E5%BC%88%E6%A0%91/","excerpt":"","text":"博弈博弈的两种的分类： 动态博弈是指在博弈中，两个参与人有行动的先后顺序，且后行动者能够观察到先行动者所选择的行动。 静态博弈是指在博弈中，两个参与人同时选择或不同时选择时，后行动者并不知道先行动者采取什么样的具体行动。 1. 极大极小博弈树​ 由于动态博弈参与者的行动有先后顺序，因此参与者的行动构成的为树状结构。 ​ 博弈通常是双方对抗，甚至是零和的博弈。也就是说，对对方最有利的决策，反过来就是对我方最不利的局面。在轮到我们做出决策的时候，我们通常希望最大化我们的收益，叫做极大层，此时树的节点叫做极大层节点；在对手做决策的时候，对手希望最小化我们的收益，叫做极小层，此时树的节点叫做极小层节点。由于双方是交替做出决策，因此极大层、极小层通常是交替出现，这样的数据结构就叫做极大极小树（Min-Max Tree）。 「必胜态」和「必败态」的概念： 一个状态为「必胜态」，当且仅当其相邻状态中至少有一个「必败态」。这里相邻的状态的定义为：在当前状态中进行决策的玩家可以到达的所有状态。也就是说，玩家可以选择移动到一个「必败态」，使得对手必败，因此当前状态是必胜的。 一个状态为「必败态」，当且仅当其相邻的所有状态都是「必胜态」。这里的道理是类似的，如果所有相邻状态都是「必胜态」，那么对手必胜，当前玩家必败。 2.从已知状态进行搜索从已知的最终状态进行倒推之前状态的可能性，考虑已有的可能的几种状态 leetcode 913 猫和老鼠 此步老鼠胜利，上一步为老鼠行动，则上一步老鼠为必胜态 此步老鼠胜利，上一步为猫行动，则上一步猫行动状态的出度减一，(因为猫走该步后不肯能胜利)，只有当猫行动后所有的子状态均为老鼠的必胜态时，即出度为0时，此时猫所处的状态为必败态。 此步猫胜利，上一步为猫行动，则上一步猫的状态为必胜态。 此步猫胜利，上一步为老鼠行动，同上。 状态定义 f[i][j][0]为老鼠处于i，猫处于j，此时为老鼠行动，上一步为猫行动。 老鼠胜利：1， 猫胜利： 2， 平局： 0，最终返回初始状态的值。","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/categories/Alogrithm/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"扩展欧几里得算法","slug":"数据结构与算法/exgcd","date":"2021-01-26T04:49:27.000Z","updated":"2021-09-10T08:53:11.503Z","comments":true,"path":"2021/01/26/数据结构与算法/exgcd/","link":"","permalink":"http://abeltian.top/2021/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/exgcd/","excerpt":"","text":"扩展欧几里得算法在求最大公约数时，基于一个基本的事实$(a, b) = (b, a - \\lfloor \\frac{a}{b}\\rfloor b) = (b, a\\ mod \\ b)$，直到$b = 0$，此时$(a, 0) = a$。这种求最大公约数的算法叫做辗转相除法，又叫做欧几里得算法。 1234567int gcd(int a, int b) &#123; while (b != 0) &#123; a %= b; swap(a, b); &#125; return a;&#125; 裴蜀定理：假设$a, b$是不全为0的整数，则存在整数$x, y$使得$ax + by = gcd(a, b)$。 简单证明：$$gcd(a, b) = gcd(b, a\\ mod\\ b) = gcd(b, a - kb) = gcd(r_1, r_2) = \\dots = gcd(r_n, 0)$$其中$r_1, r_2 \\dots r_n$都可以写成$x_ia + y_ib$的形式，因此存在$ax + by = gcd(a, b)$ 扩展欧几里得算法在求解最大公约数的同时，计算了一组适于裴蜀定理的系数。递推关系的推导，$(a, b) = (b, a\\ mod\\ b) = (b, a - \\lfloor \\frac{a}{b} \\rfloor b)$，因此存在四个整数$x, y, x’, y’$使得$$ax + by = bx’ + (a - \\lfloor \\frac{a}{b} \\rfloor b)y’ \\\\a(x - y’) + b(y - (x’ - \\lfloor \\frac{a}{b} \\rfloor)y’) = 0 \\\\x = y’, y = x’ - \\lfloor \\frac{a}{b} \\rfloor y’$$ 123456789101112ex_gcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int tmp = x; x = y; y = tmp - a / b * y; return d;&#125; 上述算法可以改写为迭代的形式，递推公式$$\\left{ \\begin{array}{rcl}{\\rm{x}} = y’ \\\\{y = x’ - \\lfloor \\frac{a}{b} \\rfloor y’}\\end{array} \\right.$$将其写为矩阵的形式 $$\\left( \\begin{array}{rcl}x \\\\y\\end{array} \\right) = \\left( \\begin{array}{rcl}0&amp;1 \\\\1&amp;{ -\\lfloor \\frac{a}{b} \\rfloor}\\end{array} \\right)\\left( \\begin{array}{rcl}{x’} \\\\{y’}\\end{array} \\right)$$ 初始矩阵为单位矩阵 $\\left( \\begin{array}{rcl}x&amp;m\\\\y&amp;n\\end{array} \\right) = \\left( \\begin{array}{rcl}x&amp;m\\\\y&amp;n\\end{array} \\right)\\left( \\begin{array}{rcl}0&amp;1\\\\1&amp;{ - d}\\end{array} \\right) = \\left( \\begin{array}{rcl}m&amp;{x - dm}\\\\n&amp;{y - dn}\\end{array} \\right)$ 当b=0时，计算结束，此时x, y为满足裴蜀定理的系数，最大公约数为a。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"乘法逆元","slug":"数据结构与算法/乘法逆元","date":"2021-01-25T14:11:43.000Z","updated":"2021-09-10T08:53:11.506Z","comments":true,"path":"2021/01/25/数据结构与算法/乘法逆元/","link":"","permalink":"http://abeltian.top/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/","excerpt":"","text":"乘法逆元1. 逆元的定义如果一个线性同余方程$ax \\equiv 1 (mod\\ b)$，则称$x$为$a\\ mod\\ b$的逆元，记作$a^{-1}$。 模运算规则与基本四则运算类似，但是除法例外。在ACM竞赛中，除法取模的运算要用到求逆元，从而得到$(a / b) \\% c = (a * x) \\% c$ 证明：已知$(b * x) \\% c = 1$，假设$(a / b) \\% c = y_1, (a * x) \\% c = y_2$ 则 $a / b = k_1*c + y_1\\quad(1)$ $a*x = k_2 * c + y_2\\quad(2)$ $(1) -(2)$$\\quad \\rightarrow \\quad a/b - a*x = (k_1 - k_2)*c + (y_1 - y_2)$ 左右同时乘以b $\\quad \\rightarrow \\quad$ $a - a * x * b = k * c * b + (y1 - y2) * b$ 左右模上c $\\quad \\rightarrow \\quad (y1 - y2) * b \\% c = 0$ 因为$b \\neq 0$, 所以$y_1 = y_2$ 2. 求逆元费马小定理，若p为素数，且$gcd(a, p) = 1$，则$a^{p - 1} \\equiv 1 (mod\\ p)$ 证明： 构造一个序列$A={1, 2, 3, \\dots p - 1}$， 这个序列有如下的性质: $\\mathop{\\Pi}\\limits_{i = 1}^{n}A_i = \\mathop{\\Pi}\\limits_{i = 1}^{n}(A_i \\times a)$ 对于任意$i, j \\in n $，$(A_i * a )\\% p \\neq (A_j * a )\\% p$，因为$(A_i - A_j) * a \\% p = 0$，则$A_i - A_j = 0$ 因此$(p - 1)! \\equiv (p - 1)! * a^{p - 1}\\ (mod\\ p) \\quad \\rightarrow a^{p - 1} \\equiv 1 \\ mod(\\ p)$ 2.1 扩展欧几里得算法扩展欧几里得算法 求解同余方程$ax \\equiv 1 (mod\\ b)$的最小整数解 假设采用扩展欧几里得算法求得一组$x_0, y_0$满足$ax_0 +by_0 = gcd(a, b)$，则该方程的任意解可以表示为$x = x_0 + bt, y = y_0-at$，对于任意t均成立，最小整数解可以表示为$x = ((x_0\\ mod\\ b) + b) mod\\ b$ 2.2快速幂算法根据费马小定理，$1 \\equiv a^{p -1} (mod\\ p)$，因此$x = a^{p - 2}$，可以采用快速幂算法进行计算。 1234567891011ll qpow(long long a, long long b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) &#123; ret = (ret * a) % mod; &#125; b &gt;&gt;= 1; a = (a * a) % mod; &#125; return ret;&#125; 2.3 线性求逆元求出$1, 2, \\dots, n$中每个数关于p的逆元。 显然$1{-1} \\equiv 1 (mod\\ p)$ 令$k = \\lfloor\\frac{p}{i} \\rfloor, j = p\\ mod\\ i$, 因此有$p = ki + j$，在模p的意义下就有$ki + j \\equiv 0\\ (mod\\ p)$ 左右同乘以$i^{-1}, j^{-1}$，有$kj^{-1} + i^{-1}=0$ $i^{-1}=-kj^{-1} = (p - k)j^{-1}$ 12345678static const expr mod = 1e9 + 7;ll fac[N], R[N], inv[N];fac[0] = fac[1] = R[0] = R[1] = inv[0] = inv[1] = 1;for (int i = 2; i &lt;= n; ++i) &#123; fac[i] = 1LL * fac[i - 1] * i % mod; inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod; R[i] = 1LL * R[i - 1] * inv[i] % mod;&#125; 1234ll comb(int n, int m) &#123; if (n &lt; m) return 0; return 1LL * fac[n] * R[m] % mod * R[n - m] % mod;&#125; 2.4 线性求任意n个数的逆元1234567891011121314151617181920212223242526272829303132using LL = long long;static constexpr LL mod = 99997867;static constexpr int N = 1000005;LL fac[N], rf[N];LL qpow(LL a, LL b) &#123; LL ret = 1; while (b) &#123; if (b &amp; 1) &#123; ret = ret * a % mod; &#125; b &gt;&gt;= 1; a = a * a % mod; &#125; return ret;&#125;void init() &#123; fac[0] = 1; for (int i = 1; i &lt; N; ++i) &#123; fac[i] = fac[i - 1] * i % mod; &#125; rf[N - 1] = qpow(fac[N - 1], mod - 2); for (int i = N - 2; i &gt;= 0; --i) &#123; rf[i] = rf[i + 1] * (i + 1) % mod; &#125;&#125;LL comb(int n, int m) &#123; if (n &lt; m || m &lt; 0) return 0; return fac[n] * rf[n - m] % mod * rf[m] % mod;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"洗牌算法","slug":"数据结构与算法/洗牌算法","date":"2021-01-18T08:25:26.000Z","updated":"2021-09-10T08:53:11.514Z","comments":true,"path":"2021/01/18/数据结构与算法/洗牌算法/","link":"","permalink":"http://abeltian.top/2021/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"洗牌算法 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。 int [] shuffle()返回数据随机打乱后的结果。 打乱的概念 随机打乱后的结果能够覆盖所有的情况，比如数组元素的个数为n，那么打乱后的结果应该覆盖$n!$种所有可能的结果 所有结果等概率出现 方法一 暴力暴力的方法就是模拟，假设数组中的每个元素为一个小球，我们将其放入袋子中，进行不放回的抽取，直到袋子中没有小球，我们将抽取出来的小球按顺序排列得到一个排列组合，这个排列组合出现的概率为$\\frac{1}{n!}$，因此这个 数组的每个排列组合都是等概的，算法时间复杂度$O(n2)$，vector&lt;int&gt;的erase()删除操作是O(n)的。 对于某一个排列组合其出现概率为$$\\mathop{\\Pi}\\limits_{k = 0}^{n - 1}\\frac{1}{n - k} = \\frac{1}{n!}$$ 方法二 Fisher-Yates算法Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个当前数组末尾指针下标的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换，这步模拟了每次从袋子里面摸一个元素的过程。 12345678vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; int pos = rand() % (i + 1); swap(arr[i], arr[pos]); &#125; return arr;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"凸优化","slug":"数据结构与算法/凸优化","date":"2021-01-12T08:12:52.000Z","updated":"2021-09-10T08:53:11.506Z","comments":true,"path":"2021/01/12/数据结构与算法/凸优化/","link":"","permalink":"http://abeltian.top/2021/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%87%B8%E4%BC%98%E5%8C%96/","excerpt":"","text":"凸优化leetcode 1515 服务中心的最佳位置 一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。给你一个数组 positions ，其中 positions[i] = [xi, yi] 表示第 i 个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 该问题本质上优化的函数如下：$$f(x_c, y_c) = \\sum\\limits_{i = 0}^{n - 1}\\sqrt{(x_c - x_i)^2 + (y_c - y_i)^2}$$其中$(x_c, y_c)$为服务器中心的位置，其可以使$f(x_c, y_c)$取得最小值。该函数是凸函数，凸优化问题的局部最优解就是全局最优解。 1.凸集$C$是凸集，如果对于任意的$x,y\\in C$和任意的$\\theta \\in \\mathbb{R}$且满足$0 \\le \\theta \\le 1$时，$\\theta x + (1 - \\theta) y$恒成立。 2.凸函数2.1 凸函数定义定义在$\\mathbb{R}^n \\rightarrow \\mathbb{R}$上的函数$f$是凸函数， 当且仅当它的定义域$\\mathbb{D}(f)$是一个凸集，且对于任意的$x, y \\in \\mathbb{D}$和$ 0 \\le \\theta \\le 1$， $f(\\theta x + (1 - \\theta)y) \\le \\theta f(x) + (1 - \\theta)f(y)$恒成立。 2.2 凸函数的一阶充要条件假设定义在$\\mathbb{R}^n \\rightarrow \\mathbb{R}$上的函数$f$可微， 即对于所有的$x \\in \\mathbb{D}(f)$，梯度$\\nabla f(x)$均存在，则函数$f$是凸函数当且仅当函数定义域$\\mathbb{D}(f)$是一个凸集合，且对于所有$x, y \\in \\mathbb{D}(f)$均满足：$$f(y) \\ge f(x) + \\nabla f(x)^T(y - x)$$ 2.3 凸函数的二阶充要条件记凸函数$f$的一阶导数和二阶导数分别为$g$和$H$$$\\nabla f = \\begin{bmatrix} \\frac{\\partial f}{\\partial x_1} \\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial x_n} \\end{bmatrix} \\quadH = \\nabla^2f = \\begin{bmatrix} \\frac{\\partial^2f}{\\partial x_1^2} &amp; \\frac{\\partial^2f}{\\partial x_1 \\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2f}{\\partial x_1 \\partial x_n} \\\\ \\frac{\\partial^2f}{\\partial x_2 \\partial x_1} &amp; \\frac{\\partial^2f}{\\partial x_2^2} &amp; \\cdots &amp; \\frac{\\partial^2f}{\\partial x_2 \\partial x_n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\frac{\\partial^2f}{\\partial x_n \\partial x_1} &amp; \\frac{\\partial^2df}{\\partial x_n \\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2f}{\\partial x_n^2} \\end{bmatrix}$$$f$在$x_k$处的二阶泰勒展开为$$f(x) = f(x_k) + \\nabla f^T (x - x_k) + \\frac{1}{2!}(x - x_k)H(x_k)(x - x_k) + o^n$$假设定义在$\\mathbb{R}^n \\rightarrow \\mathbb{R}$上的函数$f$二阶可微， 即对于所有的$x \\in \\mathbb{D}(f)$，海森矩阵$\\nabla^2 f(x)$均存在，则函数$f$是凸函数当且仅当函数定义域$\\mathbb{D}(f)$是一个凸集合，且对于所有$x, y \\in \\mathbb{D}(f)$均满足$H$为半正定矩阵。 3.凸优化可以证明本题优化的函数$f$为$\\mathbb{R}^2$的上凸函数。 梯度下降 模拟退火 爬山算法 三分搜索 3.1 梯度下降梯度下降算法，梯度下降是机器学习中常用的一种求局部最小值的算法，对于给定点$(x, y)$，它的梯度方向是函数值上升最快的方向，因此负梯度为函数值下降的最快的方向，$-\\nabla f = (-\\frac{\\partial f}{\\partial x}, -\\frac{\\partial f}{\\partial y})$，我们从一个初始点$(x_{start}, y_{start})$开始迭代， 每次令$$x \\prime = x - \\alpha \\cdot \\frac{\\partial f}{\\partial x} \\\\y \\prime = y - \\alpha \\cdot \\frac{\\partial f}{\\partial y}$$ 初始点$(x_{start}, y_{start})=(\\frac{\\sum\\limits_{i =0}^{n-1}x_i}{n},\\frac{\\sum\\limits_{i =0}^{n-1}y_i}{n})$ 学习率$\\alpha = 1$ 学习率衰减$\\eta = 0.001$ 当$(x \\prime, y\\prime)$与$(x, y)$的距离小于$10^{-7}$时结束迭代。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123; int n = positions.size(); double eps = 1e-7, alpha = 1, decay = 0.001; double x = 0, y = 0; for (auto p : positions) &#123; x += p[0]; y += p[1]; &#125; x = x / n; y = y / n; auto getDis = [&amp;](double x, double y) &#123; double ans = 0; for(auto p : positions) &#123; ans += sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1])); &#125; return ans; &#125;; while (true) &#123; double prex = x, prey = y; double dx = 0, dy = 0; for (auto p : positions) &#123; double base = max(1e-9, sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]))); dx += (x - p[0]) / base; dy += (y - p[1]) / base; &#125; x -= alpha * dx; y -= alpha * dy; alpha = alpha * (1 - decay); if (sqrt((x - prex) * (x - prex) + (y - prey) * (y - prey)) &lt; eps) &#123; break; &#125; &#125; return getDis(x, y); &#125;&#125;; 整体写下来，尝试了很多次，初始值与学习率与学习率衰减的设置都会很大程度上影响是否能够收敛到最优值。该算法对初始化参数设置的依赖较大。 3.2 爬山算法如果给定的凸函数很难求导，我们注意到负梯度方向，$\\nabla f = -\\frac{\\partial f}{\\partial x}(1, 0) -\\frac{\\partial f}{\\partial y}(0, 1)$，开始我们选择一个步长，表示每次移动的距离。如果我们当前在位置$(x, y)$，我们一次枚举四个方向，判断其函数值是否更小，如果更小则进行移动，否则说明我们的步长过大，直接跳过了最优值点，调整步长为原来的一半，直到步长小于给定的阈值。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123; int n = positions.size(); double eps = 1e-8, step = 100; double x = 0, y = 0; for (auto p : positions) &#123; x += p[0]; y += p[1]; &#125; x /= n; y /= n; auto getDis = [&amp;](double x, double y) &#123; double ans = 0; for (auto p : positions) &#123; ans += sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1])); &#125; return ans; &#125;; vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; double d = getDis(x, y); while (step &gt; eps) &#123; bool flag = false; for (int k = 0; k &lt; 4; ++k) &#123; double nx = x + step * dir[k][0], ny = y + step * dir[k][1]; double t = getDis(nx, ny); if (t &lt; d) &#123; x = nx; y = ny; d = t; flag = true; break; &#125; &#125; if (!flag) step /= 2; &#125; return d; &#125;&#125;;","categories":[{"name":"凸优化","slug":"凸优化","permalink":"http://abeltian.top/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"并查集","slug":"数据结构与算法/并查集","date":"2021-01-06T03:44:37.000Z","updated":"2021-09-10T08:53:11.509Z","comments":true,"path":"2021/01/06/数据结构与算法/并查集/","link":"","permalink":"http://abeltian.top/2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集可以说在算法中应用很广泛，最主要用来判断图的连通性的问题。之前做的题很少包含按秩合并，最多就是按照两个连通分量的大小进行合并。今天第一次碰到了按照秩进行合并的并查集问题，leetcode 399 除法求值，描述如下： 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 输入：equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000] 1.深度优先搜索因为数据规模不大，a / b = 2，可以表示为a到b有一条权值为2的边，b到a有一条权值为0.5的边，因此对于每一个查询，可以采用深度优先搜索的方式进行查找，记录路径与当前的乘积，时间复杂度为O(n)。 2.并查集方法 a / b = 2.0 说明a 与 b在一个集合中，a = 2b 带路径压缩的查询$$w[x] = \\frac{v[x]}{v[father} \\w[x] = \\frac{v[x]}{v[fa[x]]} * \\frac{v[fa[x]]}{v[father]} \\w[x] = w[x] * w[fa[x]]$$ 按秩合并 合并两个节点的父亲，要更新两个父亲之间的权值。$$w[fx] = \\frac{v[fx]}{v[fy]} \\w[fx] = \\frac{v[x]}{w[x]} / \\frac{v[y]}{w[y]} \\$$ 1234567891011121314151617181920212223242526272829303132333435class UnionFind &#123;private: int n; vector&lt;int&gt; fa; vector&lt;double&gt; w;public: UnionFind(int _n) : n(_n), fa(n, 0), w(n, 1.0) &#123; for (int i = 0; i &lt; n; ++i) fa[i] = i; &#125; int find(int x) &#123; if (x != fa[x]) &#123; int father = find(fa[x]); w[x] *= w[fa[x]]; fa[x] = father; &#125; return fa[x]; &#125; void unite(int x, int y, double weight) &#123; int fx = find(x), fy = find(y); if (fx == fy) return; fa[fx] = fy; w[fx] = weight * w[y] / w[x]; &#125; double isConnected(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) &#123; return w[x] / w[y]; &#125; else &#123; return -1; &#125; &#125;&#125;; 1234567891011121314151617181920class Solution &#123;public: vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123; unordered_map&lt;string, int&gt; mp; int idx = 0, n = equations.size(); UnionFind uf(2 * n); for (int i = 0; i &lt; n; ++i) &#123; string s = equations[i][0], t = equations[i][1]; if (!mp.count(s)) mp[s] = idx++; if (!mp.count(t)) mp[t] = idx++; uf.unite(mp[s], mp[t], values[i]); &#125; vector&lt;double&gt; ans; for (auto p : queries) &#123; if (!mp.count(p[0]) || !mp.count(p[1])) ans.push_back(-1.0); else ans.push_back(uf.isConnected(mp[p[0]], mp[p[1]])); &#125; return ans; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://abeltian.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"树与图上的动态规划III","slug":"数据结构与算法/树与图上的动态规划III","date":"2020-12-29T03:53:44.000Z","updated":"2021-09-10T08:53:11.512Z","comments":true,"path":"2020/12/29/数据结构与算法/树与图上的动态规划III/","link":"","permalink":"http://abeltian.top/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E5%9B%BE%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92III/","excerpt":"","text":"洛谷p1122 最大子树和 题目中给出了N个点的权值，与N-1条边的连接关系，并未给出根。 $1 \\le N \\le 16000$ 开始总是想需不需要换根，该题本质上是求树上点 权值和最大的一个连通分量，因此选择哪个点为根对结果没有影响，任一连通分量在某一时刻总是可以视为一颗以某个点为根的数。$$f[u] += max(f[v], 0) \\ans = max(ans, f[u])$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;int f[16005], s[16005], head[40000], tot, ans = INT_MIN;struct edge&#123; int to, nxt;&#125; e[40000];void add(int u, int v) &#123; e[++tot] = &#123;v, head[u]&#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[u] = s[u]; for (int i = head[u]; i; i = e[i]. nxt) &#123; int v = e[i].to; if (v == fa) continue; dfs(v, u); f[u] += max(f[v], 0); &#125; ans = max(ans, f[u]);&#125;int main(int argc, char *argv[]) &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; &#125; int u, v; for (int i = 0; i &lt; n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 洛谷 p1613 跑路 题目大意，图结构，如果i到j的距离为$2^k$千米，那么只需要1s时间。 $n \\le 50, m \\le 10000$ 因为涉及到$2^k$，因此为倍增算法，先进行预处理，状态表示f[i][j][k]表示i到j有一条距离为$2^k$的边。$$f[i][j][k] = f[i][l][k - 1] &amp;&amp; f[l][j][k - 1] \\1 \\le l \\le n$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int dis[60][60];bool f[60][60][65];int n, m;void work() &#123; for (int l = 1; l &lt;= 64; ++l) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int k = 1; k &lt;= n; ++k) &#123; f[i][j][l] = f[i][k][l - 1] &amp;&amp; f[k][j][l - 1]; if (f[i][j][l]) &#123; dis[i][j] = 1; break; &#125; &#125; &#125; &#125; &#125;&#125;void floyd() &#123; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; memset(dis, 63, sizeof(dis)); int u, v; for (int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; dis[u][v] = 1; f[u][v][0] = true; &#125; work(); floyd(); cout &lt;&lt; dis[1][n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"树与图上的动态规划II","slug":"数据结构与算法/树与图上的动态规划II","date":"2020-12-28T12:37:20.000Z","updated":"2021-09-10T08:53:11.512Z","comments":true,"path":"2020/12/28/数据结构与算法/树与图上的动态规划II/","link":"","permalink":"http://abeltian.top/2020/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E5%9B%BE%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92II/","excerpt":"","text":"洛谷P2014 选课 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 NNN 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 MMM 门课程学习，问他能获得的最大学分是多少？ 每门课只有一门先修课， 因此该图结构为森林，假设没有选修课的父节点都指向零，因此如果要选择子节点，则必须要选择父节点，因为父节点为选修课的要求。 转换为树上背包问题$$dp[i][j] = max(dp[i][j], dp[i][j - k] + dp[x][k]) \\quad x为i的子节点。$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int f[305][305], head[305], tot, scores[305], sz[305];struct edge&#123; int to, nxt;&#125; edges[305];void add(int u, int v) &#123; edges[++tot] = &#123;v, head[u]&#125;; head[u] = tot;&#125;void dfs(int u) &#123; sz[u] = 1; f[u][1] = scores[u]; for (int i = head[u]; i; i = edges[i].nxt) &#123; int v = edges[i].to; dfs(v); sz[u] += sz[v]; for (int j = sz[u]; j &gt;= 1; --j) &#123; for (int k = min(j - 1, sz[v]); k &gt;= 0; --k) &#123; f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]); &#125; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int k, s; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; k &gt;&gt; scores[i]; add(k, i); &#125; dfs(0); cout &lt;&lt; f[0][++m] &lt;&lt; endl; //注意包含了0节点，因此要多选一门 return 0;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"树与图上的动态规划","slug":"数据结构与算法/树形动态规划","date":"2020-12-27T02:51:43.000Z","updated":"2021-09-10T08:53:11.513Z","comments":true,"path":"2020/12/27/数据结构与算法/树形动态规划/","link":"","permalink":"http://abeltian.top/2020/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"树与图上的动态规划洛谷p 2015 二叉苹果树 二叉树共有N个结点，编号为1-N，树根编号一定是1。每颗树枝上有一定数量苹果，给定需要保留的树枝数量，求出最多能留住多少苹果。 $1\\le N, Q \\le 100$ 通常定义图的方式为：e[tot]记录了某条边的连接信息，head[u]记录了边的序号。 12345678struct edge &#123; int to, nxt, w;&#125; e[MAXN];void add(u, v, w) &#123; e[++tot] = &#123;v, head[u], w&#125;; head[u] = tot;&#125; 状态定义： 1f[u][i]表示u的子树上保留i条边，最多可保留的苹果数目 状态转移方程，n颗树的01背包问题。$$f[u][i] = max(f[u][i], f[u][i - j - i] + f[v][j] + e[u-&gt;v].w)$$保留一条边必须保留从根节点到这条边路径上的所有边，若果要保留子树v上的边，那么必须保留u到v的这条边。 整体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int n, rem, tot; int f[105][105], sz[105], head[105];struct edge &#123; int to, nxt, w;&#125; e[105 &lt;&lt; 1];void add(int u, int v, int w) &#123; e[++tot] = &#123;v, head[u], w&#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (v == fa) continue; dfs(v, u); sz[u] += sz[v] + 1; for (int j = min(rem, sz[u]); j &gt;= 0; --j) &#123; for (int k = min(j - 1, sz[v]); k &gt;= 0; --k) &#123; f[u][j] = max(f[u][j], f[u][j - k - 1] + f[v][k] + e[i].w); &#125; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; rem; int u, v, w; for (int i = 0; i &lt; n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); &#125; dfs(1, -1); cout &lt;&lt; f[1][min(sz[1], rem)] &lt;&lt; endl; return 0; &#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"动态规划优化-单调队列","slug":"数据结构与算法/动态规划优化","date":"2020-12-22T12:03:51.000Z","updated":"2021-09-10T08:53:11.507Z","comments":true,"path":"2020/12/22/数据结构与算法/动态规划优化/","link":"","permalink":"http://abeltian.top/2020/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96/","excerpt":"","text":"动态规划优化-单调队列当状态转移的复杂度为$O(n)$时， 状态个数为n个，动态规划的算法复杂度为$O(n^2)$，可能会超时，因此对状态转移的过程进行优化，将状态转移的复杂度降低到$O(logn)$或$O(1)$ 例1 多重背包的单调队列优化 有 N 种物品和一个容量是 V的背包。第 i种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是$w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。0&lt;N≤10000&lt;V≤200000&lt;$s_i$,$v_i$,$w_i$≤20000 状态转移方程，可以按照体积进行分组，本质上是求一个滑动窗口的最大值。$$dp[j+mv] = max(dp[j] + mw, dp[j+v] + (m - 1)w, \\dots, dp[j+mv])$$对上面的状态转移方程进行变形,采用单调队列进行优化，代码如下：$$dp[j+mv] = max(dp[j], dp[j+v] - w, \\dots, dp[j+mv]) + mw$$ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int dp[20010], pre[20010], dq[20010];int main() &#123; int n, m, v, w, s; cin &gt;&gt; n &gt;&gt; m; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(pre, dp, sizeof(dp)); memset(dp, 0, sizeof(dp)); for (int j = 0; j &lt; v; ++j) &#123; int head = 0, tail = -1; for (int k = j; k &lt;= m; k += v) &#123; while (head &lt;= tail &amp;&amp; pre[k] - pre[dq[tail]] &gt; (k - dq[tail]) / v * w) &#123; tail--; &#125; dq[++tail] = k; if ((k - dq[head]) / v &gt; s) head++; dp[k] = pre[dq[head]] + (k - dq[head]) / v * w; &#125; &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; return 0;&#125; 例2 跳跃游戏VI 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界, 达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。请你返回你能得到的 最大得分 。 1 &lt;= nums.length, k &lt;= $10^5$$-10^4$ &lt;= nums[i] &lt;= $10^4$ 状态转移方程 $$f[i]=\\max_{max(0,i−k)≤j&lt;i}​{f[j]}+nums[i]$$ 该状态转移方程为$O(n^2)$，但是我们仅需要前面这个滑动窗中的最大值，因此采用单调队列的方式进行优化，使得队列头部为该滑动窗的最大值。 12345678910111213141516171819class Solution &#123;public: int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); deque&lt;int&gt; dq&#123;0&#125;; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (i - dq.front() &gt; k) dq.pop_front(); int val = dp[dq.front()] + nums[i]; while (!dq.empty() &amp;&amp; val &gt; dp[dq.back()]) &#123; dq.pop_back(); &#125; dq.push_back(i); dp[i] = val; &#125; return dp[n - 1]; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode_372","slug":"数据结构与算法/leetcode-372","date":"2020-12-21T09:35:27.000Z","updated":"2021-09-10T08:53:11.503Z","comments":true,"path":"2020/12/21/数据结构与算法/leetcode-372/","link":"","permalink":"http://abeltian.top/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode-372/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"leetcode 418 屏幕可显示句子的数量","slug":"数据结构与算法/leetcode-418","date":"2020-12-20T12:46:39.000Z","updated":"2021-09-10T08:53:11.504Z","comments":true,"path":"2020/12/20/数据结构与算法/leetcode-418/","link":"","permalink":"http://abeltian.top/2020/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode-418/","excerpt":"","text":"题目描述 给你一个 rows x cols 的屏幕和一个用 非空 的单词列表组成的句子，请你计算出给定句子可以在屏幕上完整显示的次数。 单词不能拆分成两行。 单词在句子中的顺序必须保持不变。 在一行中 的两个连续单词必须用一个空格符分隔。 句子中的单词总量不会超过 100。 每个单词的长度大于 0 且不会超过 10。 1 ≤ rows, cols ≤ 20,000. 方法1 暴力模拟(超时）​ 开始看这道题没什么思路，放置单词这个应该没有什么规律，只能去暴力计算放置字符串的位置，模拟了一下在pos这个位置放置一个句子，下一次放置该句子的位置与行数。无奈被这个数据给卡了[“a”], 20000, 20000，按句子模拟必然超时。 方法2 动态规划​ 这道题的trick在于单词数量比较少，不超过100个，并且当单词不能放入当前行时，下一次其一定放置在下一行的行首。这样可以定义两个状态，这样预处理的时间复杂度为$O(mN)$, 计算放置句子个数的过程时间复杂度为$O(N)$$$count[j] \\quad 以第j个单词为当前行第一个单词时，放置的句子的个数 \\next[j] \\quad 以第j个单词为当前行第一个单词时，下一行第一个单词$$ 123456789101112131415161718192021222324252627class Solution &#123;public: int wordsTyping(vector&lt;string&gt;&amp; sentence, int rows, int cols) &#123; int n = sentence.size(); vector&lt;int&gt; cnt(n, 0), next(n, 0); vector&lt;int&gt; arr; for (string s : sentence) &#123; arr.push_back(s.size()); &#125; for (int i = 0; i &lt; n; ++i) &#123; int tmp = 0, idx = i; for (int j = 0; j &lt;= cols + 1;) &#123; j += arr[idx] + 1; if (j &gt; cols + 1) break; if (idx == n - 1) tmp++; idx = (idx + 1) % n; &#125; cnt[i] = tmp; next[i] = idx; &#125; int ans = 0, idx = 0; for (int i = 0; i &lt; rows; ++i) &#123; ans += cnt[idx]; idx = next[idx]; &#125; return ans; &#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"手写字符识别","slug":"数据结构与算法/手写字符识别","date":"2020-12-19T13:26:51.000Z","updated":"2021-09-10T08:53:11.510Z","comments":true,"path":"2020/12/19/数据结构与算法/手写字符识别/","link":"","permalink":"http://abeltian.top/2020/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/","excerpt":"","text":"计算机视觉(computer Vision)1.全连接与CNN模型比较​ 好久没弄过深度学习的东西了，上次写得时候应该是大三上学期，一转眼就是两年了。感觉自己的记忆力好差啊，之前搞得那些已经是忘得一干二净了。这次的任务是采用Omniglot数据集进行手写数字的识别，该数据及包含了50中字母系统中共计1623种字符，每个字符有20个样本，部分样本如下图所示。 ​ 我采用的深度学习框架是pytorch，当用户使用DataLoader加载自定义数据时，需要继承Dataset这个类，并重写其中的两个方法。传入参数为图片路径与标签的字典。采用DataLoader()加载数据，batch_size大小设置为64。 1234def __getitem__(self, index): raise NotImplementedErrordef __len__(self): raise NotImplementedError 定义包含一个隐层的全连接模型, 训练50个epoch，训练集上的loss与测试集上的accuracy如下图所示，全连接模型测试集的准群率在40%左右。 12345model = nn.Sequential( nn.Linear(784, 2048), nn.ReLU(), nn.Linear(2048, 50),) 定义包含四个卷积层与两个全连接层的CNN网络， 训练50次，测试集上的最高准确率为0.8389，相比于全连接模型，准确率大大提升。 12345678def forward(self, x): x = self.conv1(x) x = self.conv2(x) x = self.conv3(x) x = self.conv4(x) x = x.view(x.size(0), -1) # (batch_size, size) output = self.out(x) return output 2.尝试与对比2.1数据集的划分​ 将类别设置为20类，每个类别训练集为15个样本，测试集为3个样本，结果如下图所示，分类准确率相比于50类明显提升，最高为0.9314。适当的减少分类类别可以提升模型的分类准确率。 2.2改变模型结构相比于示例给出的卷积网络，再加入一卷积层，结果如下，分类准确率变化不大。 2.3 不同的优化器比较上述训练都是采用的SGD优化器，改为Adagrad优化器的结果如下，loss相比于SGD优化器，没有较大的波动。准确率相比于SGD也有较大的提升，最高为0.8647。 采用Adam优化器结果如下所示，其收敛速度慢于Adagrad优化器，训练500个epoch结果如下。测试集上的分类准确率为0.8777","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"进程","slug":"数据结构与算法/进程","date":"2020-12-18T08:13:22.000Z","updated":"2021-09-10T08:53:11.515Z","comments":true,"path":"2020/12/18/数据结构与算法/进程/","link":"","permalink":"http://abeltian.top/2020/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"进程1.进程的概念程序(program)是一个存储在磁盘上某个目录中的可执行文件，内核使用exec函数将程序读入内存，并执行程序。 程序执行的实例被称为进程(process), unix系统确保每个进程都有一个唯一的数字标识符，称为进程ID 2.进程环境进程命令行参数，当执行一个程序时，在调用main函数前先调用一个特殊的启动例程，启动例程从内核获得命令行参数和环境变量值，之后调用main函数。POSIX.1要求argv[argc]是一个空指针，因此在参数处理的循环中可以改写为 1for (i = 0; argv[i] != NULL; ++i) 环境表: 环境表是一个字符指针数组，其中每个指针为一个以’\\0’为结尾的C字符串地址，全局变量environ环境指针为该指针数组的地址。 1extern char **environ;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"}]},{"title":"快速选择算法","slug":"数据结构与算法/快速选择算法","date":"2020-12-18T03:32:15.000Z","updated":"2021-09-10T08:53:11.509Z","comments":true,"path":"2020/12/18/数据结构与算法/快速选择算法/","link":"","permalink":"http://abeltian.top/2020/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/","excerpt":"","text":"快速选择算法题目描述：在未排序的数组中找到第 k 个最大的元素。 12输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5 ​ 快速选择算法本质上是对快速排序算法进行优化，快速排序算法是将数组进行划分，从数组中任选一个元素，调整数组使得左边元素都比它小，其4右侧元素都比它大。通过递归调用快速排序对左侧序列与右侧序列进行排序。而快速选择算法对左侧区间和右侧区间的数据个数与需要寻找的第K大的数字进行比较，选择答案所存在的区间，舍弃了另一个不需要的区间，使算法复杂度降低到$ O(n+ n/2 + n/4 +…)$期望为$O(n)$，但是在最坏的情况下每次选择的都是最大或者最小值，算法时间复杂度为$O(n^2)$。 针对题目数据，未加入随机数时间为56ms，加入随机数为16ms 1234567891011121314151617181920212223242526class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); return quick_select(nums, 0, n - 1, n - k + 1); &#125; int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; int randPos = l + rand() % (r - l + 1); swap(nums[l], nums[randPos]); int pivot = nums[l]; int i = l, j = r; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) --j; if (i &lt; j) nums[i] = nums[j]; while (i &lt; j &amp;&amp; nums[i] &lt; pivot) ++i; if (i &lt; j) nums[j] = nums[i]; &#125; nums[i] = pivot; int idx = i - l + 1; if (idx == k) return pivot; else &#123; return idx &lt; k ? quick_select(nums, i + 1, r, k - idx) : quick_select(nums, l, i - 1, k); &#125; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"最小的k个数","slug":"数据结构与算法/最小的k个数","date":"2020-12-17T15:00:13.000Z","updated":"2021-09-10T08:53:11.510Z","comments":true,"path":"2020/12/17/数据结构与算法/最小的k个数/","link":"","permalink":"http://abeltian.top/2020/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","excerpt":"","text":"leetcode 373 查找和最小的K对数字 题目描述：给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。 做题思路由于题目中没有给定数据范围，开始以为是双指针问题，采用贪心策略，但是举了两个例子，指针的移动无法采用贪心的方法，如[1, 3, 100]与[2, 10, 11]， 第二组为(2, 3)，第三组为(1, 10)，第一个数组的指针出现了回退，因此贪心不可行。 1.暴力做法​ 枚举数组1与数组2所有可能的组合，并采用箭指offer 40 最小的k个数的最大堆的方法，维护最小的k对数字，时间复杂度$O(n^2logk)$，运行时间1232ms，勉强过了。 2.利用数组的排序信息​ 在暴力做法中完全没有利用到题目中给出的数组为升序排列这个信息，还是以[1, 3, 100]与[2, 10, 11]为例，开始我们将$(nums1[0], nums2[j]) j = 1,2\\dots n$放入最小堆中，如果当前堆中弹出的为$(nums1[i], nums2[j])$，那么则将$(nums1[i + 1], nums2[j])$放入到最小堆中。 数据结构pair&lt;pair&lt;int, int&gt;, int&gt;，分别记录nums1的值、下标， nums2的值。 最小堆 priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; 12345678910111213141516171819202122232425262728struct cmp &#123; bool operator ()(const pair&lt;pair&lt;int, int&gt;, int&gt;&amp;a, const pair&lt;pair&lt;int, int&gt;, int&gt;&amp; b) const &#123; return a.first.first + a.second &gt; b.first.first + b.second; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int m = nums1.size(), n = nums2.size(); if (m == 0 || n == 0) return &#123;&#125;; priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; pq; for (int i = 0; i &lt; n; ++i) &#123; pq.push(&#123;&#123;nums1[0], 0&#125;, nums2[i]&#125;); &#125; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; ans; while (!pq.empty() &amp;&amp; cnt &lt; k) &#123; auto [a, b] = pq.top(); pq.pop(); ans.push_back(&#123;a.first, b&#125;); int idx = a.second; if (idx + 1 &lt; m) pq.push(&#123;&#123;nums1[idx + 1], idx + 1&#125;, b&#125;); ++cnt; &#125; return ans; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"最长递增子序列","slug":"数据结构与算法/最长递增子序列","date":"2020-12-16T14:48:07.000Z","updated":"2021-09-10T08:53:11.511Z","comments":true,"path":"2020/12/16/数据结构与算法/最长递增子序列/","link":"","permalink":"http://abeltian.top/2020/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列leetcode 300 最长递增子序列 leetcode 673 最长递增子序列的个数 对于673题，常规做法动态规划，记录两个状态 最长上升子序列的长度与当前长度对应的子序列的个数。动态规划的规划过程$$arr[j] &gt; arr[i] \\if; dp[j] &lt; dp[i] + 1 \\quad dp[j] = dp[i] + 1, nums[j] = nums[i] \\else ;if ; dp[j] == dp[i] + 1 \\quad nums[j] += nums[i]$$动态规划规划的复杂度为$O(n^2)$ 采用树状数组$O(nlogn)$的复杂度，定义Node结构体，记录长度与个数，重载加法操作符。 维护小于等于当前值区间的最长长度的上升子序列个数。 12345678910111213struct Node &#123; int m, c; Node (int _m, int _c) : m(_m), c(_c) &#123;&#125; Node&amp; operator +=(Node &amp;rhs) &#123; if (m &lt; rhs.m) &#123; m = rhs.m; c = rhs.c; &#125; else if (m == rhs.m) &#123; c += rhs.c; &#125; return *this; &#125;&#125;; 1234567891011121314151617181920212223242526class Solution &#123;public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; arr = nums; sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); unordered_map&lt;int, int&gt; mp; for (int i = 0; i &lt; arr.size(); ++i) &#123; mp[arr[i]] = i + 1; &#125; vector&lt;Node&gt; tree(2010, &#123;0, 0&#125;); Node res(0, 0); for (int val : nums) &#123; Node tmp(0, 1); for (int k = mp[val] - 1; k &gt; 0; k -= (k &amp; -k)) &#123; tmp += tree[k]; &#125; tmp.m++; res += tmp; for (int k = mp[val]; k &lt; 2010; k += (k &amp; -k)) &#123; tree[k] += tmp; &#125; &#125; return res.c; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"DTMF信号检测与识别","slug":"数据结构与算法/DTMF信号检测与识别","date":"2020-12-15T14:17:52.000Z","updated":"2021-09-10T08:53:11.501Z","comments":true,"path":"2020/12/15/数据结构与算法/DTMF信号检测与识别/","link":"","permalink":"http://abeltian.top/2020/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DTMF%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB/","excerpt":"","text":"DTMF信号的检测与识别1. 程序设计思路与框图1.1 FFT直接计算利用FFT计算输入的信号的DFT频域信息，并找到两个峰值频率点，从而检测DTMF信号。 数据预处理，作业给定的为.wav文件，其中数据为16bit的short类型，文件指针偏移40个字节的位置记录了wav数据块的字节数，调用read函数将之后的数据读入到数组中。 编写类FFTMethod，调用第一次作业编写的时域基2DFT对音频信号做FFT变换。找到频域中两个峰值对应的数字角频率，从而计算得到模拟角频率，找到对应的DTMF信号 程序框图 1.2 Goertzel 算法计算FFT包含了信号整个频域的信息，而我们只关注DTMF信号的八个特定频率，因此算法存在冗余。在FFT中如果我们只关注某一个特定的数字角频率，$X[k] = \\sum_{n = 0}^{N- 1}x[m]W_n^{m -N}$，其可以视为$x[n]$通过冲激响应为$W_N^{-nk}$的LTI系统在N时刻的取值。第k个频点对应的差分方程为：$$V_k[n] = 2cos(\\omega_k)V_k[n - 1] - V_k[n-2] + x[n] \\X_k[n] = V_k[n] - W_N^k[n - 1], v[-1] = v[-2] = 0$$其本质是一个动态规划的过程，由递推关系可以得到n时刻的状态，从而确定该频点的FFT。得到八个特定频点的FFT值后，选择两个峰值，从而确定DTMF信号。 1.3一串DTMF信号的识别下图为一串DTMF信号的时域图像，可以看到其中包含了15个DTMF信号，我们要做的工作是确定每一个信号的起始于结束位置，直接使用强度值进行判断存在较大的误差，因此选择滑动窗取平均的方式。程序中选择滑动窗大小为64，计算信号每个点对应的滑动窗内的平均能量，并与阈值作比较，从而确定每一个信号的起始结束位置。之后将每一段信号采用上述的两种方法进行信号判断 程序框图 2.两种算法的结果与复杂度比较实验结果： 复杂度分析： FFT方法采用DFT计算了所有的频点信息，时间复杂度为$O(nlogn)$，寻找峰值的复杂度为O(n)，总的时间复杂度为$O(nlogn) + O(n)$ Goertzel方法只计算特定的8个频点，并采用差分方程的形式递推计算，时间复杂度为O(n) FFT方法需要存储所有的频域信息，空间复杂度为$O(n)$， Goertzel方法在递推过程中只需要V[i-1]、V[i-2]这两个状态， 空间复杂度为$O(1)$","categories":[{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"unix shell简单实现","slug":"数据结构与算法/a simple shell","date":"2020-12-14T12:21:10.000Z","updated":"2021-09-10T08:53:11.502Z","comments":true,"path":"2020/12/14/数据结构与算法/a simple shell/","link":"","permalink":"http://abeltian.top/2020/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/a%20simple%20shell/","excerpt":"","text":"1.shell整体框架github项目地址 shell程序整体框架，读取用户输入命令并执行 进入main函数后，循环执行从标准输入读取命令，解析命令，将命令字符串以空格分隔，解析为命令与参数。判断是否为内建命令(history, jobs, fb, exit)。如果不是则父进程通过fork()创建子进程，子进程执行execv()完成进程代码段与数据段内容替换。 2.输入输出重定向定义命令结构体，其包含argc(命令参数个数)、bg(后台命令标志)、name(命令名称)、argv(命令参数)、fds(重定向文件描述符)等五个成员变量。 1234567struct command &#123; int argc; int bg; string name; string argv[ARG_MAX]; int fds[2];&#125;; 解析指令时command &gt; file检查是否有&gt;或&lt;操作符，有则检查后面是否有文件，若果有文件则以读写的方式打开文件，并将返回文件描述符记录到命令结构体中，在fork()后的子进程中，采用dup2()函数将子进程的输入、输出重定向fds所指向的文件描述符。 3.实现管道123456struct commands &#123; string key; int cmd_counts; struct command* cmds[CMD_MAX]; commands *pre, *next;&#125; 定义命令集(commands)结构体，成员cmd_counts为命令个数，cmds记录每一个解析后的命令指针。 检查输入的字符中是否有”|”，如果有按照|将字符串分隔开，并解析每一个命令(支持多条命令) 创建管道，前一个命令的stdout重定向到管道的写端，后一个命令的stdin重定向的管道的读端。 Fork()创建每一个子进程，执行指令 4.作业控制123456struct job_t &#123; pid_t pid; int jid; int state; string cmd;&#125;; 定义job_t结构体，包含成员进程编号，作业编号，作业状态，命令字符串。定义作业运行状态：UNDEF:0、FG:1、BG:2、 ST:3 定义JOBCtrl类，来控制作业的执行。 父进程fork()创建子进程后，父进程将作业添加到作业列表，并定义SIG_CHLD信号处理函数，当子进程结束执行时，发送SIG_CH LD信号给父进程。父进程捕捉信号，在信号处理函数中调用waitpid()函数获得子进程pid，将其从作业列表中删除。 5.后台执行程序 如果是前台执行程序，则父进程处于while循环的等待状态，直到子进程执行完毕向父进程发送SIG_CHLG信号，父进程捕捉到信号后将其从作业列表中删除后，结束while循环等待。如果是后台执行程序则打印作业相关信息并继续执行读取用户输入。 6.作业控制 jobs fg bg jobs查看所有作业的运行状态， 将作业列表中的所有作业打印输出 fg % 1，从作业列表中找到后台运行的作业，将其状态变为FG，并执行等待，直到子进程结束发出SIG_CHLD信号，从作业列表中删除。 bg % 1，父进程注册SIGTSTP信号处理，CRTL+Z, 发送STGTSTP信号给子进程，暂停子进程执行。当执行bg命令时，父进程向暂停的子进程发送SIGCONT信号恢复子进程的执行。 7.历史命令 实现了CMDCache类 哈希表+双向链表维护历史命令，哈希表记录输入字符串与解析后的命令结构体的映射，双向链表记录历史输入命令 LRU(least Recently used)算法，当输入字符串已经被解析过时，将命令从双向链表中删除，并重新命令列表头部插入。输入字符串未解析过，解析后插入列表头部。 history命令 将历史命令按输入顺序的倒序排列输出 up、down命令获取上一条输入命令、下一条命令输入","categories":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"}]},{"title":"pipe","slug":"数据结构与算法/pipe","date":"2020-12-12T06:36:56.000Z","updated":"2021-09-10T08:53:11.504Z","comments":true,"path":"2020/12/12/数据结构与算法/pipe/","link":"","permalink":"http://abeltian.top/2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/pipe/","excerpt":"","text":"1.管道的概念管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递，通过pipe()系统调用即可创建一个管道。 其本质是一个伪文件，实为内核缓冲区 两个文件描述符引用，一个表示读端，一个表示写端 管道采用半双工通信方式，数据只能在一个方向流动 只能在有公共祖先的进程间使用管道 2.pipe函数123int pipe(int (*pipefd)[2]); ret 0 : SUCCESS -1 : Failure 函数调用成功返回read/write两个文件描述符，无需open，需要手动close。 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端 父进程调用fork()创建子进程，子进程继承父进程文件描述符。 父进程关闭管道读端，子进程关闭管道写端，父进程可以向管道中写入数据，子进程将管道中数据读出。 3.管道读写行为 使用管道需要注意以下4种特殊情况 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 4.示例程序 采用管道实现 ls /home | wc主线程调用fork()创建两个进程一个执行ls /home，另一个执行 wc，利用管道重定向两个进程的stdout，stdin。 踩坑记录，在主线程wait(NULL)前，需要手动关闭主线程的所有管道，否则第二个进程会处于读阻塞的状态，因此发生了死锁 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;ctype.h&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int f[2]; pipe(f); for (int i = 0; i &lt; 2; ++i) &#123; pid_t pid = fork(); if (pid == 0) &#123; if (i == 1) &#123; close(f[1]); dup2(f[0], 0); char *name = &quot;/usr/bin/wc&quot;; char **argv = new char*[1]; argv[0] = &quot;/usr/bin/wc&quot;; int exet_st = execv(name, argv); close(f[0]); _exit(EXIT_SUCCESS); &#125; else &#123; close(f[0]); char buff[] = &quot;test&quot;; write(f[1], buff, strlen(buff)); close(f[1]); _exit(EXIT_SUCCESS); &#125; &#125; &#125; close(f[0]); close(f[1]); for (int i = 0; i &lt; 2; ++i) &#123; wait(NULL); &#125; return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"}]},{"title":"区间和","slug":"数据结构与算法/区间和","date":"2020-12-10T07:17:40.000Z","updated":"2021-09-10T08:53:11.508Z","comments":true,"path":"2020/12/10/数据结构与算法/区间和/","link":"","permalink":"http://abeltian.top/2020/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%92%8C/","excerpt":"","text":"leetcode 1477 找两个和为目标值且不重叠的子数组 leetcode 1658 将x减小到0的最小次数 leetcode 1423 可获得的最大点数 题目中给出的数据范围$1\\le arr[i]\\le10^4$，因此找到一段区间和为某一个数值，可以采用双指针的方式，如果当前区域的和大于target，则移动前面的指针，直到区间和小于等于target。如果存在负数或零，则采用前缀和与哈希表的方式。 对于题目1477 其要找到满足等于给定和的最小的两个不想交的区间，采用dp[j]表示区间右端点小于等于j的最小区间长度。$$dp[j] = \\min(dp[j - 1], j - i + 1) \\ans = \\min(ans, dp[i - 1] + j - i + 1)$$ 1234567891011121314151617181920212223class Solution &#123;public: int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) &#123; int n = arr.size(); int i = 0, sum = 0, ans = 0x3f3f3f3f; vector&lt;int&gt; dp(n, 0x3f3f3f3f); for (int j = 0; j &lt; n; ++j) &#123; sum += arr[j]; while (sum &gt; target &amp;&amp; i &lt; j) &#123; sum -= arr[i]; ++i; &#125; if (j &gt; 0) dp[j] = dp[j - 1]; if (sum == target) &#123; dp[j] = min(dp[j], j - i + 1); if (i &gt; 0) &#123; ans = min(ans, dp[i - 1] + j - i + 1); &#125; &#125; &#125; return ans == 0x3f3f3f3f ? -1 : ans; &#125;&#125;; 对于1658题，首先找到一段区间和为x，然后调整两个指针的位置使得两端区间和为x 123456789101112131415161718192021222324class Solution &#123;public: int minOperations(vector&lt;int&gt;&amp; nums, int x) &#123; int n = nums.size(), ans = 0x3f3f3f3f; int j = n - 1, sum = 0; while (j &gt;= 0 &amp;&amp; sum &lt; x) &#123; sum += nums[j]; --j; &#125; ++j; if (sum == x) ans = n - j; for (int i = 0; i &lt; n; ++i) &#123; sum += nums[i]; while (j &lt; n &amp;&amp; sum &gt; x) &#123; sum -= nums[j]; ++j; &#125; if (sum == x &amp;&amp; j &gt; i) &#123; ans = min(ans, i + 1 + n - j); &#125; &#125; return ans == 0x3f3f3f3f ? -1 : ans; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"区间和","slug":"区间和","permalink":"http://abeltian.top/tags/%E5%8C%BA%E9%97%B4%E5%92%8C/"}]},{"title":"线段树","slug":"数据结构与算法/线段树","date":"2020-12-09T11:55:27.000Z","updated":"2021-09-10T08:53:11.514Z","comments":true,"path":"2020/12/09/数据结构与算法/线段树/","link":"","permalink":"http://abeltian.top/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"每个叶子节点为最小的分割区间，即为数组存储的值。 假设树的高度为k，0,1,2$\\dots$k，另n为区间个数，则有$2^{k - 1} &lt; n \\le 2^k$，整棵树的节点个数有$2^{k + 1} - 1$个，通常线段树空间大小为4 * n leetcode 1109 航班预订统计 leetcode 307 区间和检索-数组可修改 leetcode 308 二维区域和检索—可变 线段树建树数组下标同树状数组相同，都是从1开始 12345678910void build(int l, int r, int p) &#123; if(l == r) &#123; d[p] = a[l]; return; &#125; int mid = l + (r - l) / 2; build(l, m, p &lt;&lt; 1); build(m + 1, r, p &lt;&lt; 1 | 1); d[p] = d[p &lt;&lt; 1] + d[p &lt;&lt; 1 | 1];&#125; 线段树区间查询l，r为查询区间，cl，cr为当前区间的左右边界。 123456789int query(int l, int r, int p, int cl, int cr) &#123; if(cl &gt; r || cr &lt; l) return 0; else if(l &lt;= cl &amp;&amp; r &gt;= cr) return d[p]; else &#123; int mid = l + (r - l) / 2, sum = 0; if(l &lt;= mid) sum += query(l, r, p &lt;&lt; 1, cl, mid); if(r &gt; mid) sum += quert(l, r, p &lt;&lt; 1 | 1s, mid + 1, cr); &#125;&#125; 线段树的点更新$O(nlogn)$123456789101112void update(int k, int v, int l, int r, int p) &#123; //update(k, v, 1, n, 1) if(l == r) a[k] += v, d[k] += v; else &#123; int mid = l + (r - l) / 2; if(k &lt;= mid) &#123; update(k, v, l, mid, p &lt;&lt; 1); &#125; else &#123; update(k, v, mid + 1, r, p &lt;&lt; 1 | 1); &#125; d[p] = d[p &lt;&lt; 1] + d[p &lt;&lt; 1 | 1]; &#125;&#125; 线段树区间修改与懒惰标记对于一个区间$[l, r]$，如果每次更新区间中的每个值，那么时间复杂度为$O(nlogn)$，为了提高更新效率，采用了mark进行标记。在递归更新过程中，当当前节点区间为待更新区间的真子集时，不再向下更新。 123456789101112131415161718192021void push_down(int p, int len) &#123; mark[p &lt;&lt; 1] += mark[p]; mark[p &lt;&lt; 1 | 1] += mark[p]; d[p &lt;&lt; 1] += mark[p] * (len - len / 2); d[p &lt;&lt; 1 | 1] += mark[p] * len / 2; mark[p] = 0;&#125;void update(int l, int r, int val, int cl, int cr, int p) &#123; if(l &gt; cr || r &lt; cl) return; else if(l &lt;= cl &amp;&amp; r &gt;= cr) &#123; d[p] += (cr - cl + 1) * val; if(cl &gt; cr) mark[p] += d; &#125; else &#123; int mid = cl + (cr - cl) / 2; push_down(p, cr - cl + 1); update(l, r, val, cl, mid, p &lt;&lt; 1); update(l, r, val, mid + 1, cr, p &lt;&lt; 1 | 1); d[p] = d[p &lt;&lt; 1] + d[p &lt;&lt; 1 | 1]; &#125;&#125; 线段树区间查询 包含懒惰标记123456789int query(int l, int r, int cl, int cr, int p) &#123; if(l &gt; cr || r &lt; cl) return 0; else if(l &lt;= cl &amp;&amp; r &gt;= cr) return d[p]; else &#123; int mid = l + (r - l) / 2; if(mark[p]) push_down(p, cr - cl + 1); return query(l, r, cl, mid, p &lt;&lt; 1) + query(l, r, mid + 1, cr, p &lt;&lt; 1 | 1); &#125;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://abeltian.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]}],"categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/categories/JAVA/"},{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/categories/Alogrithm/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"},{"name":"凸优化","slug":"凸优化","permalink":"http://abeltian.top/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"},{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://abeltian.top/tags/deep-learning/"},{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"},{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"},{"name":"deep learing","slug":"deep-learing","permalink":"http://abeltian.top/tags/deep-learing/"},{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/tags/JAVA/"},{"name":"JAVA Spring","slug":"JAVA-Spring","permalink":"http://abeltian.top/tags/JAVA-Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://abeltian.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Data Stucture","slug":"Data-Stucture","permalink":"http://abeltian.top/tags/Data-Stucture/"},{"name":"数据库","slug":"数据库","permalink":"http://abeltian.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"并查集","slug":"并查集","permalink":"http://abeltian.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"},{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"区间和","slug":"区间和","permalink":"http://abeltian.top/tags/%E5%8C%BA%E9%97%B4%E5%92%8C/"},{"name":"线段树","slug":"线段树","permalink":"http://abeltian.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]}