{"meta":{"title":"TYS的博客","subtitle":"算法小白努力学习中","description":"","author":"tys","url":"http://abeltian.top","root":"/"},"pages":[{"title":"about","date":"2020-12-14T12:31:27.000Z","updated":"2021-09-10T08:53:11.520Z","comments":true,"path":"about/index.html","permalink":"http://abeltian.top/about/index.html","excerpt":"","text":""},{"title":"books","date":"2020-12-14T12:31:21.000Z","updated":"2021-09-10T08:53:11.521Z","comments":true,"path":"books/index.html","permalink":"http://abeltian.top/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-14T12:29:49.000Z","updated":"2021-09-10T08:53:11.522Z","comments":true,"path":"categories/index.html","permalink":"http://abeltian.top/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2020-12-14T12:31:13.000Z","updated":"2021-09-10T08:53:11.524Z","comments":true,"path":"links/index.html","permalink":"http://abeltian.top/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-14T12:30:36.000Z","updated":"2021-09-10T08:53:11.524Z","comments":true,"path":"tags/index.html","permalink":"http://abeltian.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"点在多边形内部","slug":"计算几何/点在多边形内部","date":"2021-05-21T12:36:37.000Z","updated":"2021-09-10T08:53:11.519Z","comments":true,"path":"2021/05/21/计算几何/点在多边形内部/","link":"","permalink":"http://abeltian.top/2021/05/21/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/","excerpt":"","text":"点在多边形内部射线法，从判断点向上做一条射线，当与多边形交点个数为奇数个时，则点在多边形内部。 边界条件(点在顶点上，点在边上，通过叉积等于0与点积小于等于0来判断） 边界条件，凸顶点判断一次，凹顶点判断两次 边界条件，当连线与边重叠时，不进行判断，点一定在多边形外部。 1((c.x &gt;= a.x &amp;&amp; c.x &lt; b.x) || (c.x &gt;= b.x &amp;&amp; c.x &lt; a.x)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;using LL = long long;struct Point &#123;public: int x, y; Point(int _x, int _y) : x(_x), y(_y) &#123;&#125; Point operator - (const Point&amp; rhs) &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125;&#125;;int dot(const Point&amp; a, const Point&amp; b) &#123; return a.x * b.x + a.y * b.y;&#125;int cross(const Point&amp; a, const Point&amp; b) &#123; return a.x * b.y - b.x * a.y;&#125;vector&lt;Point&gt; arr;bool in(Point c) &#123; int n = arr.size(); int ans = 0; for (int i = 0, j = n - 1; i &lt; n; j = i++) &#123; Point a = arr[j], b = arr[i]; if (dot(c - a, c - b) &lt;= 0 &amp;&amp; cross(c - a, c - b) == 0) return 0; if (((c.x &gt;= a.x &amp;&amp; c.x &lt; b.x) || (c.x &gt;= b.x &amp;&amp; c.x &lt; a.x)) &amp;&amp; c.y &lt; a.y + 1.0 * (b.y - a.y) / (b.x - a.x) * (c.x - a.x)) &#123; ans = !ans; &#125; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout); #endif int n, q, x, y; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; arr.push_back(&#123;x, y&#125;); &#125; cin &gt;&gt; q; int ans = 0; for (int i = 0; i &lt; q; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; if (in(&#123;x, y&#125;)) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"素数方法","slug":"数论/关于素数的一些方法","date":"2021-05-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.517Z","comments":true,"path":"2021/05/20/数论/关于素数的一些方法/","link":"","permalink":"http://abeltian.top/2021/05/20/%E6%95%B0%E8%AE%BA/%E5%85%B3%E4%BA%8E%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"关于素数的一些方法假设N为1e5，对1到N中所有的数做质因子分解。 12345678910111213141516171819static constexpr int N = 1e5 + 5;unordered_map&lt;int, int&gt; prime[N];bool isp[N];&#123; memset(isp, true, sizeof(isp)); for (int i = 2; i &lt; N; ++i) &#123; if (isp[i]) &#123; for (int j = i; j &lt; N; j += i) &#123; int cur = j, cnt = 0; while (cur % i == 0) &#123; cur /= i; ++cnt; &#125; prime[j][i] = cnt; isp[j] = false; &#125; &#125; &#125;&#125; 找到1到N中所有数的因数 123456vector&lt;int&gt; fact[N];for (int i = 1; i &lt; N; ++i) &#123; for (int j = 2 * i; j &lt; N; j += i) &#123; fact[j].push_back(i); &#125;&#125; 找到[1:m]中满足$gcd(n, p) = x$的$p$的数量。 $$gcd(n, p) = x \\\\n = a \\cdot x, p = b \\cdot x \\\\gcd(a, b) = 1$$找到[1:b]中gcd(a, b) = 1中数字的数量，计算[1:b]中gcd(a, b) != 1的数量, prime[a]为a的质因数分解。 12345678910111213141516171819int find(int a, int b) &#123; int ans = 0; vector&lt;int&gt; arr; for (auto it : prime[a]) &#123; arr.push_back(it.first); &#125; int sz = arr.size(); for (int i = 1; i &lt; (1 &lt;&lt; sz); ++i) &#123; int mul = 1, sign = -1; for (int j = 0; j &lt; sz; ++j) &#123; if (i &gt;&gt; j &amp; 1) &#123; mul *= arr[j]; sign *= -1; &#125; &#125; ans += sign * b / mul; &#125; return b - ans;&#125; 例题：https://codeforces.com/problemset/problem/1139/D 其中cnt为1到m中gcd(p, x) = y的p的数量。$$f[x] = 1 + \\frac{cnt}{m}f[y] + \\frac{\\frac{m}{x}}{m}f[x]$$","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"组合数学DP","slug":"组合数学/组合数学DP","date":"2021-05-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.518Z","comments":true,"path":"2021/05/20/组合数学/组合数学DP/","link":"","permalink":"http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6DP/","excerpt":"","text":"组合数学DP一个挺有意思的题目 https://cses.fi/problemset/task/1717 There are n children at a Christmas party, and each of them has brought a gift. The idea is that everybody will get a gift brought by someone else. In how many ways can the gifts be distributed?","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"错拍公式","slug":"组合数学/错排公式","date":"2021-05-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.519Z","comments":true,"path":"2021/05/20/组合数学/错排公式/","link":"","permalink":"http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/","excerpt":"","text":"错排公式错排问题，考虑$n$个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。记作$n$个元素的错排数为$D(n)$。 递推公式： 选择书的编号为m，剩下n - 1个位置，假设选择k k放入m的位置 则转化为$D(n - 2)$的错排方案数 第m本书在位置k不动，此时k不能放在第m个位置，其他n - 2本书也不在自己原本的位置，等价于求$n - 1$个数的错排 $$D(n) = (n - 1) *[D(n- 1) + D(n - 2)]$$ https://cses.fi/problemset/task/1717","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"JAVA注解","slug":"JAVA/java注解","date":"2021-04-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.498Z","comments":true,"path":"2021/04/20/JAVA/java注解/","link":"","permalink":"http://abeltian.top/2021/04/20/JAVA/java%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"java注解注解可以被编译器打包进入class文件，是一种用作标注的元数据。 由编译器使用的注解@Override让编译器检查该方法是否正确地实现了覆写。这类注解不会被编译进入.class文件，在编译后就被扔掉了 由工具类处理.class文件使用的注解。 程序运行期能够读取的注解，加载后一直存在于JVM中，例如@PostConstruct方法在调用构造方法后自动被调用。 1.定义注解java语言使用@interface语法来定义注解(Annotation) 2.使用注解通常注解如何使用由程序自己决定。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"wilson定理","slug":"数论/wilson定理","date":"2021-04-20T02:29:10.000Z","updated":"2021-09-10T08:53:11.516Z","comments":true,"path":"2021/04/20/数论/wilson定理/","link":"","permalink":"http://abeltian.top/2021/04/20/%E6%95%B0%E8%AE%BA/wilson%E5%AE%9A%E7%90%86/","excerpt":"","text":"wilson定理正整数n &gt; 1， 则n是一个素数当且仅当$(n - 1)! \\equiv -1 (mod\\ n)$ 如果n为非质数，假设集合A为${1, x_1, x_2,\\cdots x_{m - 1}, n - 1}$与n互质。 对于任意$x_i$，则$x_i \\cdot A$集合为${x_i,\\ x_i\\cdot x_1,\\ x_i \\cdot x_2,\\ \\cdots,\\ x_i \\cdot x_{m - 1},\\ x_i \\cdot (n - 1)}$, 对于其中$x_i\\cdot A$中任意一个元素其膜n的值互不相同，且为集合A中的元素，因此存在$x_i * x_j \\equiv 1 (mod\\ n)$，因为1和n - 1模n逆元为其本身，$x_i$的逆元为$x_j$$$(1\\times x_1 \\times x_2 \\times \\cdots x_m \\times n - 1) \\cdot (1\\times x_1 \\times x_2 \\times \\cdots x_m \\times n - 1) \\equiv (1 * 1) \\times (x_i * x_j) \\cdots \\times ((n - 1) * (n - 1)) \\equiv 1 (mod \\ n) \\\\令(1\\times x_1 \\times x_2 \\times \\cdots x_m \\times n - 1) = y \\\\y^2\\equiv 1 (mod\\ n)\\\\y \\equiv 1 (mod\\ n)\\ 或\\ y \\equiv n - 1 (mod\\ n)$$ $$x_i*x_j \\equiv x_i * x_k (mod\\ n) \\\\x_i * (x_j - x_k) \\equiv 0 (mod\\ n) \\\\(x_j - x_k) \\equiv 0 (mod\\ n) \\\\x_j = x_k$$","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"欧拉函数","slug":"数据结构与算法/欧拉函数","date":"2021-03-07T12:53:42.000Z","updated":"2021-09-10T08:53:11.513Z","comments":true,"path":"2021/03/07/数据结构与算法/欧拉函数/","link":"","permalink":"http://abeltian.top/2021/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"欧拉函数欧拉函数是小于或等于n的正整数中与n互质的数目，$\\phi(1) = 1$。 通式：$$\\phi(x)= x \\mathop{\\Pi}\\limits_{i = 1}^{n}(1 - \\frac{1}{p_i})$$若n是质数的p的k次幂，$\\phi(n) = p^k - p^{k - 1}$，因为除了p的倍数$p * (1,2\\dots p^{k - 1})$以外，其他数均与n互质。 线性筛，每个合数通过其最小的质因数筛掉。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"凸包","slug":"数据结构与算法/凸包","date":"2021-03-01T08:43:21.000Z","updated":"2021-09-10T08:53:11.507Z","comments":true,"path":"2021/03/01/数据结构与算法/凸包/","link":"","permalink":"http://abeltian.top/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%87%B8%E5%8C%85/","excerpt":"","text":"凸包二维凸包， 凸多边形是指所有内角大小都在$[0, \\pi]$范围内的简单多边形。在平面上能包含所有给定点的最小凸多边形叫做凸包。 Andrew算法$\\quad\\quad$首先将点集按照x坐标(第一关键字)，y坐标进行升序排列。显然排序后最小的元素和最大的元素一定在凸包上。他们之间的部分可以分成上下两条链分别求解。求下链时只要从小到大遍历排序后的点列，求上链从大到小遍历即可。 $\\quad\\quad$在凸包上，我们从一个点出发逆时针走，轨迹总是左拐的，如果出现右拐，则说明该段不在凸包上。采用栈来记录轨迹上已经走过的点，如果即将入栈的点$P$和栈顶点$S_1$构成的向量方向相较$S_2, S_1$构成向量的方向向右旋转，即叉积$\\vec{S_2S_1} \\times\\vec{S_1P} &lt; 0$，则弹出栈顶，直到$\\vec{S_2S_1} \\times\\vec{S_1P} \\geq 0$或栈内仅包含一个元素。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Point &#123; int x, y; Point(int _x, int _y) : x(_x), y(_y) &#123;&#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x == rhs.x ? y &lt; rhs.y : x &lt; rhs.x; &#125; Point operator - (const Point&amp; rhs) &#123; Point ret(0, 0); ret.x = x - rhs.x; ret.y = y - rhs.y; return ret; &#125; int operator ^ (const Point&amp; rhs) &#123; return x * rhs.y - y * rhs.x; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; outerTrees(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; vector&lt;Point&gt; arr; int n = points.size(); for (int i = 0; i &lt; n; ++i) &#123; arr.push_back(&#123;points[i][0], points[i][1]&#125;); &#125; sort(arr.begin(), arr.end()); int tp = 0; vector&lt;bool&gt; used(n, 0); vector&lt;int&gt; st(n + 5); for (int i = 0; i &lt; n; ++i) &#123; while (tp &gt;= 2 &amp;&amp; ((arr[st[tp]] - arr[st[tp - 1]]) ^ (arr[i] - arr[st[tp]])) &lt; 0) &#123; used[st[tp--]] = false; &#125; st[++tp] = i; used[i] = true; &#125; used[0] = false; for (int i = n - 1; i &gt;= 0; --i) &#123; if (used[i]) continue; while (tp &gt;= 2 &amp;&amp; ((arr[st[tp]] - arr[st[tp - 1]]) ^ (arr[i] - arr[st[tp]])) &lt; 0) &#123; used[st[tp--]] = false; &#125; st[++tp] = i; used[i] = true; &#125; vector&lt;vector&lt;int&gt;&gt; ret; for (int i = 1; i &lt; tp; ++i) &#123; ret.push_back(&#123;arr[st[i]].x, arr[st[i]].y&#125;); &#125; return ret; &#125;&#125;; 复杂度分析 时间复杂度，排序$O(n\\log n)$，上下链求解$O(2n)$ 空间复杂度，栈的最大深度为O(n)","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"跳表","slug":"数据结构与算法/跳表","date":"2021-02-27T03:46:47.000Z","updated":"2021-09-10T08:53:11.515Z","comments":true,"path":"2021/02/27/数据结构与算法/跳表/","link":"","permalink":"http://abeltian.top/2021/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/","excerpt":"","text":"跳表(Probabilistic Alternative to Balanced Trees)​ 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳表的期望空间复杂度为$O(n)$，跳表的查询，插入和删除操作的期望时间复杂度都为$O(logn)$。 ​ 链表加多级索引的结构就是跳表。跳表的每一层都是一个有序链表，每层位于第i层的节点有p的概率出现在第i+1层，p为常数。 复杂度证明空间复杂度​ 第一层的期望值为$n$, 第二层的期望值为$np$, 第三层的期望值为$np^2$，因此空间复杂度的期望值为$\\sum\\limits_{i = 0}^{+\\infty}np^i=\\frac{n}{1 - p}$。因为p为常数，因此跳表期望的空间复杂度为$O(n)$。 时间复杂度 跳表最后一层节点的个数为$\\frac{1}{p}$，因为再上一层的期望值为1(无意义)。因此层数m为$$np^{m - 1}=\\frac{1}{p} \\\\(\\frac{1}{p})^m=n \\\\m = \\log_{\\frac{1}{p}}n$$​ 跳表skiplist的平均查找长度，查找长度指的是查找路径上跨越的跳数，查找过程中的比较次数等于查找长度加1（每比较一次要么向下一层，要么到本层的右侧节点)。每个节点在进行插入的时候，它的层数是由随机函数randomLevel()计算出来的，随机的计算不依赖于其它的节点，每个节点是独立同分布的，每次插入过程都是完全独立的。 ​ 为了计算查找长度，我们将逆向还原查找过程，从右下方第一层最后到达的那个节点开始，沿着查找路径向左，向上回溯。假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。 如果某一个节点有上层节点的话，则我们需要向上走，整个查找过程类似楼梯的形状，每个节点第一被访问一定是位于其最顶层。 如果节点x有第i+1，那么我们需要向上走，这种情况概率为p 如果节点没有第i+1层指针，那么我们需要向左走，这种情况的概率为1-p 用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度，因此有$$C(k) = (1 - p)*(C(k) + 1) + p * (C(k - 1) + 1) \\\\C(k) = \\frac{1}{p} + C(k - 1) \\\\C(k) = \\frac{k}{p}$$n个节点跳表的层数为$\\log_{\\frac{1}{p}}n$， 因此所需时间为$\\frac{\\log_{\\frac{1}{p}}n}{p}$，即平均时间复杂度为$O(\\log n)$ 代码实现数据结构SkipListNode，skiplist真正有数据只有下面一层的数据节点，每个节点的后继就是level[0], 12345struct SkipListNode &#123; int val; vector&lt;SkipListNode *&gt; level; SkipListNode (int _val, int sz=32) : val(_val), level(sz, nullptr) &#123;&#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Skiplist &#123;private: SkipListNode *head, *tail; int level, length;public: static constexpr int MAXL = 32; static constexpr int P = 4; static constexpr int S = 0xFFFF; static constexpr int PS = S / 4; Skiplist() &#123; level = length = 0; tail = new SkipListNode(INT_MAX, 0); head = new SkipListNode(INT_MAX); for (int i = 0; i &lt; MAXL; ++i) &#123; head-&gt;level[i] = tail; &#125; &#125; SkipListNode* find(int val) &#123; SkipListNode *p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123; p = p-&gt;level[i]; &#125; &#125; p = p-&gt;level[0]; return p; &#125; bool search(int target) &#123; SkipListNode *p = find(target); return p-&gt;val == target; &#125; void add(int val) &#123; vector&lt;SkipListNode *&gt; update(MAXL); SkipListNode *p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123; p = p-&gt;level[i]; &#125; update[i] = p; &#125; int lv = randomLevel(); if (lv &gt; level) &#123; lv = ++level; update[lv - 1] = head; &#125; SkipListNode *newNode = new SkipListNode(val, lv); for (int i = lv - 1; i &gt;= 0; --i) &#123; p = update[i]; newNode-&gt;level[i] = p-&gt;level[i]; p-&gt;level[i] = newNode; &#125; ++length; &#125; bool erase(int val) &#123; vector&lt;SkipListNode *&gt; update(MAXL + 1); SkipListNode *p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123; p = p-&gt;level[i]; &#125; update[i] = p; &#125; p = p-&gt;level[0]; if (p-&gt;val != val) return false; for (int i = 0; i &lt; level; ++i) &#123; if (update[i]-&gt;level[i] != p) &#123; break; &#125; update[i]-&gt;level[i] = p-&gt;level[i]; &#125; while (level &gt; 0 &amp;&amp; head-&gt;level[level - 1] == tail) --level; --length; return true; &#125; int randomLevel() &#123; int lv = 1; while (lv &lt; MAXL &amp;&amp; (rand() &amp; S) &lt; PS) ++lv; return lv; &#125;&#125;; 参考文章http://zhangtielei.com/posts/blog-redis-skiplist.html ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf https://oi-wiki.org/ds/skiplist/#_4","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"JAVA反射","slug":"JAVA/JAVA反射","date":"2021-02-24T12:51:45.000Z","updated":"2021-09-10T08:53:11.498Z","comments":true,"path":"2021/02/24/JAVA/JAVA反射/","link":"","permalink":"http://abeltian.top/2021/02/24/JAVA/JAVA%E5%8F%8D%E5%B0%84/","excerpt":"","text":"JAVA 反射反射是为了解决运行期，对某个对象一无所知的情况下，调用其方法，JVM为每一个加载的class创建一个Class类型的实例，并关联起来。 通过Class实例获取class信息的方法称为反射(Reflection) 1. 访问字段 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。**** 2.调用方法3.调用构造方法、获取继承关系4.动态代理","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/tags/JAVA/"}]},{"title":"JAVA_Spring","slug":"JAVA/JAVA-Spring","date":"2021-02-24T12:17:40.000Z","updated":"2021-09-10T08:53:11.497Z","comments":true,"path":"2021/02/24/JAVA/JAVA-Spring/","link":"","permalink":"http://abeltian.top/2021/02/24/JAVA/JAVA-Spring/","excerpt":"","text":"IOC(Inversion of Control控制反转)应用本身不负责依赖对象的创建和维护，依赖对象的创建和维护是由外部容器负责的称为控制反转。 IOC容器管理的对象称为Bean，Bean是由Spring容器初始化，装配及管理的对象。 DI(Dependency Injection依赖注入)","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/categories/JAVA/"}],"tags":[{"name":"JAVA Spring","slug":"JAVA-Spring","permalink":"http://abeltian.top/tags/JAVA-Spring/"}]},{"title":"设计模式","slug":"JAVA/设计模式","date":"2021-02-22T12:03:14.000Z","updated":"2021-09-10T08:53:11.498Z","comments":true,"path":"2021/02/22/JAVA/设计模式/","link":"","permalink":"http://abeltian.top/2021/02/22/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式设计模式本质上是面向对象设计原则的实际运用。 1.1设计模式分类 创建型模式 结构型模式 行为型模式 UML 类图2.设计模式 代理模式：https://www.cnblogs.com/daniels/p/8242592.html 中介隔离作用， 代理类对象可以在客户类和委托对象之间起到中介的作用。 开闭原则，增加功能。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。可以通过给代理类增加额外的功能来扩展委托类的功能。 java动态代理 https://blog.csdn.net/yaomingyang/article/details/80981004","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://abeltian.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Miller-Rabin素数探测","slug":"数据结构与算法/Miller-Rabin素数探测","date":"2021-02-15T13:30:13.000Z","updated":"2021-09-10T08:53:11.502Z","comments":true,"path":"2021/02/15/数据结构与算法/Miller-Rabin素数探测/","link":"","permalink":"http://abeltian.top/2021/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Miller-Rabin%E7%B4%A0%E6%95%B0%E6%8E%A2%E6%B5%8B/","excerpt":"","text":"Miller-Rabin素数探测费马小定理，如果p为质数，且$gcd(a,p)=1$，那么$a^{p - 1} \\equiv 1 (mod\\ p)$， 如果p为质数，且a，p互质，那么a的p-1次方除以p的余数等于1。 二次探测定理， 如果p是素数，且x是小于p的正整数，且$x^2 \\equiv 1 (mod\\ p)$，那么$x = 1$或者$x =p - 1$。 Miller-Rabin素数探测，将p-1(偶数)表示为$d \\times 2^r$，其中d为奇数，如果p为素数，那么存在某个$0 \\le i &lt; r$使得$a^{d*2^{r - i}} mod\\ n = n - 1$，或者$a^d = 1$。 12345678910111213141516171819202122232425262728293031323334353637using ll = long long;vector&lt;int&gt; prime&#123;2, 3, 5&#125;;ll qpow(ll a, ll b, ll p) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125;// 如果是long long会发生溢出，则需要在模运算意义下计算快速积int TwiceDetect(ll a, ll b, ll p) &#123; int r = __builtin_ctz(b); ll d = b &gt;&gt; t; ll x, y; x = y = qpow(a, d, p); while (r--) &#123; y = x * x % p; if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != p - 1) return 1; //是合数返回1 x = y; &#125; return y != 1;&#125;bool miller_rabin(ll p) &#123; if (p == 2) return true; if (p &lt; 2 || p % 2 == 0) return false; for (int i = 0; i &lt; 3; ++i) &#123; ll base = prime[i]; if (p == base) return true; if (TwiceDetect(base, p - 1, p)) return 0; &#125; return 1;&#125;","categories":[],"tags":[{"name":"Data Stucture","slug":"Data-Stucture","permalink":"http://abeltian.top/tags/Data-Stucture/"}]},{"title":"线段树I","slug":"数据结构与算法/线段树I","date":"2021-02-05T10:03:40.000Z","updated":"2021-09-10T08:53:11.515Z","comments":true,"path":"2021/02/05/数据结构与算法/线段树I/","link":"","permalink":"http://abeltian.top/2021/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91I/","excerpt":"","text":"线段树线段树本质上开了O(4n)的空间来维护了数组区间的性质。根节点从下标1开始 1234567891011void build(int p, int l, int r) &#123; // p为当前l, r区间对应的下标， l为当前区键的左侧下标，r为右侧下标 if (l == r) &#123; //更新a[p] return; &#125; int mid = l + (r - l) / 2; build(p &lt;&lt; 1, l , mid); build(p &lt;&lt; 1 | 1, mid + 1, r); a[p] = f(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1])&#125; 惰性更新，当更新区间包含了当前的区间[l, r]，只需要更新当前的节点并进行标记。 123void update(int p, int l, int r, int ul, int ur, int val) &#123; &#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"可持久化并查集","slug":"数据结构与算法/可持久化并查集","date":"2021-02-04T09:15:35.000Z","updated":"2021-09-10T08:53:11.508Z","comments":true,"path":"2021/02/04/数据结构与算法/可持久化并查集/","link":"","permalink":"http://abeltian.top/2021/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"可持久化并查集可持久化并查集 = 可持久化 + 并查集 = 主席树 + 并查集 leetcode 1724 检查边长度限制的路径是否存在 II 主席树方便用来维护历史的版本信息，可以支持回退， 访问之前版本的数据结构。 并查集，常用的两种优化方法是路径压缩，按秩合并。在可持久化并查集中只会用到按秩合并，即深度小的点向深度大的点合并，保证单次查询的时间复杂度为$ologn$ 可持久化并查集进本操作，状态定义 1234int tot;int rt[N] // 保存每一个版本的头结点int ls[N &lt;&lt; 5], rs[N &lt;&lt; 5] // 每个节点的左右孩子int fa[N &lt;&lt; 5], sz[N &lt;&lt; 5] // 节点的父亲、树的高度 建立基础主席树 12345678910void build(int &amp;t, int l, int r) &#123; t = ++tot; if (l == r) &#123; fa[t] = l; return; &#125; int mid = l + (r - l) / 2; build(ls[t], l, mid); build(rs[t], mid + 1, r);&#125; 查找某一个元素在主席树中的下标 1234567int query(int t, int l, int r, int x) &#123; // t为某一历史版本的根节点下标， x为待查找的元素 if (l == r) return t; int mid = l + (r - l) / 2; if (x &lt;= mid) return query(ls[t], l, mid, x); else return query(rs[t], mid + 1, r, x);&#125; 查找版本号为t元素x的祖先 12345int find(int t, int l, int r, int x) &#123; int p = query(t, l, r, x); // 查询x的下标 if (fa[p] == x) return x; return find(t, l, r, fa[p]);&#125; 按秩合并 1234567891011121314int unite(int pre, int l, int r, int x, int father) &#123; // 修改x节点的父亲为father int t = ++tot; ls[t] = ls[pre], rs[t] = rs[pre]; if (l == r) &#123; fa[t] = father; sz[t] = sz[pre]; return t; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) ls[t] = unite(ls[pre], l, mid, x, father); else rs[t] = unite(rs[pre], mid + 1, r, x, father); return t;&#125; 更新合并后父节点的深度 123456789void update(int t, int l, int r, int x) &#123; if (l == r) &#123; sz[t]++; return; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) update(ls[t], l, mid, x); else update(rs[t], mid + 1, r, x);&#125; 全部代码如下, java用时329ms通过了全部测试用例， 但是用c++超时了…..不开o2优化太坑人了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#pragma GCC optimize(2)class DistanceLimitedPathsExist &#123;public: static constexpr int N = 10005; int tot, n; int rt[N], ls[N &lt;&lt; 5], rs[N &lt;&lt; 5], fa[N &lt;&lt; 5], sz[N &lt;&lt; 5]; vector&lt;int&gt; dis; void build(int &amp;t, int l, int r) &#123; t = ++tot; if (l == r) &#123; fa[t] = l; return; &#125; int mid = l + (r - l) / 2; build(ls[t], l, mid); build(rs[t], mid + 1, r); &#125; int query(int t, int l, int r, int x) &#123; if (l == r) return t; int mid = l + (r - l) / 2; if (x &lt;= mid) return query(ls[t], l, mid, x); else return query(rs[t], mid + 1, r, x); &#125; int find(int t, int l, int r, int x) &#123; int p = query(t, l, r, x); if (fa[p] == x) return p; return find(t, l, r, fa[p]); &#125; int unite(int pre, int l, int r, int x, int father) &#123; // 修改x节点的父亲为father int t = ++tot; ls[t] = ls[pre], rs[t] = rs[pre]; if (l == r) &#123; fa[t] = father; sz[t] = sz[pre]; return t; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) ls[t] = unite(ls[pre], l, mid, x, father); else rs[t] = unite(rs[pre], mid + 1, r, x, father); return t; &#125; void update(int t, int l, int r, int x) &#123; if (l == r) &#123; sz[t]++; return; &#125; int mid = l + (r - l) / 2; if (x &lt;= mid) update(ls[t], l, mid, x); else update(rs[t], mid + 1, r, x); &#125; DistanceLimitedPathsExist(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edgeList) &#123; tot = 0; this-&gt;n = n; memset(rt, 0, sizeof(rt)); memset(ls, 0, sizeof(ls)); memset(rs, 0, sizeof(rs)); memset(fa, 0, sizeof(fa)); memset(sz, 0, sizeof(sz)); sort(edgeList.begin(), edgeList.end(), [](auto a, auto b) &#123; return a[2] &lt; b[2]; &#125;); build(rt[0], 0, n - 1); for (int i = 0; i &lt; edgeList.size(); ++i) &#123; rt[i + 1] = rt[i]; int x = edgeList[i][0], y = edgeList[i][1]; int posx = find(rt[i], 0, n - 1, x), posy = find(rt[i], 0, n - 1, y); if (fa[posx] != fa[posy]) &#123; if (sz[posx] &gt; sz[posy]) swap(posx, posy); rt[i + 1] = unite(rt[i], 0, n - 1, fa[posx], fa[posy]); if (sz[posx] == sz[posy]) update(rt[i + 1], 0, n - 1, fa[posy]); &#125; dis.push_back(edgeList[i][2]); &#125; &#125; bool query(int p, int q, int limit) &#123; int num = upper_bound(dis.begin(), dis.end(), limit - 1) - dis.begin(); int version = rt[num]; int posx = find(version, 0, n - 1, p); int posy = find(version, 0, n - 1, q); if (fa[posx] == fa[posy]) return true; else return false; &#125;&#125;;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"主席树","slug":"数据结构与算法/主席树","date":"2021-02-03T02:28:14.000Z","updated":"2021-09-10T08:53:11.505Z","comments":true,"path":"2021/02/03/数据结构与算法/主席树/","link":"","permalink":"http://abeltian.top/2021/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"主席树（可持久化线段树）问题描述： 给定N个数（int范围内），一共M次询问，每次都要询问区间[[l,r]的第k大的数。 其中N, M, l, r均不超过$2\\times10^5$，保证询问有答案 ​ 主席树本名可持久化线段树，也就是说，主席树是基于线段树发展而来的一种数据结构。其前缀”可持久化”意在给线段树增加一些历史点来维护历史数据，使得我们能在较短时间内查询历史数据，图示如下。 当每插入一个数据时，会修改$logn$个节点，因为主席树的左右子树节点编号不能够计算得到，而是需要记录下来。 1234static constexpr int N = 200010int rt[N] // 记录插入第i个数后的根节点int ls[N &lt;&lt; 5], rs[N &lt;&lt; 5] // 记录左儿子，右儿子int sum[N &lt;&lt; 5] // 记录当前节点区间的元素个数 将数组复制一份，进行排序，去掉重复的数字离散化。 以离散化后的数组为基础建立一个全零的线段树，称为基础主席树 对原数据中每一个[1,i]区间统计，有序地插入新节点，i每增加1，就会多一个数，仅需对主席树对应的节点增加1即可 对于查询[l, r]中第k小值的操作，找到[l, r]对应的根节点，按照线段树操作的方法即可 建立基础主席树 1234567void build(int &amp;u, int l, int r) &#123; u = ++tot; if (l == r) return; int mid = l + (r - l) / 2; build(ls[u], l, mid); build(rs[u], mid + 1, r);&#125; 向主席树中加入元素 12345678910int modify(int pre, int l, int r, int x) &#123; int cur = ++tot; ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre] + 1; if (l == r) return cur; int mid = l + (r - l) / 2; if (x &lt;= mid) ls[cur] = modify(ls[cur], l, mid); else rs[cur] = modify(rs[cur], mid + 1, r); return cur; &#125; 查询区间第k大，注意区间下标是从1开始 12345678int query(int u, int v, int l, int r, int k) &#123; int ans = 0, x = sum[ls[v]] - sum[ls[u]]; int mid = l + (r - l) / 2; if (l == r) return l; if (k &lt;= x) ans = query(ls[u], ls[v], l, mid, k); else ans = query(rs[u], rs[v], mid + 1, r, k - x); return ans;&#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"数据库","slug":"数据结构与算法/数据库","date":"2021-02-02T09:39:39.000Z","updated":"2021-09-10T08:53:11.510Z","comments":true,"path":"2021/02/02/数据结构与算法/数据库/","link":"","permalink":"http://abeltian.top/2021/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"一片介绍rank() dense_rank()很好的文章https://blog.csdn.net/u011726005/article/details/94592866","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://abeltian.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"博弈--极大极小博弈树","slug":"数据结构与算法/极大极小博弈树","date":"2021-01-31T10:04:02.000Z","updated":"2021-09-10T08:53:11.511Z","comments":true,"path":"2021/01/31/数据结构与算法/极大极小博弈树/","link":"","permalink":"http://abeltian.top/2021/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%8D%9A%E5%BC%88%E6%A0%91/","excerpt":"","text":"博弈博弈的两种的分类： 动态博弈是指在博弈中，两个参与人有行动的先后顺序，且后行动者能够观察到先行动者所选择的行动。 静态博弈是指在博弈中，两个参与人同时选择或不同时选择时，后行动者并不知道先行动者采取什么样的具体行动。 1. 极大极小博弈树​ 由于动态博弈参与者的行动有先后顺序，因此参与者的行动构成的为树状结构。 ​ 博弈通常是双方对抗，甚至是零和的博弈。也就是说，对对方最有利的决策，反过来就是对我方最不利的局面。在轮到我们做出决策的时候，我们通常希望最大化我们的收益，叫做极大层，此时树的节点叫做极大层节点；在对手做决策的时候，对手希望最小化我们的收益，叫做极小层，此时树的节点叫做极小层节点。由于双方是交替做出决策，因此极大层、极小层通常是交替出现，这样的数据结构就叫做极大极小树（Min-Max Tree）。 「必胜态」和「必败态」的概念： 一个状态为「必胜态」，当且仅当其相邻状态中至少有一个「必败态」。这里相邻的状态的定义为：在当前状态中进行决策的玩家可以到达的所有状态。也就是说，玩家可以选择移动到一个「必败态」，使得对手必败，因此当前状态是必胜的。 一个状态为「必败态」，当且仅当其相邻的所有状态都是「必胜态」。这里的道理是类似的，如果所有相邻状态都是「必胜态」，那么对手必胜，当前玩家必败。 2.从已知状态进行搜索从已知的最终状态进行倒推之前状态的可能性，考虑已有的可能的几种状态 leetcode 913 猫和老鼠 此步老鼠胜利，上一步为老鼠行动，则上一步老鼠为必胜态 此步老鼠胜利，上一步为猫行动，则上一步猫行动状态的出度减一，(因为猫走该步后不肯能胜利)，只有当猫行动后所有的子状态均为老鼠的必胜态时，即出度为0时，此时猫所处的状态为必败态。 此步猫胜利，上一步为猫行动，则上一步猫的状态为必胜态。 此步猫胜利，上一步为老鼠行动，同上。 状态定义 f[i][j][0]为老鼠处于i，猫处于j，此时为老鼠行动，上一步为猫行动。 老鼠胜利：1， 猫胜利： 2， 平局： 0，最终返回初始状态的值。","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/categories/Alogrithm/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"扩展欧几里得算法","slug":"数据结构与算法/exgcd","date":"2021-01-26T04:49:27.000Z","updated":"2021-09-10T08:53:11.503Z","comments":true,"path":"2021/01/26/数据结构与算法/exgcd/","link":"","permalink":"http://abeltian.top/2021/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/exgcd/","excerpt":"","text":"扩展欧几里得算法在求最大公约数时，基于一个基本的事实$(a, b) = (b, a - \\lfloor \\frac{a}{b}\\rfloor b) = (b, a\\ mod \\ b)$，直到$b = 0$，此时$(a, 0) = a$。这种求最大公约数的算法叫做辗转相除法，又叫做欧几里得算法。 1234567int gcd(int a, int b) &#123; while (b != 0) &#123; a %= b; swap(a, b); &#125; return a;&#125; 裴蜀定理：假设$a, b$是不全为0的整数，则存在整数$x, y$使得$ax + by = gcd(a, b)$。 简单证明：$$gcd(a, b) = gcd(b, a\\ mod\\ b) = gcd(b, a - kb) = gcd(r_1, r_2) = \\dots = gcd(r_n, 0)$$其中$r_1, r_2 \\dots r_n$都可以写成$x_ia + y_ib$的形式，因此存在$ax + by = gcd(a, b)$ 扩展欧几里得算法在求解最大公约数的同时，计算了一组适于裴蜀定理的系数。递推关系的推导，$(a, b) = (b, a\\ mod\\ b) = (b, a - \\lfloor \\frac{a}{b} \\rfloor b)$，因此存在四个整数$x, y, x’, y’$使得$$ax + by = bx’ + (a - \\lfloor \\frac{a}{b} \\rfloor b)y’ \\\\a(x - y’) + b(y - (x’ - \\lfloor \\frac{a}{b} \\rfloor)y’) = 0 \\\\x = y’, y = x’ - \\lfloor \\frac{a}{b} \\rfloor y’$$ 123456789101112ex_gcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int tmp = x; x = y; y = tmp - a / b * y; return d;&#125; 上述算法可以改写为迭代的形式，递推公式$$\\left{ \\begin{array}{rcl}{\\rm{x}} = y’ \\\\{y = x’ - \\lfloor \\frac{a}{b} \\rfloor y’}\\end{array} \\right.$$将其写为矩阵的形式 $$\\left( \\begin{array}{rcl}x \\\\y\\end{array} \\right) = \\left( \\begin{array}{rcl}0&amp;1 \\\\1&amp;{ -\\lfloor \\frac{a}{b} \\rfloor}\\end{array} \\right)\\left( \\begin{array}{rcl}{x’} \\\\{y’}\\end{array} \\right)$$ 初始矩阵为单位矩阵 $\\left( \\begin{array}{rcl}x&amp;m\\\\y&amp;n\\end{array} \\right) = \\left( \\begin{array}{rcl}x&amp;m\\\\y&amp;n\\end{array} \\right)\\left( \\begin{array}{rcl}0&amp;1\\\\1&amp;{ - d}\\end{array} \\right) = \\left( \\begin{array}{rcl}m&amp;{x - dm}\\\\n&amp;{y - dn}\\end{array} \\right)$ 当b=0时，计算结束，此时x, y为满足裴蜀定理的系数，最大公约数为a。","categories":[],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"乘法逆元","slug":"数据结构与算法/乘法逆元","date":"2021-01-25T14:11:43.000Z","updated":"2021-09-10T08:53:11.506Z","comments":true,"path":"2021/01/25/数据结构与算法/乘法逆元/","link":"","permalink":"http://abeltian.top/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/","excerpt":"","text":"乘法逆元1. 逆元的定义如果一个线性同余方程$ax \\equiv 1 (mod\\ b)$，则称$x$为$a\\ mod\\ b$的逆元，记作$a^{-1}$。 模运算规则与基本四则运算类似，但是除法例外。在ACM竞赛中，除法取模的运算要用到求逆元，从而得到$(a / b) \\% c = (a * x) \\% c$ 证明：已知$(b * x) \\% c = 1$，假设$(a / b) \\% c = y_1, (a * x) \\% c = y_2$ 则 $a / b = k_1*c + y_1\\quad(1)$ $a*x = k_2 * c + y_2\\quad(2)$ $(1) -(2)$$\\quad \\rightarrow \\quad a/b - a*x = (k_1 - k_2)*c + (y_1 - y_2)$ 左右同时乘以b $\\quad \\rightarrow \\quad$ $a - a * x * b = k * c * b + (y1 - y2) * b$ 左右模上c $\\quad \\rightarrow \\quad (y1 - y2) * b \\% c = 0$ 因为$b \\neq 0$, 所以$y_1 = y_2$ 2. 求逆元费马小定理，若p为素数，且$gcd(a, p) = 1$，则$a^{p - 1} \\equiv 1 (mod\\ p)$ 证明： 构造一个序列$A={1, 2, 3, \\dots p - 1}$， 这个序列有如下的性质: $\\mathop{\\Pi}\\limits_{i = 1}^{n}A_i = \\mathop{\\Pi}\\limits_{i = 1}^{n}(A_i \\times a)$ 对于任意$i, j \\in n $，$(A_i * a )\\% p \\neq (A_j * a )\\% p$，因为$(A_i - A_j) * a \\% p = 0$，则$A_i - A_j = 0$ 因此$(p - 1)! \\equiv (p - 1)! * a^{p - 1}\\ (mod\\ p) \\quad \\rightarrow a^{p - 1} \\equiv 1 \\ mod(\\ p)$ 2.1 扩展欧几里得算法扩展欧几里得算法 求解同余方程$ax \\equiv 1 (mod\\ b)$的最小整数解 假设采用扩展欧几里得算法求得一组$x_0, y_0$满足$ax_0 +by_0 = gcd(a, b)$，则该方程的任意解可以表示为$x = x_0 + bt, y = y_0-at$，对于任意t均成立，最小整数解可以表示为$x = ((x_0\\ mod\\ b) + b) mod\\ b$ 2.2快速幂算法根据费马小定理，$1 \\equiv a^{p -1} (mod\\ p)$，因此$x = a^{p - 2}$，可以采用快速幂算法进行计算。 1234567891011ll qpow(long long a, long long b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) &#123; ret = (ret * a) % mod; &#125; b &gt;&gt;= 1; a = (a * a) % mod; &#125; return ret;&#125; 2.3 线性求逆元求出$1, 2, \\dots, n$中每个数关于p的逆元。 显然$1{-1} \\equiv 1 (mod\\ p)$ 令$k = \\lfloor\\frac{p}{i} \\rfloor, j = p\\ mod\\ i$, 因此有$p = ki + j$，在模p的意义下就有$ki + j \\equiv 0\\ (mod\\ p)$ 左右同乘以$i^{-1}, j^{-1}$，有$kj^{-1} + i^{-1}=0$ $i^{-1}=-kj^{-1} = (p - k)j^{-1}$ 12345678static const expr mod = 1e9 + 7;ll fac[N], R[N], inv[N];fac[0] = fac[1] = R[0] = R[1] = inv[0] = inv[1] = 1;for (int i = 2; i &lt;= n; ++i) &#123; fac[i] = 1LL * fac[i - 1] * i % mod; inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod; R[i] = 1LL * R[i - 1] * inv[i] % mod;&#125; 1234ll comb(int n, int m) &#123; if (n &lt; m) return 0; return 1LL * fac[n] * R[m] % mod * R[n - m] % mod;&#125; 2.4 线性求任意n个数的逆元1234567891011121314151617181920212223242526272829303132using LL = long long;static constexpr LL mod = 99997867;static constexpr int N = 1000005;LL fac[N], rf[N];LL qpow(LL a, LL b) &#123; LL ret = 1; while (b) &#123; if (b &amp; 1) &#123; ret = ret * a % mod; &#125; b &gt;&gt;= 1; a = a * a % mod; &#125; return ret;&#125;void init() &#123; fac[0] = 1; for (int i = 1; i &lt; N; ++i) &#123; fac[i] = fac[i - 1] * i % mod; &#125; rf[N - 1] = qpow(fac[N - 1], mod - 2); for (int i = N - 2; i &gt;= 0; --i) &#123; rf[i] = rf[i + 1] * (i + 1) % mod; &#125;&#125;LL comb(int n, int m) &#123; if (n &lt; m || m &lt; 0) return 0; return fac[n] * rf[n - m] % mod * rf[m] % mod;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"洗牌算法","slug":"数据结构与算法/洗牌算法","date":"2021-01-18T08:25:26.000Z","updated":"2021-09-10T08:53:11.514Z","comments":true,"path":"2021/01/18/数据结构与算法/洗牌算法/","link":"","permalink":"http://abeltian.top/2021/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"洗牌算法 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。 int [] shuffle()返回数据随机打乱后的结果。 打乱的概念 随机打乱后的结果能够覆盖所有的情况，比如数组元素的个数为n，那么打乱后的结果应该覆盖$n!$种所有可能的结果 所有结果等概率出现 方法一 暴力暴力的方法就是模拟，假设数组中的每个元素为一个小球，我们将其放入袋子中，进行不放回的抽取，直到袋子中没有小球，我们将抽取出来的小球按顺序排列得到一个排列组合，这个排列组合出现的概率为$\\frac{1}{n!}$，因此这个 数组的每个排列组合都是等概的，算法时间复杂度$O(n2)$，vector&lt;int&gt;的erase()删除操作是O(n)的。 对于某一个排列组合其出现概率为$$\\mathop{\\Pi}\\limits_{k = 0}^{n - 1}\\frac{1}{n - k} = \\frac{1}{n!}$$ 方法二 Fisher-Yates算法Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个当前数组末尾指针下标的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换，这步模拟了每次从袋子里面摸一个元素的过程。 12345678vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; int pos = rand() % (i + 1); swap(arr[i], arr[pos]); &#125; return arr;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"}]},{"title":"凸优化","slug":"数据结构与算法/凸优化","date":"2021-01-12T08:12:52.000Z","updated":"2021-09-10T08:53:11.506Z","comments":true,"path":"2021/01/12/数据结构与算法/凸优化/","link":"","permalink":"http://abeltian.top/2021/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%87%B8%E4%BC%98%E5%8C%96/","excerpt":"","text":"凸优化leetcode 1515 服务中心的最佳位置 一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。给你一个数组 positions ，其中 positions[i] = [xi, yi] 表示第 i 个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 该问题本质上优化的函数如下：$$f(x_c, y_c) = \\sum\\limits_{i = 0}^{n - 1}\\sqrt{(x_c - x_i)^2 + (y_c - y_i)^2}$$其中$(x_c, y_c)$为服务器中心的位置，其可以使$f(x_c, y_c)$取得最小值。该函数是凸函数，凸优化问题的局部最优解就是全局最优解。 1.凸集$C$是凸集，如果对于任意的$x,y\\in C$和任意的$\\theta \\in \\mathbb{R}$且满足$0 \\le \\theta \\le 1$时，$\\theta x + (1 - \\theta) y$恒成立。 2.凸函数2.1 凸函数定义定义在$\\mathbb{R}^n \\rightarrow \\mathbb{R}$上的函数$f$是凸函数， 当且仅当它的定义域$\\mathbb{D}(f)$是一个凸集，且对于任意的$x, y \\in \\mathbb{D}$和$ 0 \\le \\theta \\le 1$， $f(\\theta x + (1 - \\theta)y) \\le \\theta f(x) + (1 - \\theta)f(y)$恒成立。 2.2 凸函数的一阶充要条件假设定义在$\\mathbb{R}^n \\rightarrow \\mathbb{R}$上的函数$f$可微， 即对于所有的$x \\in \\mathbb{D}(f)$，梯度$\\nabla f(x)$均存在，则函数$f$是凸函数当且仅当函数定义域$\\mathbb{D}(f)$是一个凸集合，且对于所有$x, y \\in \\mathbb{D}(f)$均满足：$$f(y) \\ge f(x) + \\nabla f(x)^T(y - x)$$ 2.3 凸函数的二阶充要条件记凸函数$f$的一阶导数和二阶导数分别为$g$和$H$$$\\nabla f = \\begin{bmatrix} \\frac{\\partial f}{\\partial x_1} \\\\ \\frac{\\partial f}{\\partial x_2}\\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial x_n} \\end{bmatrix} \\quadH = \\nabla^2f = \\begin{bmatrix} \\frac{\\partial^2f}{\\partial x_1^2} &amp; \\frac{\\partial^2f}{\\partial x_1 \\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2f}{\\partial x_1 \\partial x_n} \\\\ \\frac{\\partial^2f}{\\partial x_2 \\partial x_1} &amp; \\frac{\\partial^2f}{\\partial x_2^2} &amp; \\cdots &amp; \\frac{\\partial^2f}{\\partial x_2 \\partial x_n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\frac{\\partial^2f}{\\partial x_n \\partial x_1} &amp; \\frac{\\partial^2df}{\\partial x_n \\partial x_2} &amp; \\cdots &amp; \\frac{\\partial^2f}{\\partial x_n^2} \\end{bmatrix}$$$f$在$x_k$处的二阶泰勒展开为$$f(x) = f(x_k) + \\nabla f^T (x - x_k) + \\frac{1}{2!}(x - x_k)H(x_k)(x - x_k) + o^n$$假设定义在$\\mathbb{R}^n \\rightarrow \\mathbb{R}$上的函数$f$二阶可微， 即对于所有的$x \\in \\mathbb{D}(f)$，海森矩阵$\\nabla^2 f(x)$均存在，则函数$f$是凸函数当且仅当函数定义域$\\mathbb{D}(f)$是一个凸集合，且对于所有$x, y \\in \\mathbb{D}(f)$均满足$H$为半正定矩阵。 3.凸优化可以证明本题优化的函数$f$为$\\mathbb{R}^2$的上凸函数。 梯度下降 模拟退火 爬山算法 三分搜索 3.1 梯度下降梯度下降算法，梯度下降是机器学习中常用的一种求局部最小值的算法，对于给定点$(x, y)$，它的梯度方向是函数值上升最快的方向，因此负梯度为函数值下降的最快的方向，$-\\nabla f = (-\\frac{\\partial f}{\\partial x}, -\\frac{\\partial f}{\\partial y})$，我们从一个初始点$(x_{start}, y_{start})$开始迭代， 每次令$$x \\prime = x - \\alpha \\cdot \\frac{\\partial f}{\\partial x} \\\\y \\prime = y - \\alpha \\cdot \\frac{\\partial f}{\\partial y}$$ 初始点$(x_{start}, y_{start})=(\\frac{\\sum\\limits_{i =0}^{n-1}x_i}{n},\\frac{\\sum\\limits_{i =0}^{n-1}y_i}{n})$ 学习率$\\alpha = 1$ 学习率衰减$\\eta = 0.001$ 当$(x \\prime, y\\prime)$与$(x, y)$的距离小于$10^{-7}$时结束迭代。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123; int n = positions.size(); double eps = 1e-7, alpha = 1, decay = 0.001; double x = 0, y = 0; for (auto p : positions) &#123; x += p[0]; y += p[1]; &#125; x = x / n; y = y / n; auto getDis = [&amp;](double x, double y) &#123; double ans = 0; for(auto p : positions) &#123; ans += sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1])); &#125; return ans; &#125;; while (true) &#123; double prex = x, prey = y; double dx = 0, dy = 0; for (auto p : positions) &#123; double base = max(1e-9, sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]))); dx += (x - p[0]) / base; dy += (y - p[1]) / base; &#125; x -= alpha * dx; y -= alpha * dy; alpha = alpha * (1 - decay); if (sqrt((x - prex) * (x - prex) + (y - prey) * (y - prey)) &lt; eps) &#123; break; &#125; &#125; return getDis(x, y); &#125;&#125;; 整体写下来，尝试了很多次，初始值与学习率与学习率衰减的设置都会很大程度上影响是否能够收敛到最优值。该算法对初始化参数设置的依赖较大。 3.2 爬山算法如果给定的凸函数很难求导，我们注意到负梯度方向，$\\nabla f = -\\frac{\\partial f}{\\partial x}(1, 0) -\\frac{\\partial f}{\\partial y}(0, 1)$，开始我们选择一个步长，表示每次移动的距离。如果我们当前在位置$(x, y)$，我们一次枚举四个方向，判断其函数值是否更小，如果更小则进行移动，否则说明我们的步长过大，直接跳过了最优值点，调整步长为原来的一半，直到步长小于给定的阈值。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123; int n = positions.size(); double eps = 1e-8, step = 100; double x = 0, y = 0; for (auto p : positions) &#123; x += p[0]; y += p[1]; &#125; x /= n; y /= n; auto getDis = [&amp;](double x, double y) &#123; double ans = 0; for (auto p : positions) &#123; ans += sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1])); &#125; return ans; &#125;; vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; double d = getDis(x, y); while (step &gt; eps) &#123; bool flag = false; for (int k = 0; k &lt; 4; ++k) &#123; double nx = x + step * dir[k][0], ny = y + step * dir[k][1]; double t = getDis(nx, ny); if (t &lt; d) &#123; x = nx; y = ny; d = t; flag = true; break; &#125; &#125; if (!flag) step /= 2; &#125; return d; &#125;&#125;;","categories":[{"name":"凸优化","slug":"凸优化","permalink":"http://abeltian.top/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"并查集","slug":"数据结构与算法/并查集","date":"2021-01-06T03:44:37.000Z","updated":"2021-09-10T08:53:11.509Z","comments":true,"path":"2021/01/06/数据结构与算法/并查集/","link":"","permalink":"http://abeltian.top/2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集可以说在算法中应用很广泛，最主要用来判断图的连通性的问题。之前做的题很少包含按秩合并，最多就是按照两个连通分量的大小进行合并。今天第一次碰到了按照秩进行合并的并查集问题，leetcode 399 除法求值，描述如下： 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 输入：equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000] 1.深度优先搜索因为数据规模不大，a / b = 2，可以表示为a到b有一条权值为2的边，b到a有一条权值为0.5的边，因此对于每一个查询，可以采用深度优先搜索的方式进行查找，记录路径与当前的乘积，时间复杂度为O(n)。 2.并查集方法 a / b = 2.0 说明a 与 b在一个集合中，a = 2b 带路径压缩的查询$$w[x] = \\frac{v[x]}{v[father} \\w[x] = \\frac{v[x]}{v[fa[x]]} * \\frac{v[fa[x]]}{v[father]} \\w[x] = w[x] * w[fa[x]]$$ 按秩合并 合并两个节点的父亲，要更新两个父亲之间的权值。$$w[fx] = \\frac{v[fx]}{v[fy]} \\w[fx] = \\frac{v[x]}{w[x]} / \\frac{v[y]}{w[y]} \\$$ 1234567891011121314151617181920212223242526272829303132333435class UnionFind &#123;private: int n; vector&lt;int&gt; fa; vector&lt;double&gt; w;public: UnionFind(int _n) : n(_n), fa(n, 0), w(n, 1.0) &#123; for (int i = 0; i &lt; n; ++i) fa[i] = i; &#125; int find(int x) &#123; if (x != fa[x]) &#123; int father = find(fa[x]); w[x] *= w[fa[x]]; fa[x] = father; &#125; return fa[x]; &#125; void unite(int x, int y, double weight) &#123; int fx = find(x), fy = find(y); if (fx == fy) return; fa[fx] = fy; w[fx] = weight * w[y] / w[x]; &#125; double isConnected(int x, int y) &#123; int fx = find(x), fy = find(y); if (fx == fy) &#123; return w[x] / w[y]; &#125; else &#123; return -1; &#125; &#125;&#125;; 1234567891011121314151617181920class Solution &#123;public: vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123; unordered_map&lt;string, int&gt; mp; int idx = 0, n = equations.size(); UnionFind uf(2 * n); for (int i = 0; i &lt; n; ++i) &#123; string s = equations[i][0], t = equations[i][1]; if (!mp.count(s)) mp[s] = idx++; if (!mp.count(t)) mp[t] = idx++; uf.unite(mp[s], mp[t], values[i]); &#125; vector&lt;double&gt; ans; for (auto p : queries) &#123; if (!mp.count(p[0]) || !mp.count(p[1])) ans.push_back(-1.0); else ans.push_back(uf.isConnected(mp[p[0]], mp[p[1]])); &#125; return ans; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://abeltian.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"树与图上的动态规划III","slug":"数据结构与算法/树与图上的动态规划III","date":"2020-12-29T03:53:44.000Z","updated":"2021-09-10T08:53:11.512Z","comments":true,"path":"2020/12/29/数据结构与算法/树与图上的动态规划III/","link":"","permalink":"http://abeltian.top/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E5%9B%BE%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92III/","excerpt":"","text":"洛谷p1122 最大子树和 题目中给出了N个点的权值，与N-1条边的连接关系，并未给出根。 $1 \\le N \\le 16000$ 开始总是想需不需要换根，该题本质上是求树上点 权值和最大的一个连通分量，因此选择哪个点为根对结果没有影响，任一连通分量在某一时刻总是可以视为一颗以某个点为根的数。$$f[u] += max(f[v], 0) \\ans = max(ans, f[u])$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;int f[16005], s[16005], head[40000], tot, ans = INT_MIN;struct edge&#123; int to, nxt;&#125; e[40000];void add(int u, int v) &#123; e[++tot] = &#123;v, head[u]&#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; f[u] = s[u]; for (int i = head[u]; i; i = e[i]. nxt) &#123; int v = e[i].to; if (v == fa) continue; dfs(v, u); f[u] += max(f[v], 0); &#125; ans = max(ans, f[u]);&#125;int main(int argc, char *argv[]) &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; &#125; int u, v; for (int i = 0; i &lt; n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 洛谷 p1613 跑路 题目大意，图结构，如果i到j的距离为$2^k$千米，那么只需要1s时间。 $n \\le 50, m \\le 10000$ 因为涉及到$2^k$，因此为倍增算法，先进行预处理，状态表示f[i][j][k]表示i到j有一条距离为$2^k$的边。$$f[i][j][k] = f[i][l][k - 1] &amp;&amp; f[l][j][k - 1] \\1 \\le l \\le n$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int dis[60][60];bool f[60][60][65];int n, m;void work() &#123; for (int l = 1; l &lt;= 64; ++l) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int k = 1; k &lt;= n; ++k) &#123; f[i][j][l] = f[i][k][l - 1] &amp;&amp; f[k][j][l - 1]; if (f[i][j][l]) &#123; dis[i][j] = 1; break; &#125; &#125; &#125; &#125; &#125;&#125;void floyd() &#123; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; memset(dis, 63, sizeof(dis)); int u, v; for (int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; dis[u][v] = 1; f[u][v][0] = true; &#125; work(); floyd(); cout &lt;&lt; dis[1][n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"树与图上的动态规划II","slug":"数据结构与算法/树与图上的动态规划II","date":"2020-12-28T12:37:20.000Z","updated":"2021-09-10T08:53:11.512Z","comments":true,"path":"2020/12/28/数据结构与算法/树与图上的动态规划II/","link":"","permalink":"http://abeltian.top/2020/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8E%E5%9B%BE%E4%B8%8A%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92II/","excerpt":"","text":"洛谷P2014 选课 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 NNN 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 MMM 门课程学习，问他能获得的最大学分是多少？ 每门课只有一门先修课， 因此该图结构为森林，假设没有选修课的父节点都指向零，因此如果要选择子节点，则必须要选择父节点，因为父节点为选修课的要求。 转换为树上背包问题$$dp[i][j] = max(dp[i][j], dp[i][j - k] + dp[x][k]) \\quad x为i的子节点。$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int f[305][305], head[305], tot, scores[305], sz[305];struct edge&#123; int to, nxt;&#125; edges[305];void add(int u, int v) &#123; edges[++tot] = &#123;v, head[u]&#125;; head[u] = tot;&#125;void dfs(int u) &#123; sz[u] = 1; f[u][1] = scores[u]; for (int i = head[u]; i; i = edges[i].nxt) &#123; int v = edges[i].to; dfs(v); sz[u] += sz[v]; for (int j = sz[u]; j &gt;= 1; --j) &#123; for (int k = min(j - 1, sz[v]); k &gt;= 0; --k) &#123; f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]); &#125; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int k, s; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; k &gt;&gt; scores[i]; add(k, i); &#125; dfs(0); cout &lt;&lt; f[0][++m] &lt;&lt; endl; //注意包含了0节点，因此要多选一门 return 0;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"树与图上的动态规划","slug":"数据结构与算法/树形动态规划","date":"2020-12-27T02:51:43.000Z","updated":"2021-09-10T08:53:11.513Z","comments":true,"path":"2020/12/27/数据结构与算法/树形动态规划/","link":"","permalink":"http://abeltian.top/2020/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"树与图上的动态规划洛谷p 2015 二叉苹果树 二叉树共有N个结点，编号为1-N，树根编号一定是1。每颗树枝上有一定数量苹果，给定需要保留的树枝数量，求出最多能留住多少苹果。 $1\\le N, Q \\le 100$ 通常定义图的方式为：e[tot]记录了某条边的连接信息，head[u]记录了边的序号。 12345678struct edge &#123; int to, nxt, w;&#125; e[MAXN];void add(u, v, w) &#123; e[++tot] = &#123;v, head[u], w&#125;; head[u] = tot;&#125; 状态定义： 1f[u][i]表示u的子树上保留i条边，最多可保留的苹果数目 状态转移方程，n颗树的01背包问题。$$f[u][i] = max(f[u][i], f[u][i - j - i] + f[v][j] + e[u-&gt;v].w)$$保留一条边必须保留从根节点到这条边路径上的所有边，若果要保留子树v上的边，那么必须保留u到v的这条边。 整体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int n, rem, tot; int f[105][105], sz[105], head[105];struct edge &#123; int to, nxt, w;&#125; e[105 &lt;&lt; 1];void add(int u, int v, int w) &#123; e[++tot] = &#123;v, head[u], w&#125;; head[u] = tot;&#125;void dfs(int u, int fa) &#123; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (v == fa) continue; dfs(v, u); sz[u] += sz[v] + 1; for (int j = min(rem, sz[u]); j &gt;= 0; --j) &#123; for (int k = min(j - 1, sz[v]); k &gt;= 0; --k) &#123; f[u][j] = max(f[u][j], f[u][j - k - 1] + f[v][k] + e[i].w); &#125; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; rem; int u, v, w; for (int i = 0; i &lt; n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); &#125; dfs(1, -1); cout &lt;&lt; f[1][min(sz[1], rem)] &lt;&lt; endl; return 0; &#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"动态规划优化-单调队列","slug":"数据结构与算法/动态规划优化","date":"2020-12-22T12:03:51.000Z","updated":"2021-09-10T08:53:11.507Z","comments":true,"path":"2020/12/22/数据结构与算法/动态规划优化/","link":"","permalink":"http://abeltian.top/2020/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96/","excerpt":"","text":"动态规划优化-单调队列当状态转移的复杂度为$O(n)$时， 状态个数为n个，动态规划的算法复杂度为$O(n^2)$，可能会超时，因此对状态转移的过程进行优化，将状态转移的复杂度降低到$O(logn)$或$O(1)$ 例1 多重背包的单调队列优化 有 N 种物品和一个容量是 V的背包。第 i种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是$w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。0&lt;N≤10000&lt;V≤200000&lt;$s_i$,$v_i$,$w_i$≤20000 状态转移方程，可以按照体积进行分组，本质上是求一个滑动窗口的最大值。$$dp[j+mv] = max(dp[j] + mw, dp[j+v] + (m - 1)w, \\dots, dp[j+mv])$$对上面的状态转移方程进行变形,采用单调队列进行优化，代码如下：$$dp[j+mv] = max(dp[j], dp[j+v] - w, \\dots, dp[j+mv]) + mw$$ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int dp[20010], pre[20010], dq[20010];int main() &#123; int n, m, v, w, s; cin &gt;&gt; n &gt;&gt; m; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(pre, dp, sizeof(dp)); memset(dp, 0, sizeof(dp)); for (int j = 0; j &lt; v; ++j) &#123; int head = 0, tail = -1; for (int k = j; k &lt;= m; k += v) &#123; while (head &lt;= tail &amp;&amp; pre[k] - pre[dq[tail]] &gt; (k - dq[tail]) / v * w) &#123; tail--; &#125; dq[++tail] = k; if ((k - dq[head]) / v &gt; s) head++; dp[k] = pre[dq[head]] + (k - dq[head]) / v * w; &#125; &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; return 0;&#125; 例2 跳跃游戏VI 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界, 达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。请你返回你能得到的 最大得分 。 1 &lt;= nums.length, k &lt;= $10^5$$-10^4$ &lt;= nums[i] &lt;= $10^4$ 状态转移方程 $$f[i]=\\max_{max(0,i−k)≤j&lt;i}​{f[j]}+nums[i]$$ 该状态转移方程为$O(n^2)$，但是我们仅需要前面这个滑动窗中的最大值，因此采用单调队列的方式进行优化，使得队列头部为该滑动窗的最大值。 12345678910111213141516171819class Solution &#123;public: int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); deque&lt;int&gt; dq&#123;0&#125;; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (i - dq.front() &gt; k) dq.pop_front(); int val = dp[dq.front()] + nums[i]; while (!dq.empty() &amp;&amp; val &gt; dp[dq.back()]) &#123; dq.pop_back(); &#125; dq.push_back(i); dp[i] = val; &#125; return dp[n - 1]; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode_372","slug":"数据结构与算法/leetcode-372","date":"2020-12-21T09:35:27.000Z","updated":"2021-09-10T08:53:11.503Z","comments":true,"path":"2020/12/21/数据结构与算法/leetcode-372/","link":"","permalink":"http://abeltian.top/2020/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode-372/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"leetcode 418 屏幕可显示句子的数量","slug":"数据结构与算法/leetcode-418","date":"2020-12-20T12:46:39.000Z","updated":"2021-09-10T08:53:11.504Z","comments":true,"path":"2020/12/20/数据结构与算法/leetcode-418/","link":"","permalink":"http://abeltian.top/2020/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode-418/","excerpt":"","text":"题目描述 给你一个 rows x cols 的屏幕和一个用 非空 的单词列表组成的句子，请你计算出给定句子可以在屏幕上完整显示的次数。 单词不能拆分成两行。 单词在句子中的顺序必须保持不变。 在一行中 的两个连续单词必须用一个空格符分隔。 句子中的单词总量不会超过 100。 每个单词的长度大于 0 且不会超过 10。 1 ≤ rows, cols ≤ 20,000. 方法1 暴力模拟(超时）​ 开始看这道题没什么思路，放置单词这个应该没有什么规律，只能去暴力计算放置字符串的位置，模拟了一下在pos这个位置放置一个句子，下一次放置该句子的位置与行数。无奈被这个数据给卡了[“a”], 20000, 20000，按句子模拟必然超时。 方法2 动态规划​ 这道题的trick在于单词数量比较少，不超过100个，并且当单词不能放入当前行时，下一次其一定放置在下一行的行首。这样可以定义两个状态，这样预处理的时间复杂度为$O(mN)$, 计算放置句子个数的过程时间复杂度为$O(N)$$$count[j] \\quad 以第j个单词为当前行第一个单词时，放置的句子的个数 \\next[j] \\quad 以第j个单词为当前行第一个单词时，下一行第一个单词$$ 123456789101112131415161718192021222324252627class Solution &#123;public: int wordsTyping(vector&lt;string&gt;&amp; sentence, int rows, int cols) &#123; int n = sentence.size(); vector&lt;int&gt; cnt(n, 0), next(n, 0); vector&lt;int&gt; arr; for (string s : sentence) &#123; arr.push_back(s.size()); &#125; for (int i = 0; i &lt; n; ++i) &#123; int tmp = 0, idx = i; for (int j = 0; j &lt;= cols + 1;) &#123; j += arr[idx] + 1; if (j &gt; cols + 1) break; if (idx == n - 1) tmp++; idx = (idx + 1) % n; &#125; cnt[i] = tmp; next[i] = idx; &#125; int ans = 0, idx = 0; for (int i = 0; i &lt; rows; ++i) &#123; ans += cnt[idx]; idx = next[idx]; &#125; return ans; &#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"手写字符识别","slug":"数据结构与算法/手写字符识别","date":"2020-12-19T13:26:51.000Z","updated":"2021-09-10T08:53:11.510Z","comments":true,"path":"2020/12/19/数据结构与算法/手写字符识别/","link":"","permalink":"http://abeltian.top/2020/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/","excerpt":"","text":"计算机视觉(computer Vision)1.全连接与CNN模型比较​ 好久没弄过深度学习的东西了，上次写得时候应该是大三上学期，一转眼就是两年了。感觉自己的记忆力好差啊，之前搞得那些已经是忘得一干二净了。这次的任务是采用Omniglot数据集进行手写数字的识别，该数据及包含了50中字母系统中共计1623种字符，每个字符有20个样本，部分样本如下图所示。 ​ 我采用的深度学习框架是pytorch，当用户使用DataLoader加载自定义数据时，需要继承Dataset这个类，并重写其中的两个方法。传入参数为图片路径与标签的字典。采用DataLoader()加载数据，batch_size大小设置为64。 1234def __getitem__(self, index): raise NotImplementedErrordef __len__(self): raise NotImplementedError 定义包含一个隐层的全连接模型, 训练50个epoch，训练集上的loss与测试集上的accuracy如下图所示，全连接模型测试集的准群率在40%左右。 12345model = nn.Sequential( nn.Linear(784, 2048), nn.ReLU(), nn.Linear(2048, 50),) 定义包含四个卷积层与两个全连接层的CNN网络， 训练50次，测试集上的最高准确率为0.8389，相比于全连接模型，准确率大大提升。 12345678def forward(self, x): x = self.conv1(x) x = self.conv2(x) x = self.conv3(x) x = self.conv4(x) x = x.view(x.size(0), -1) # (batch_size, size) output = self.out(x) return output 2.尝试与对比2.1数据集的划分​ 将类别设置为20类，每个类别训练集为15个样本，测试集为3个样本，结果如下图所示，分类准确率相比于50类明显提升，最高为0.9314。适当的减少分类类别可以提升模型的分类准确率。 2.2改变模型结构相比于示例给出的卷积网络，再加入一卷积层，结果如下，分类准确率变化不大。 2.3 不同的优化器比较上述训练都是采用的SGD优化器，改为Adagrad优化器的结果如下，loss相比于SGD优化器，没有较大的波动。准确率相比于SGD也有较大的提升，最高为0.8647。 采用Adam优化器结果如下所示，其收敛速度慢于Adagrad优化器，训练500个epoch结果如下。测试集上的分类准确率为0.8777","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"进程","slug":"数据结构与算法/进程","date":"2020-12-18T08:13:22.000Z","updated":"2021-09-10T08:53:11.515Z","comments":true,"path":"2020/12/18/数据结构与算法/进程/","link":"","permalink":"http://abeltian.top/2020/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"进程1.进程的概念程序(program)是一个存储在磁盘上某个目录中的可执行文件，内核使用exec函数将程序读入内存，并执行程序。 程序执行的实例被称为进程(process), unix系统确保每个进程都有一个唯一的数字标识符，称为进程ID 2.进程环境进程命令行参数，当执行一个程序时，在调用main函数前先调用一个特殊的启动例程，启动例程从内核获得命令行参数和环境变量值，之后调用main函数。POSIX.1要求argv[argc]是一个空指针，因此在参数处理的循环中可以改写为 1for (i = 0; argv[i] != NULL; ++i) 环境表: 环境表是一个字符指针数组，其中每个指针为一个以’\\0’为结尾的C字符串地址，全局变量environ环境指针为该指针数组的地址。 1extern char **environ;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"}]},{"title":"快速选择算法","slug":"数据结构与算法/快速选择算法","date":"2020-12-18T03:32:15.000Z","updated":"2021-09-10T08:53:11.509Z","comments":true,"path":"2020/12/18/数据结构与算法/快速选择算法/","link":"","permalink":"http://abeltian.top/2020/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/","excerpt":"","text":"快速选择算法题目描述：在未排序的数组中找到第 k 个最大的元素。 12输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5 ​ 快速选择算法本质上是对快速排序算法进行优化，快速排序算法是将数组进行划分，从数组中任选一个元素，调整数组使得左边元素都比它小，其4右侧元素都比它大。通过递归调用快速排序对左侧序列与右侧序列进行排序。而快速选择算法对左侧区间和右侧区间的数据个数与需要寻找的第K大的数字进行比较，选择答案所存在的区间，舍弃了另一个不需要的区间，使算法复杂度降低到$ O(n+ n/2 + n/4 +…)$期望为$O(n)$，但是在最坏的情况下每次选择的都是最大或者最小值，算法时间复杂度为$O(n^2)$。 针对题目数据，未加入随机数时间为56ms，加入随机数为16ms 1234567891011121314151617181920212223242526class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); return quick_select(nums, 0, n - 1, n - k + 1); &#125; int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; int randPos = l + rand() % (r - l + 1); swap(nums[l], nums[randPos]); int pivot = nums[l]; int i = l, j = r; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) --j; if (i &lt; j) nums[i] = nums[j]; while (i &lt; j &amp;&amp; nums[i] &lt; pivot) ++i; if (i &lt; j) nums[j] = nums[i]; &#125; nums[i] = pivot; int idx = i - l + 1; if (idx == k) return pivot; else &#123; return idx &lt; k ? quick_select(nums, i + 1, r, k - idx) : quick_select(nums, l, i - 1, k); &#125; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"最小的k个数","slug":"数据结构与算法/最小的k个数","date":"2020-12-17T15:00:13.000Z","updated":"2021-09-10T08:53:11.510Z","comments":true,"path":"2020/12/17/数据结构与算法/最小的k个数/","link":"","permalink":"http://abeltian.top/2020/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","excerpt":"","text":"leetcode 373 查找和最小的K对数字 题目描述：给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。 做题思路由于题目中没有给定数据范围，开始以为是双指针问题，采用贪心策略，但是举了两个例子，指针的移动无法采用贪心的方法，如[1, 3, 100]与[2, 10, 11]， 第二组为(2, 3)，第三组为(1, 10)，第一个数组的指针出现了回退，因此贪心不可行。 1.暴力做法​ 枚举数组1与数组2所有可能的组合，并采用箭指offer 40 最小的k个数的最大堆的方法，维护最小的k对数字，时间复杂度$O(n^2logk)$，运行时间1232ms，勉强过了。 2.利用数组的排序信息​ 在暴力做法中完全没有利用到题目中给出的数组为升序排列这个信息，还是以[1, 3, 100]与[2, 10, 11]为例，开始我们将$(nums1[0], nums2[j]) j = 1,2\\dots n$放入最小堆中，如果当前堆中弹出的为$(nums1[i], nums2[j])$，那么则将$(nums1[i + 1], nums2[j])$放入到最小堆中。 数据结构pair&lt;pair&lt;int, int&gt;, int&gt;，分别记录nums1的值、下标， nums2的值。 最小堆 priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; 12345678910111213141516171819202122232425262728struct cmp &#123; bool operator ()(const pair&lt;pair&lt;int, int&gt;, int&gt;&amp;a, const pair&lt;pair&lt;int, int&gt;, int&gt;&amp; b) const &#123; return a.first.first + a.second &gt; b.first.first + b.second; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int m = nums1.size(), n = nums2.size(); if (m == 0 || n == 0) return &#123;&#125;; priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; pq; for (int i = 0; i &lt; n; ++i) &#123; pq.push(&#123;&#123;nums1[0], 0&#125;, nums2[i]&#125;); &#125; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; ans; while (!pq.empty() &amp;&amp; cnt &lt; k) &#123; auto [a, b] = pq.top(); pq.pop(); ans.push_back(&#123;a.first, b&#125;); int idx = a.second; if (idx + 1 &lt; m) pq.push(&#123;&#123;nums1[idx + 1], idx + 1&#125;, b&#125;); ++cnt; &#125; return ans; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"最长递增子序列","slug":"数据结构与算法/最长递增子序列","date":"2020-12-16T14:48:07.000Z","updated":"2021-09-10T08:53:11.511Z","comments":true,"path":"2020/12/16/数据结构与算法/最长递增子序列/","link":"","permalink":"http://abeltian.top/2020/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列leetcode 300 最长递增子序列 leetcode 673 最长递增子序列的个数 对于673题，常规做法动态规划，记录两个状态 最长上升子序列的长度与当前长度对应的子序列的个数。动态规划的规划过程$$arr[j] &gt; arr[i] \\if; dp[j] &lt; dp[i] + 1 \\quad dp[j] = dp[i] + 1, nums[j] = nums[i] \\else ;if ; dp[j] == dp[i] + 1 \\quad nums[j] += nums[i]$$动态规划规划的复杂度为$O(n^2)$ 采用树状数组$O(nlogn)$的复杂度，定义Node结构体，记录长度与个数，重载加法操作符。 维护小于等于当前值区间的最长长度的上升子序列个数。 12345678910111213struct Node &#123; int m, c; Node (int _m, int _c) : m(_m), c(_c) &#123;&#125; Node&amp; operator +=(Node &amp;rhs) &#123; if (m &lt; rhs.m) &#123; m = rhs.m; c = rhs.c; &#125; else if (m == rhs.m) &#123; c += rhs.c; &#125; return *this; &#125;&#125;; 1234567891011121314151617181920212223242526class Solution &#123;public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; arr = nums; sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); unordered_map&lt;int, int&gt; mp; for (int i = 0; i &lt; arr.size(); ++i) &#123; mp[arr[i]] = i + 1; &#125; vector&lt;Node&gt; tree(2010, &#123;0, 0&#125;); Node res(0, 0); for (int val : nums) &#123; Node tmp(0, 1); for (int k = mp[val] - 1; k &gt; 0; k -= (k &amp; -k)) &#123; tmp += tree[k]; &#125; tmp.m++; res += tmp; for (int k = mp[val]; k &lt; 2010; k += (k &amp; -k)) &#123; tree[k] += tmp; &#125; &#125; return res.c; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"}]},{"title":"DTMF信号检测与识别","slug":"数据结构与算法/DTMF信号检测与识别","date":"2020-12-15T14:17:52.000Z","updated":"2021-09-10T08:53:11.501Z","comments":true,"path":"2020/12/15/数据结构与算法/DTMF信号检测与识别/","link":"","permalink":"http://abeltian.top/2020/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DTMF%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB/","excerpt":"","text":"DTMF信号的检测与识别1. 程序设计思路与框图1.1 FFT直接计算利用FFT计算输入的信号的DFT频域信息，并找到两个峰值频率点，从而检测DTMF信号。 数据预处理，作业给定的为.wav文件，其中数据为16bit的short类型，文件指针偏移40个字节的位置记录了wav数据块的字节数，调用read函数将之后的数据读入到数组中。 编写类FFTMethod，调用第一次作业编写的时域基2DFT对音频信号做FFT变换。找到频域中两个峰值对应的数字角频率，从而计算得到模拟角频率，找到对应的DTMF信号 程序框图 1.2 Goertzel 算法计算FFT包含了信号整个频域的信息，而我们只关注DTMF信号的八个特定频率，因此算法存在冗余。在FFT中如果我们只关注某一个特定的数字角频率，$X[k] = \\sum_{n = 0}^{N- 1}x[m]W_n^{m -N}$，其可以视为$x[n]$通过冲激响应为$W_N^{-nk}$的LTI系统在N时刻的取值。第k个频点对应的差分方程为：$$V_k[n] = 2cos(\\omega_k)V_k[n - 1] - V_k[n-2] + x[n] \\X_k[n] = V_k[n] - W_N^k[n - 1], v[-1] = v[-2] = 0$$其本质是一个动态规划的过程，由递推关系可以得到n时刻的状态，从而确定该频点的FFT。得到八个特定频点的FFT值后，选择两个峰值，从而确定DTMF信号。 1.3一串DTMF信号的识别下图为一串DTMF信号的时域图像，可以看到其中包含了15个DTMF信号，我们要做的工作是确定每一个信号的起始于结束位置，直接使用强度值进行判断存在较大的误差，因此选择滑动窗取平均的方式。程序中选择滑动窗大小为64，计算信号每个点对应的滑动窗内的平均能量，并与阈值作比较，从而确定每一个信号的起始结束位置。之后将每一段信号采用上述的两种方法进行信号判断 程序框图 2.两种算法的结果与复杂度比较实验结果： 复杂度分析： FFT方法采用DFT计算了所有的频点信息，时间复杂度为$O(nlogn)$，寻找峰值的复杂度为O(n)，总的时间复杂度为$O(nlogn) + O(n)$ Goertzel方法只计算特定的8个频点，并采用差分方程的形式递推计算，时间复杂度为O(n) FFT方法需要存储所有的频域信息，空间复杂度为$O(n)$， Goertzel方法在递推过程中只需要V[i-1]、V[i-2]这两个状态， 空间复杂度为$O(1)$","categories":[{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"unix shell简单实现","slug":"数据结构与算法/a simple shell","date":"2020-12-14T12:21:10.000Z","updated":"2021-09-10T08:53:11.502Z","comments":true,"path":"2020/12/14/数据结构与算法/a simple shell/","link":"","permalink":"http://abeltian.top/2020/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/a%20simple%20shell/","excerpt":"","text":"1.shell整体框架github项目地址 shell程序整体框架，读取用户输入命令并执行 进入main函数后，循环执行从标准输入读取命令，解析命令，将命令字符串以空格分隔，解析为命令与参数。判断是否为内建命令(history, jobs, fb, exit)。如果不是则父进程通过fork()创建子进程，子进程执行execv()完成进程代码段与数据段内容替换。 2.输入输出重定向定义命令结构体，其包含argc(命令参数个数)、bg(后台命令标志)、name(命令名称)、argv(命令参数)、fds(重定向文件描述符)等五个成员变量。 1234567struct command &#123; int argc; int bg; string name; string argv[ARG_MAX]; int fds[2];&#125;; 解析指令时command &gt; file检查是否有&gt;或&lt;操作符，有则检查后面是否有文件，若果有文件则以读写的方式打开文件，并将返回文件描述符记录到命令结构体中，在fork()后的子进程中，采用dup2()函数将子进程的输入、输出重定向fds所指向的文件描述符。 3.实现管道123456struct commands &#123; string key; int cmd_counts; struct command* cmds[CMD_MAX]; commands *pre, *next;&#125; 定义命令集(commands)结构体，成员cmd_counts为命令个数，cmds记录每一个解析后的命令指针。 检查输入的字符中是否有”|”，如果有按照|将字符串分隔开，并解析每一个命令(支持多条命令) 创建管道，前一个命令的stdout重定向到管道的写端，后一个命令的stdin重定向的管道的读端。 Fork()创建每一个子进程，执行指令 4.作业控制123456struct job_t &#123; pid_t pid; int jid; int state; string cmd;&#125;; 定义job_t结构体，包含成员进程编号，作业编号，作业状态，命令字符串。定义作业运行状态：UNDEF:0、FG:1、BG:2、 ST:3 定义JOBCtrl类，来控制作业的执行。 父进程fork()创建子进程后，父进程将作业添加到作业列表，并定义SIG_CHLD信号处理函数，当子进程结束执行时，发送SIG_CH LD信号给父进程。父进程捕捉信号，在信号处理函数中调用waitpid()函数获得子进程pid，将其从作业列表中删除。 5.后台执行程序 如果是前台执行程序，则父进程处于while循环的等待状态，直到子进程执行完毕向父进程发送SIG_CHLG信号，父进程捕捉到信号后将其从作业列表中删除后，结束while循环等待。如果是后台执行程序则打印作业相关信息并继续执行读取用户输入。 6.作业控制 jobs fg bg jobs查看所有作业的运行状态， 将作业列表中的所有作业打印输出 fg % 1，从作业列表中找到后台运行的作业，将其状态变为FG，并执行等待，直到子进程结束发出SIG_CHLD信号，从作业列表中删除。 bg % 1，父进程注册SIGTSTP信号处理，CRTL+Z, 发送STGTSTP信号给子进程，暂停子进程执行。当执行bg命令时，父进程向暂停的子进程发送SIGCONT信号恢复子进程的执行。 7.历史命令 实现了CMDCache类 哈希表+双向链表维护历史命令，哈希表记录输入字符串与解析后的命令结构体的映射，双向链表记录历史输入命令 LRU(least Recently used)算法，当输入字符串已经被解析过时，将命令从双向链表中删除，并重新命令列表头部插入。输入字符串未解析过，解析后插入列表头部。 history命令 将历史命令按输入顺序的倒序排列输出 up、down命令获取上一条输入命令、下一条命令输入","categories":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"}]},{"title":"pipe","slug":"数据结构与算法/pipe","date":"2020-12-12T06:36:56.000Z","updated":"2021-09-10T08:53:11.504Z","comments":true,"path":"2020/12/12/数据结构与算法/pipe/","link":"","permalink":"http://abeltian.top/2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/pipe/","excerpt":"","text":"1.管道的概念管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递，通过pipe()系统调用即可创建一个管道。 其本质是一个伪文件，实为内核缓冲区 两个文件描述符引用，一个表示读端，一个表示写端 管道采用半双工通信方式，数据只能在一个方向流动 只能在有公共祖先的进程间使用管道 2.pipe函数123int pipe(int (*pipefd)[2]); ret 0 : SUCCESS -1 : Failure 函数调用成功返回read/write两个文件描述符，无需open，需要手动close。 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端 父进程调用fork()创建子进程，子进程继承父进程文件描述符。 父进程关闭管道读端，子进程关闭管道写端，父进程可以向管道中写入数据，子进程将管道中数据读出。 3.管道读写行为 使用管道需要注意以下4种特殊情况 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 4.示例程序 采用管道实现 ls /home | wc主线程调用fork()创建两个进程一个执行ls /home，另一个执行 wc，利用管道重定向两个进程的stdout，stdin。 踩坑记录，在主线程wait(NULL)前，需要手动关闭主线程的所有管道，否则第二个进程会处于读阻塞的状态，因此发生了死锁 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;ctype.h&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int f[2]; pipe(f); for (int i = 0; i &lt; 2; ++i) &#123; pid_t pid = fork(); if (pid == 0) &#123; if (i == 1) &#123; close(f[1]); dup2(f[0], 0); char *name = &quot;/usr/bin/wc&quot;; char **argv = new char*[1]; argv[0] = &quot;/usr/bin/wc&quot;; int exet_st = execv(name, argv); close(f[0]); _exit(EXIT_SUCCESS); &#125; else &#123; close(f[0]); char buff[] = &quot;test&quot;; write(f[1], buff, strlen(buff)); close(f[1]); _exit(EXIT_SUCCESS); &#125; &#125; &#125; close(f[0]); close(f[1]); for (int i = 0; i &lt; 2; ++i) &#123; wait(NULL); &#125; return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"}]},{"title":"区间和","slug":"数据结构与算法/区间和","date":"2020-12-10T07:17:40.000Z","updated":"2021-09-10T08:53:11.508Z","comments":true,"path":"2020/12/10/数据结构与算法/区间和/","link":"","permalink":"http://abeltian.top/2020/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%92%8C/","excerpt":"","text":"leetcode 1477 找两个和为目标值且不重叠的子数组 leetcode 1658 将x减小到0的最小次数 leetcode 1423 可获得的最大点数 题目中给出的数据范围$1\\le arr[i]\\le10^4$，因此找到一段区间和为某一个数值，可以采用双指针的方式，如果当前区域的和大于target，则移动前面的指针，直到区间和小于等于target。如果存在负数或零，则采用前缀和与哈希表的方式。 对于题目1477 其要找到满足等于给定和的最小的两个不想交的区间，采用dp[j]表示区间右端点小于等于j的最小区间长度。$$dp[j] = \\min(dp[j - 1], j - i + 1) \\ans = \\min(ans, dp[i - 1] + j - i + 1)$$ 1234567891011121314151617181920212223class Solution &#123;public: int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) &#123; int n = arr.size(); int i = 0, sum = 0, ans = 0x3f3f3f3f; vector&lt;int&gt; dp(n, 0x3f3f3f3f); for (int j = 0; j &lt; n; ++j) &#123; sum += arr[j]; while (sum &gt; target &amp;&amp; i &lt; j) &#123; sum -= arr[i]; ++i; &#125; if (j &gt; 0) dp[j] = dp[j - 1]; if (sum == target) &#123; dp[j] = min(dp[j], j - i + 1); if (i &gt; 0) &#123; ans = min(ans, dp[i - 1] + j - i + 1); &#125; &#125; &#125; return ans == 0x3f3f3f3f ? -1 : ans; &#125;&#125;; 对于1658题，首先找到一段区间和为x，然后调整两个指针的位置使得两端区间和为x 123456789101112131415161718192021222324class Solution &#123;public: int minOperations(vector&lt;int&gt;&amp; nums, int x) &#123; int n = nums.size(), ans = 0x3f3f3f3f; int j = n - 1, sum = 0; while (j &gt;= 0 &amp;&amp; sum &lt; x) &#123; sum += nums[j]; --j; &#125; ++j; if (sum == x) ans = n - j; for (int i = 0; i &lt; n; ++i) &#123; sum += nums[i]; while (j &lt; n &amp;&amp; sum &gt; x) &#123; sum -= nums[j]; ++j; &#125; if (sum == x &amp;&amp; j &gt; i) &#123; ans = min(ans, i + 1 + n - j); &#125; &#125; return ans == 0x3f3f3f3f ? -1 : ans; &#125;&#125;;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"区间和","slug":"区间和","permalink":"http://abeltian.top/tags/%E5%8C%BA%E9%97%B4%E5%92%8C/"}]},{"title":"线段树","slug":"数据结构与算法/线段树","date":"2020-12-09T11:55:27.000Z","updated":"2021-09-10T08:53:11.514Z","comments":true,"path":"2020/12/09/数据结构与算法/线段树/","link":"","permalink":"http://abeltian.top/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"每个叶子节点为最小的分割区间，即为数组存储的值。 假设树的高度为k，0,1,2$\\dots$k，另n为区间个数，则有$2^{k - 1} &lt; n \\le 2^k$，整棵树的节点个数有$2^{k + 1} - 1$个，通常线段树空间大小为4 * n leetcode 1109 航班预订统计 leetcode 307 区间和检索-数组可修改 leetcode 308 二维区域和检索—可变 线段树建树数组下标同树状数组相同，都是从1开始 12345678910void build(int l, int r, int p) &#123; if(l == r) &#123; d[p] = a[l]; return; &#125; int mid = l + (r - l) / 2; build(l, m, p &lt;&lt; 1); build(m + 1, r, p &lt;&lt; 1 | 1); d[p] = d[p &lt;&lt; 1] + d[p &lt;&lt; 1 | 1];&#125; 线段树区间查询l，r为查询区间，cl，cr为当前区间的左右边界。 123456789int query(int l, int r, int p, int cl, int cr) &#123; if(cl &gt; r || cr &lt; l) return 0; else if(l &lt;= cl &amp;&amp; r &gt;= cr) return d[p]; else &#123; int mid = l + (r - l) / 2, sum = 0; if(l &lt;= mid) sum += query(l, r, p &lt;&lt; 1, cl, mid); if(r &gt; mid) sum += quert(l, r, p &lt;&lt; 1 | 1s, mid + 1, cr); &#125;&#125; 线段树的点更新$O(nlogn)$123456789101112void update(int k, int v, int l, int r, int p) &#123; //update(k, v, 1, n, 1) if(l == r) a[k] += v, d[k] += v; else &#123; int mid = l + (r - l) / 2; if(k &lt;= mid) &#123; update(k, v, l, mid, p &lt;&lt; 1); &#125; else &#123; update(k, v, mid + 1, r, p &lt;&lt; 1 | 1); &#125; d[p] = d[p &lt;&lt; 1] + d[p &lt;&lt; 1 | 1]; &#125;&#125; 线段树区间修改与懒惰标记对于一个区间$[l, r]$，如果每次更新区间中的每个值，那么时间复杂度为$O(nlogn)$，为了提高更新效率，采用了mark进行标记。在递归更新过程中，当当前节点区间为待更新区间的真子集时，不再向下更新。 123456789101112131415161718192021void push_down(int p, int len) &#123; mark[p &lt;&lt; 1] += mark[p]; mark[p &lt;&lt; 1 | 1] += mark[p]; d[p &lt;&lt; 1] += mark[p] * (len - len / 2); d[p &lt;&lt; 1 | 1] += mark[p] * len / 2; mark[p] = 0;&#125;void update(int l, int r, int val, int cl, int cr, int p) &#123; if(l &gt; cr || r &lt; cl) return; else if(l &lt;= cl &amp;&amp; r &gt;= cr) &#123; d[p] += (cr - cl + 1) * val; if(cl &gt; cr) mark[p] += d; &#125; else &#123; int mid = cl + (cr - cl) / 2; push_down(p, cr - cl + 1); update(l, r, val, cl, mid, p &lt;&lt; 1); update(l, r, val, mid + 1, cr, p &lt;&lt; 1 | 1); d[p] = d[p &lt;&lt; 1] + d[p &lt;&lt; 1 | 1]; &#125;&#125; 线段树区间查询 包含懒惰标记123456789int query(int l, int r, int cl, int cr, int p) &#123; if(l &gt; cr || r &lt; cl) return 0; else if(l &lt;= cl &amp;&amp; r &gt;= cr) return d[p]; else &#123; int mid = l + (r - l) / 2; if(mark[p]) push_down(p, cr - cl + 1); return query(l, r, cl, mid, p &lt;&lt; 1) + query(l, r, mid + 1, cr, p &lt;&lt; 1 | 1); &#125;&#125;","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://abeltian.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]}],"categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/categories/JAVA/"},{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/categories/Alogrithm/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/categories/Data-Structure/"},{"name":"凸优化","slug":"凸优化","permalink":"http://abeltian.top/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/categories/Linux/"},{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://abeltian.top/tags/Data-Structure/"},{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://abeltian.top/tags/Alogrithm/"},{"name":"JAVA","slug":"JAVA","permalink":"http://abeltian.top/tags/JAVA/"},{"name":"JAVA Spring","slug":"JAVA-Spring","permalink":"http://abeltian.top/tags/JAVA-Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://abeltian.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Data Stucture","slug":"Data-Stucture","permalink":"http://abeltian.top/tags/Data-Stucture/"},{"name":"数据库","slug":"数据库","permalink":"http://abeltian.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"并查集","slug":"并查集","permalink":"http://abeltian.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"动态规划","slug":"动态规划","permalink":"http://abeltian.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"深度学习","slug":"深度学习","permalink":"http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"http://abeltian.top/tags/Linux/"},{"name":"信号处理","slug":"信号处理","permalink":"http://abeltian.top/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"区间和","slug":"区间和","permalink":"http://abeltian.top/tags/%E5%8C%BA%E9%97%B4%E5%92%8C/"},{"name":"线段树","slug":"线段树","permalink":"http://abeltian.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]}