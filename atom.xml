<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TYS的博客</title>
  
  <subtitle>算法小白努力学习中</subtitle>
  <link href="http://abeltian.top/atom.xml" rel="self"/>
  
  <link href="http://abeltian.top/"/>
  <updated>2022-01-03T09:56:31.644Z</updated>
  <id>http://abeltian.top/</id>
  
  <author>
    <name>tys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://abeltian.top/2022/01/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E4%BC%9A%E8%AE%AE/"/>
    <id>http://abeltian.top/2022/01/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E4%BC%9A%E8%AE%AE/</id>
    <published>2022-01-03T09:55:03.295Z</published>
    <updated>2022-01-03T09:56:31.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="医学图像处理的会议"><a href="#医学图像处理的会议" class="headerlink" title="医学图像处理的会议"></a>医学图像处理的会议</h1><p><a href="https://2022.midl.io/call-for-papers.html">https://2022.midl.io/call-for-papers.html</a></p><p>Medical Imaging with Deep Learning</p><p>MIDL 长论文 提交deadline 12月 短论文三页 4月22号。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;医学图像处理的会议&quot;&gt;&lt;a href=&quot;#医学图像处理的会议&quot; class=&quot;headerlink&quot; title=&quot;医学图像处理的会议&quot;&gt;&lt;/a&gt;医学图像处理的会议&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://2022.midl.io/call-for-pap</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作安排</title>
    <link href="http://abeltian.top/2022/01/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%921/"/>
    <id>http://abeltian.top/2022/01/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%921/</id>
    <published>2022-01-01T02:29:10.000Z</published>
    <updated>2022-01-19T04:31:59.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h1><p>2021.12.23-12.25</p><p>重叠与密集细胞区域的检测文献调研。</p><p>调研了两篇密集区域目标检测的文章</p><p>PS-RCNN 两个阶段来分别检测未遮挡与严重遮挡的目标</p><p>迭代检测的方法，将历史的特征图卷积后作为第二次的输入</p><p>查看一下目前faster-rcnn的所有密集、重叠区域检测结果的情况，挑选出了一些检测结果差的样本。</p><p>2021.12.25~2021.12.31</p><p>密集、重叠细胞区域存在的检测难点，严重遮挡的细胞智能提供较少的视觉信息，检测得到的置信度低，容易被NMS最大值抑制去除。其中一种解决方案是Soft-NMS，Soft-NMS按照检测框之间的重合程度(IOU)进行置信度衰减，但是衰减的形式为人工设计，具有较大的局限性，且置信度降低的检测框后续也可能因不满足置信度阈值的要求而被去除。</p><p>针对密集、重叠细胞区域存在的检测失效的问题，拟采用迭代检测的方法来检测两组具有不同遮挡的细胞实例。第一轮检测没有遮挡或者轻微遮挡的细胞，在实例分割分支会得到的已检测到细胞的mask，之后采用该mask去覆盖原特征图的相应位置得到masked feature。在第二轮检测中使用masked feature去检测被遗漏的遮挡较严重的细胞。通过这样的迭代检测方式去提升网络对被遮挡细胞的检测能力。</p><p><img src="C:\Users\sty\AppData\Roaming\Typora\typora-user-images\image-20211231210503997.png" alt="image-20211231210503997"></p><p>在该迭代检测的方法中，需要细胞边界的mask信息，因此需要使用语义分割进行细胞的位置标注。</p><p>先完成结果写入到labelme的json的形式，完成结果的迭代，目前完成细胞质标注约500余张，版本一迭代完成，形成了闭环，下图为mask-rcnn推断的结果，红色为细胞，绿色为细胞核。</p><p><img src="C:\Users\sty\AppData\Roaming\Typora\typora-user-images\image-20211231213015456.png" alt="image-20211231213015456"></p><p>跑一下带有mask的检测网络如mask-rcnn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;train.py  configs&#x2F;mask_rcnn&#x2F;mask_rcnn_r50_fpn_2x_coco.py --work-dir .&#x2F;work_dir&#x2F;mask_rcnn_new&#x2F;</span><br></pre></td></tr></table></figure><p>12.29检测结果出现了问题</p><ol><li>只检测细胞边检</li><li>只检测细胞核边界</li><li>同时检测，目前存在失效的问题 不知道为什么 考虑结合语义分割网络，目前已找到问题未修改dataset coco数据集合与网络输出的分类类别，在结果写入json中出现了seg重复定义的bug。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作内容&quot;&gt;&lt;a href=&quot;#工作内容&quot; class=&quot;headerlink&quot; title=&quot;工作内容&quot;&gt;&lt;/a&gt;工作内容&lt;/h1&gt;&lt;p&gt;2021.12.23-12.25&lt;/p&gt;
&lt;p&gt;重叠与密集细胞区域的检测文献调研。&lt;/p&gt;
&lt;p&gt;调研了两篇密集区域目标检测</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://abeltian.top/2021/12/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection_seg/"/>
    <id>http://abeltian.top/2021/12/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection_seg/</id>
    <published>2021-12-31T03:27:38.047Z</published>
    <updated>2021-12-31T12:32:50.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mmdetection"><a href="#mmdetection" class="headerlink" title="mmdetection"></a>mmdetection</h2><p>遇到的问题 </p><ol><li><p>只检测细胞边检</p></li><li><p>只检测细胞核边界</p></li><li><p>同时检测，目前存在失效的问题 不知道为什么 考虑结合语义分割网络</p></li></ol><p>   目前怀疑的问题是dataset的类别没有进行改动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mmdetection&quot;&gt;&lt;a href=&quot;#mmdetection&quot; class=&quot;headerlink&quot; title=&quot;mmdetection&quot;&gt;&lt;/a&gt;mmdetection&lt;/h2&gt;&lt;p&gt;遇到的问题 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;只检测细胞边检&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据集准备</title>
    <link href="http://abeltian.top/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%88%B6%E4%BD%9C%E5%8C%85%E5%90%ABmask%E7%9A%84coco%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://abeltian.top/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%88%B6%E4%BD%9C%E5%8C%85%E5%90%ABmask%E7%9A%84coco%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2021-12-29T02:29:10.000Z</published>
    <updated>2022-01-19T04:33:14.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="制作包含mask的coco数据集"><a href="#制作包含mask的coco数据集" class="headerlink" title="制作包含mask的coco数据集"></a>制作包含mask的coco数据集</h1><h1 id="1-coco数据集格式"><a href="#1-coco数据集格式" class="headerlink" title="1. coco数据集格式"></a>1. coco数据集格式</h1><p>coco数据集的官网<a href="https://cocodataset.org/">https://cocodataset.org/</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;annotations&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: int,</span><br><span class="line">    <span class="attr">&quot;image_id&quot;</span>: int,</span><br><span class="line">    <span class="attr">&quot;category_id&quot;</span>: int,</span><br><span class="line">    <span class="attr">&quot;segmentation&quot;</span>: RLE or [polygon],</span><br><span class="line">    <span class="attr">&quot;area&quot;</span>: float,</span><br><span class="line">    <span class="attr">&quot;bbox&quot;</span>: [x,y,width,height],</span><br><span class="line">    <span class="attr">&quot;iscrowd&quot;</span>: <span class="number">0</span> or <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>标注的信息</p><p>cocoapi提供了将polygon转为rle格式的代码 annToRLE</p><p>labelme中通过group来判断边界框与mask的归属性。</p><h1 id="2-训练Mask-RCNN"><a href="#2-训练Mask-RCNN" class="headerlink" title="2. 训练Mask-RCNN"></a>2. 训练Mask-RCNN</h1><p>pycococreator</p><p>跑通了mask-rcnn跑出的分割结果是与图片大小相同的mask</p><h1 id="3-mmdet中对COCO类的包装"><a href="#3-mmdet中对COCO类的包装" class="headerlink" title="3. mmdet中对COCO类的包装"></a>3. mmdet中对COCO类的包装</h1><p>coco中imgToAnns记录了某一个img_id对应所有的ann_id</p><p>_parse_ann_info包含了一张图片的所有的bbox与segm信息</p><p>result2json将检测与分割的结果写为coco的json格式。</p><p>model.show_result展示检测结果</p><h1 id="4-标注的标准"><a href="#4-标注的标准" class="headerlink" title="4. 标注的标准"></a>4. 标注的标准</h1><p>对于处于边界的细胞，完整程度要大于5/6</p><p>对于细胞质非常小，几乎不可见的细胞种类，不标注细胞核，直接标注为细胞cell</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://patrickwasp.com/create-your-own-coco-style-dataset/">https://patrickwasp.com/create-your-own-coco-style-dataset/</a></p><p><a href="https://github.com/waspinator/pycococreator/">https://github.com/waspinator/pycococreator/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;制作包含mask的coco数据集&quot;&gt;&lt;a href=&quot;#制作包含mask的coco数据集&quot; class=&quot;headerlink&quot; title=&quot;制作包含mask的coco数据集&quot;&gt;&lt;/a&gt;制作包含mask的coco数据集&lt;/h1&gt;&lt;h1 id=&quot;1-coco数据集</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>mmdetection网络训练</title>
    <link href="http://abeltian.top/2021/12/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection%E8%AE%AD%E7%BB%83/"/>
    <id>http://abeltian.top/2021/12/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection%E8%AE%AD%E7%BB%83/</id>
    <published>2021-12-20T02:29:10.000Z</published>
    <updated>2022-01-19T04:28:19.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mmdetection训练"><a href="#mmdetection训练" class="headerlink" title="mmdetection训练"></a>mmdetection训练</h2><p>如何制作数据集<a href="https://github.com/spytensor/prepare_detection_dataset">https://github.com/spytensor/prepare_detection_dataset</a></p><p>将labelme格式的数据转化为coco格式数据，需要对文件进行改写。</p><p>// 修改类别，修改image字段 修改area</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotation[<span class="string">&#x27;area&#x27;</span>] = annotation[<span class="string">&#x27;bbox&#x27;</span>][<span class="number">2</span>]  *  annotation[<span class="string">&#x27;bbox&#x27;</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>json编辑器dadroit</p><p>通过目录的软连接将数据创建到data文件夹下</p><p><a href="https://blog.csdn.net/duanyajun987/article/details/97659685">https://blog.csdn.net/duanyajun987/article/details/97659685</a></p><p>修改mmdetection/mmdet/datasets/coco.py <code>CLASSES</code></p><p>mmdetection/mmdet/core/evaluation/class_names.py 修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def coco_classes():</span><br><span class="line">    return [</span><br><span class="line">        &#39;Prim&#39;, &#39;Lym&#39;, &#39;Mono&#39;, &#39;Plas&#39;, &#39;Red&#39;,&#39;Promy&#39;,&#39;Myelo&#39;,&#39;Late&#39;,&#39;Rods&#39;,&#39;Lobu&#39;,&#39;Eosl&#39;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>修改configs/models/retinanet_r50_fpn.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_classes=<span class="number">11</span>,</span><br></pre></td></tr></table></figure><p>训练数据集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/train.py configs/retinanet/retinanet_r50_fpn_1x_coco.py  --work-dir work_dirs --resume-from work_dirs/latest.pth --gpus 2</span><br></pre></td></tr></table></figure><p>多卡训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./tools/dist_train.sh  configs/retinanet/retinanet_r50_fpn_1x_coco.py  2  --work-dir work_dirs --resume-from work_dirs/latest.pth</span><br></pre></td></tr></table></figure><p>查看显卡使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 -d nvidia-smi</span><br></pre></td></tr></table></figure><p>真正的训练文件<code>mmdet/apis/train.py</code></p><p>修改epoch <code>configs/_base_/schedules/schedules_1x.py</code>的<code>runner = dict(type=&#39;EpochBasedRunner&#39;, max_epochs=240)</code>修改epoch数量</p><p>修改batchsize<code>configs/datasets/coco_detection.py</code> samples_per_gpu参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; dict(</span><br><span class="line">    samples_per_gpu&#x3D;2,</span><br><span class="line">    workers_per_gpu&#x3D;2,</span><br><span class="line">    train&#x3D;dict(</span><br><span class="line">        type&#x3D;dataset_type,</span><br><span class="line">        ann_file&#x3D;data_root + &#39;annotations&#x2F;instances_train2017.json&#39;,</span><br><span class="line">        img_prefix&#x3D;data_root + &#39;train2017&#x2F;&#39;,</span><br><span class="line">        pipeline&#x3D;train_pipeline),</span><br><span class="line">    val&#x3D;dict(</span><br><span class="line">        type&#x3D;dataset_type,</span><br><span class="line">        ann_file&#x3D;data_root + &#39;annotations&#x2F;instances_val2017.json&#39;,</span><br><span class="line">        img_prefix&#x3D;data_root + &#39;val2017&#x2F;&#39;,</span><br><span class="line">        pipeline&#x3D;test_pipeline),</span><br><span class="line">    test&#x3D;dict(</span><br><span class="line">        type&#x3D;dataset_type,</span><br><span class="line">        ann_file&#x3D;data_root + &#39;annotations&#x2F;instances_val2017.json&#39;,</span><br><span class="line">        img_prefix&#x3D;data_root + &#39;val2017&#x2F;&#39;,</span><br><span class="line">        pipeline&#x3D;test_pipeline))</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/test.py configs/retinanet/retinanet_r50_fpn_1x_coco.py checkpoints/retinanet_r50_fpn_1x_coco_20200130-c2398f9e.pth --show</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/test.py configs/retinanet/retinanet_r50_fpn_1x_coco.py work_dirs/latest.pth --out test_result/latest.pkl --<span class="built_in">eval</span> bbox --show-<span class="built_in">dir</span> detect_results</span><br></pre></td></tr></table></figure><p>mmdetection 结果炫酷可视化</p><h5 id="TSNE"><a href="#TSNE" class="headerlink" title="TSNE"></a>TSNE</h5><p>热力图(好看的colorbar<a href="https://www.cnblogs.com/zb-ml/p/13561449.html">https://www.cnblogs.com/zb-ml/p/13561449.html</a>)</p><h3 id="docker环境"><a href="#docker环境" class="headerlink" title="docker环境"></a>docker环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name sty_cell --gpus  all   -p 10022:22 --shm-size=16g  -v /mnt/sda/sty/data:/Data  nvidia/cuda:11.2.2-cudnn8-devel-ubuntu18.04</span><br></pre></td></tr></table></figure><p>创建docker环境，安装anaconda，安装mmcv mmdet</p><h2 id="训练faster-rcnn"><a href="#训练faster-rcnn" class="headerlink" title="训练faster-rcnn"></a>训练faster-rcnn</h2><p>修改 /mmdet/datasets/coco.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSES = ( <span class="string">&#x27;Prim&#x27;</span>, <span class="string">&#x27;Lym&#x27;</span>, <span class="string">&#x27;Mono&#x27;</span>, <span class="string">&#x27;Plas&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>,<span class="string">&#x27;Promy&#x27;</span>,<span class="string">&#x27;Myelo&#x27;</span>,<span class="string">&#x27;Late&#x27;</span>,<span class="string">&#x27;Rods&#x27;</span>,<span class="string">&#x27;Lobu&#x27;</span>,<span class="string">&#x27;Eosl&#x27;</span>)</span><br></pre></td></tr></table></figure><p>修改config/_base_/models/faster_rcnn_r50_fpn.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_classes=<span class="number">11</span></span><br></pre></td></tr></table></figure><p>指定GPU训练数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES&#x3D;1 python tools&#x2F;train.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py  --work-dir work_dir&#x2F;faster_rcnn </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mmdetection训练&quot;&gt;&lt;a href=&quot;#mmdetection训练&quot; class=&quot;headerlink&quot; title=&quot;mmdetection训练&quot;&gt;&lt;/a&gt;mmdetection训练&lt;/h2&gt;&lt;p&gt;如何制作数据集&lt;a href=&quot;https://gi</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>mmdetection结果评估</title>
    <link href="http://abeltian.top/2021/12/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection%20%E7%BB%93%E6%9E%9C%E8%AF%84%E4%BB%B7%E5%87%BD%E6%95%B0/"/>
    <id>http://abeltian.top/2021/12/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmdetection%20%E7%BB%93%E6%9E%9C%E8%AF%84%E4%BB%B7%E5%87%BD%E6%95%B0/</id>
    <published>2021-12-20T02:29:10.000Z</published>
    <updated>2022-01-19T04:28:06.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mmdetection-结果评价函数"><a href="#mmdetection-结果评价函数" class="headerlink" title="mmdetection 结果评价函数"></a>mmdetection 结果评价函数</h1><p>{‘bboxes’: array([[119., 111., 244., 252.]], dtype=float32), ‘labels’: array([8]), ‘bboxes_ignore’: array([], shape=(0, 4), dtype=float32), ‘masks’: [[[119.0, 111.0, 244.0, 252.0]]], ‘seg_map’: ‘ER0437_233.png’}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;test.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py work_dir&#x2F;faster_rcnn&#x2F;epoch_80.pth --work-dir . --out .&#x2F;tmp.pkl</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;analysis_tools&#x2F;analyze_results.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py .&#x2F;tmp.pkl .&#x2F;results</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;train.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_2x_coco.py --work-dir&#x2F; .&#x2F;work_dirs&#x2F;faster_rcnn1</span><br></pre></td></tr></table></figure><p>COCO数据集标注文件有三种信息</p><ul><li><p>annotations标注的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;id&quot;: 1655,</span><br><span class="line"> &quot;image_id&quot;: 1011,</span><br><span class="line"> &quot;category_id&quot;: 1,</span><br><span class="line"> &quot;bbox&quot;: [</span><br><span class="line">  38.760299625468164,</span><br><span class="line">  84.26966292134831,</span><br><span class="line">  100.1198501872659,</span><br><span class="line">  90.47940074906366</span><br><span class="line"> ],</span><br><span class="line"> &quot;area&quot;: 9058.784048029847</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>categories标注列表</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;name&quot;: &quot;Prim&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>images列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;height&quot;: 363,</span><br><span class="line"> &quot;width&quot;: 360,</span><br><span class="line"> &quot;id&quot;: 0,</span><br><span class="line"> &quot;file_name&quot;: &quot;ER0437_233.jpg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coco_eval做了些什么？ </p><p>首先创建哈希表，_gts与_dts键位image_id与category_id，值为标注与预测bbox与类别信息。</p><h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h3><p>对结果进行分析</p><h3 id="mmdetection检测结果"><a href="#mmdetection检测结果" class="headerlink" title="mmdetection检测结果"></a>mmdetection检测结果</h3><p>单纯用Precision与Recall评价检测器并不公平，AP计算了不同Recall下的Precision，综合性地评价了检测器，PR曲线，对所有BBox给出的置信度从高到低进行排序，当把置信度取某一个值S时，依次对前n个大于置信度的BBox计算Precison与Recall得到一组(P, R)结果。在计算AP时，都要对P-R曲线做一次修正，将P值修正为当r&gt;R时最大的P</p></li></ul><p>  $$<br>  Precision = \frac{TP}{TP + FP} \<br>  Recall = \frac{TP}{TP + FN} \<br>  AP = \int_{0}^{1} \max({P(r) | r \ge R}) dR<br>  $$<br>  对于BBox是TP还是FP的算法判断，如某一个BBox预测的label为1，则需要计算其与该图片中所有label为1的GT Box的IOU值，当大于iou_thres时，则该预测box为TP，否则为FP。当某一个GT被置信度最大的BBox匹配后，会从GT Box集合中移除。</p><p>  TP + FN为测试集中该种类的样本的个数，因此不需要计算FN的个数，一个BBox与GT BOX是一一对应的，最后未检出的GT为FN</p><p>  <img src="https://pic3.zhimg.com/v2-8a3da2c2d827d784662ceff1e72474ce_r.jpg" alt="preview"></p><p>  类别平衡问题，mAP，所有类别的检测性能(AP)取平均，就是检测算法在这个IOU下的性能。</p><h5 id="位置偏差"><a href="#位置偏差" class="headerlink" title="位置偏差"></a>位置偏差</h5><p>  不同场景下对预测位置准确度的要求不同。 mmAP，设置一组iou阈值，每一个IOU</p><p>  <a href="https://zhuanlan.zhihu.com/p/60707912">https://zhuanlan.zhihu.com/p/60707912</a> 画出不同IOU下的PR曲线。</p><p>  可以计算一个mAP，对这些性能取平均，在coco数据集中，mAP的计算针对10个IOU阈值下的AP取平均值<code>np.linspace(0.5, 0.95, 10)</code>。</p><p>  <a href="https://blog.csdn.net/lppfwl/article/details/108018950">https://blog.csdn.net/lppfwl/article/details/108018950</a></p><p>  <a href="https://zhuanlan.zhihu.com/p/55575423">https://zhuanlan.zhihu.com/p/55575423</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mmdetection-结果评价函数&quot;&gt;&lt;a href=&quot;#mmdetection-结果评价函数&quot; class=&quot;headerlink&quot; title=&quot;mmdetection 结果评价函数&quot;&gt;&lt;/a&gt;mmdetection 结果评价函数&lt;/h1&gt;&lt;p&gt;{‘bbox</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://abeltian.top/2021/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/#%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/"/>
    <id>http://abeltian.top/2021/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/#%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/</id>
    <published>2021-11-29T04:11:03.074Z</published>
    <updated>2021-11-29T13:03:34.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h1><h3 id="使用AdamW余弦退火算法，参数如下的训练结果"><a href="#使用AdamW余弦退火算法，参数如下的训练结果" class="headerlink" title="使用AdamW余弦退火算法，参数如下的训练结果"></a>使用AdamW余弦退火算法，参数如下的训练结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021.11.29 今日跑完了transformer-fg 结果一般 到了80%的准确度后未提升。训练faster-rcnn 计算map各个分类下的曲线</span><br></pre></td></tr></table></figure><p>明日计划完成faster-rcnn输出的特征热力图，与各个分类的map曲线，画一下分类Token的TSNE降维后的数据。</p><p>文献调研，调研一下骨髓血细胞分类的历史文献，并做PPT。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;训练结果&quot;&gt;&lt;a href=&quot;#训练结果&quot; class=&quot;headerlink&quot; title=&quot;训练结果&quot;&gt;&lt;/a&gt;训练结果&lt;/h1&gt;&lt;h3 id=&quot;使用AdamW余弦退火算法，参数如下的训练结果&quot;&gt;&lt;a href=&quot;#使用AdamW余弦退火算法，参数如下的训练结</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ant Design UI框架</title>
    <link href="http://abeltian.top/2021/10/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Ant%20Design%20UI%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://abeltian.top/2021/10/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Ant%20Design%20UI%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-26T02:29:10.000Z</published>
    <updated>2022-01-19T04:25:38.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ant-Design-UI框架学习"><a href="#Ant-Design-UI框架学习" class="headerlink" title="Ant Design UI框架学习"></a>Ant Design UI框架学习</h3><p><a href="https://www.jianshu.com/p/700777ea9db0">https://www.jianshu.com/p/700777ea9db0</a></p><p>采用钩子函数useState，使该函数成为有状态函数组件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Ant-Design-UI框架学习&quot;&gt;&lt;a href=&quot;#Ant-Design-UI框架学习&quot; class=&quot;headerlink&quot; title=&quot;Ant Design UI框架学习&quot;&gt;&lt;/a&gt;Ant Design UI框架学习&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>pytorch tensor张量</title>
    <link href="http://abeltian.top/2021/10/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch%20Tensor/"/>
    <id>http://abeltian.top/2021/10/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch%20Tensor/</id>
    <published>2021-10-19T02:29:10.000Z</published>
    <updated>2022-01-19T04:30:05.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pytorch-Tensor"><a href="#Pytorch-Tensor" class="headerlink" title="Pytorch Tensor"></a>Pytorch Tensor</h3><p><a href="https://zhuanlan.zhihu.com/p/64551412">https://zhuanlan.zhihu.com/p/64551412</a></p><p>$\qquad$Tensor多维数组底层实现是使用一块连续内存的1维数组，Tensor在元信息里保存了多维数组的形状，在访问元素时，通过多维度索引转化成1维数组相对于数组起始位置的偏移量即可找到对应的数据。</p><p>$\qquad$某些Tensor操作（<a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/48915810/pytorch-contiguous">如transpose、permute、narrow、expand</a>）与原Tensor是共享内存中的数据，不会改变底层数组的存储，但原来在语义上相邻、内存里也相邻的元素在执行这样的操作后，在语义上相邻，但在内存不相邻，即不连续了（<em>is not contiguous</em>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window_partition</span>(<span class="params">x, window_size</span>):</span></span><br><span class="line">    B, H, W, C = x.shape</span><br><span class="line">    x = x.view(B, H // window_size, window_size, W // window_size, window_size, C)</span><br><span class="line">    windows = x.permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>).contiguous().view(-<span class="number">1</span>, window_size, window_size, C)</span><br><span class="line">    <span class="keyword">return</span> windows</span><br></pre></td></tr></table></figure><p>以上述代码为例，在permute后，只是改变了tensor的元信息，现坐标相对于一维数组的变化，上述代码permute后，每个坐标对应的stride会发生改变。stride可以理解为每个下标的权重。</p><p>数组 t 在内存中实际以一维数组形式存储，通过 <strong>flatten</strong> 方法查看 t 的一维展开形式，实际存储形式与一维展开一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Pytorch-Tensor&quot;&gt;&lt;a href=&quot;#Pytorch-Tensor&quot; class=&quot;headerlink&quot; title=&quot;Pytorch Tensor&quot;&gt;&lt;/a&gt;Pytorch Tensor&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuan</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>骨髓血细胞检测</title>
    <link href="http://abeltian.top/2021/10/14/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/%E9%AA%A8%E9%AB%93%E8%A1%80%E7%BB%86%E8%83%9E%E6%A3%80%E6%B5%8B/"/>
    <id>http://abeltian.top/2021/10/14/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/%E9%AA%A8%E9%AB%93%E8%A1%80%E7%BB%86%E8%83%9E%E6%A3%80%E6%B5%8B/</id>
    <published>2021-10-14T13:53:31.000Z</published>
    <updated>2021-10-20T11:30:55.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文献阅读"><a href="#文献阅读" class="headerlink" title="文献阅读"></a>文献阅读</h3><h5 id="Morphogo-An-Automatic-Bone-Marrow-Cell-Classification-System-on-Digital-Images-Analyzed-by-Artificial-Intelligence"><a href="#Morphogo-An-Automatic-Bone-Marrow-Cell-Classification-System-on-Digital-Images-Analyzed-by-Artificial-Intelligence" class="headerlink" title="Morphogo: An Automatic Bone Marrow Cell Classification System on Digital Images Analyzed by Artificial Intelligence"></a>Morphogo: An Automatic Bone Marrow Cell Classification System on Digital Images Analyzed by Artificial Intelligence</h5><p>骨髓血细胞检测难点</p><ul><li>正常骨髓中的细胞类别较多，包含处于不同发育阶段从早期到功能成熟的的间充质细胞、内皮细胞和造血细胞</li><li></li></ul><h5 id="Human-level-recognition-of-blast-cells-in-acute-myeloid-leukaemia-with-convolutional-neural-networks"><a href="#Human-level-recognition-of-blast-cells-in-acute-myeloid-leukaemia-with-convolutional-neural-networks" class="headerlink" title="Human-level recognition of blast cells in acute myeloid leukaemia with convolutional neural networks"></a>Human-level recognition of blast cells in acute myeloid leukaemia with convolutional neural networks</h5><ul><li>数字化过程，使用低倍镜，选择单层细胞且无重叠区域，每个细胞的形态学特征可以更好的被识别，将细胞划分与 AML 的形态学分类相关的子类别。对于每个AOI，使用100倍的油浸镜挑选并标注100个左右的白细胞。</li><li>观察者间的差异，多人对同一批数据进行标注。 观察者内部的差异与自我一致性，多个月后同一人重新标注。</li><li>采用Resnext网络，采用五折交叉验证进行训练，对于数据集采用随机划分的方式。可以按病人进行划分，避免训练与测试集的相关性，但是检测结果差别不大。</li><li>类别不均衡问题采用旋转，随机水平或者垂直反转来扩充数据集。</li><li>评价指标，准确率、敏感性、特异性。positave与negative是指是否属于某一个特定类别的数量。TP与TF为网络正确判定是否属于该类别图像的数量。</li><li>gold standard annotation 最佳标注的一种描述。通过该细胞与其他区域细胞的对比确定该细胞的类别。</li><li>描述网络检测结果 混淆矩阵，特征图</li></ul><h5 id="Hierarchical-Vision-Transformer-using-Shifted-Windows"><a href="#Hierarchical-Vision-Transformer-using-Shifted-Windows" class="headerlink" title="Hierarchical Vision Transformer using Shifted Windows"></a>Hierarchical Vision Transformer using Shifted Windows</h5><ul><li>自然语言处理与视觉任务的差别，视觉目标尺寸变化较大 ，而自然语言处理中的word token大小固定。对于高分图像，self-attention计算复杂度是图像的大小的平方时间复杂度。</li><li>shift of the window</li><li>VIT缺点 在密集的视觉任务或高分辨图像中，不适合作为通用的backbone</li><li><a href="https://zhuanlan.zhihu.com/p/411311520">https://zhuanlan.zhihu.com/p/411311520</a></li></ul><h5 id="Squeeze-and-Excitation-Networks"><a href="#Squeeze-and-Excitation-Networks" class="headerlink" title="Squeeze-and-Excitation Networks"></a>Squeeze-and-Excitation Networks</h5><ul><li><p>convolutional filters are expected to be informative combinations by fusing spatial and channel-wise information together within local receptive fields.</p></li><li><p>自适应的调整通道间的相应，通过对通道间的相关性进行建模。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文献阅读&quot;&gt;&lt;a href=&quot;#文献阅读&quot; class=&quot;headerlink&quot; title=&quot;文献阅读&quot;&gt;&lt;/a&gt;文献阅读&lt;/h3&gt;&lt;h5 id=&quot;Morphogo-An-Automatic-Bone-Marrow-Cell-Classification-Sys</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mmcv组件Runner</title>
    <link href="http://abeltian.top/2021/10/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmcv%E7%BB%84%E4%BB%B6Runner/"/>
    <id>http://abeltian.top/2021/10/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmcv%E7%BB%84%E4%BB%B6Runner/</id>
    <published>2021-10-13T08:47:04.000Z</published>
    <updated>2022-01-19T04:37:20.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MMCV组件Runner"><a href="#MMCV组件Runner" class="headerlink" title="MMCV组件Runner"></a>MMCV组件Runner</h3><p>Runner负责所有框架的训练过程调度。</p><p>配合各类的Hook，对外提供灵活的扩展能力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">self, data_loader, **kwargs</span>):</span></span><br><span class="line">    self.model.<span class="built_in">eval</span>()</span><br><span class="line">    self.mode = <span class="string">&#x27;val&#x27;</span></span><br><span class="line">    self.data_loader = data_loader</span><br><span class="line">    self.call_hook(<span class="string">&#x27;before_val_epoch&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># Prevent possible deadlock during epoch transition</span></span><br><span class="line">    <span class="keyword">for</span> i, data_batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.data_loader):</span><br><span class="line">        self._inner_iter = i</span><br><span class="line">        self.call_hook(<span class="string">&#x27;before_val_iter&#x27;</span>)</span><br><span class="line">        self.run_iter(data_batch, train_mode=<span class="literal">False</span>)</span><br><span class="line">        self.call_hook(<span class="string">&#x27;after_val_iter&#x27;</span>)</span><br><span class="line">  self.call_hook(<span class="string">&#x27;after_val_epoch&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在测是流程中，call_hook函数来按照优先级执行hook的不同阶段(e.g. after_val_epoch)的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_hook</span>(<span class="params">self, fn_name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._hooks:</span><br><span class="line">        <span class="built_in">getattr</span>(hook, fn_name)(self)</span><br></pre></td></tr></table></figure><h3 id="如何修改mmdetection中的验证流程代码"><a href="#如何修改mmdetection中的验证流程代码" class="headerlink" title="如何修改mmdetection中的验证流程代码"></a>如何修改mmdetection中的验证流程代码</h3><p>在配置中默认validate变量为true</p><p>注册eval hooks，Hook类为EvalHook</p><p>在runner的流程中，在一个epoch后会执行EvalHook的after_train_epoch代码，其调用<code>_do_evaluate</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_do_evaluate</span>(<span class="params">self, runner</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;perform evaluation and save ckpt.&quot;&quot;&quot;</span></span><br><span class="line">    results = self.test_fn(runner.model, self.dataloader)</span><br><span class="line">    runner.log_buffer.output[<span class="string">&#x27;eval_iter_num&#x27;</span>] = <span class="built_in">len</span>(self.dataloader)</span><br><span class="line">    key_score = self.evaluate(runner, results)</span><br></pre></td></tr></table></figure><p>之后调用runner类的evaluate函数，调用datasets的evaluate函数，并将结果写入到runner.logger中，其是一个OrderedDict()字典结构(按照key插入顺序输出)，并将ready状态设置为True</p><p>修改自己数据集的evalute函数，如imagenet数据集的evaluate函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MMCV组件Runner&quot;&gt;&lt;a href=&quot;#MMCV组件Runner&quot; class=&quot;headerlink&quot; title=&quot;MMCV组件Runner&quot;&gt;&lt;/a&gt;MMCV组件Runner&lt;/h3&gt;&lt;p&gt;Runner负责所有框架的训练过程调度。&lt;/p&gt;
&lt;p&gt;配合</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mmclassification</title>
    <link href="http://abeltian.top/2021/10/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmclassification/"/>
    <id>http://abeltian.top/2021/10/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/mmclassification/</id>
    <published>2021-10-10T11:47:16.000Z</published>
    <updated>2022-01-19T04:37:20.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mmclassification训练"><a href="#mmclassification训练" class="headerlink" title="mmclassification训练"></a>mmclassification训练</h3><h3 id="train"><a href="#train" class="headerlink" title="train"></a>train</h3><p>生成imagenet数据集</p><p>修改模型配置文件resnext50_32x4d.py修改输出类别</p><p>修改datasets imagenet.py CLASSES列表变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASSES &#x3D; [&#39;Prim&#39;, &#39;Lym&#39;, &#39;Mono&#39;, &#39;Plas&#39;, &#39;Red&#39;, &#39;Promy&#39;, &#39;Myelo&#39;, &#39;Late&#39;, &#39;Rods&#39;, &#39;Lobu&#39;, &#39;Eosl&#39;]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/train.py configs/resnet/resnet50_b32x8_imagenet.py  --work-dir work_dirs</span><br></pre></td></tr></table></figure><h5 id="swin-transformer"><a href="#swin-transformer" class="headerlink" title="swin_transformer"></a>swin_transformer</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/train.py configs/swin_transformer/swin_small_224_b16x64_300e_imagenet.py  --work-dir work_dirs_swin</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/test.py configs/resnet/resnet50_b32x8_imagenet.py work_dirs/latest.pth --out result_test/resnet.pkl --metrics precision --out-items <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>分析结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;analysis_tools&#x2F;analyze_results.py configs&#x2F;swin_transformer&#x2F;swin_small_224_b16x64_300e_imagenet.py result_test&#x2F;resnet.pkl --out-dir result_test</span><br></pre></td></tr></table></figure><p> 训练swin_transformer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;train.py configs&#x2F;swin_transformer&#x2F;swin_small_224_b16x64_300e_imagenet.py  --work-dir work_dir_swin --resume-from work_dirss&#x2F;latest.pth</span><br></pre></td></tr></table></figure><p>测试swin_transformer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/test.py configs/swin_transformer/swin_small_224_b16x64_300e_imagenet.py work_dirs_swin/epoch_122.pth --out result_test/swin.pkl --metrics precision --out-items all</span><br></pre></td></tr></table></figure><p>分析结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/analysis_tools/analyze_results.py configs/swin_transformer/swin_small_224_b16x64_300e_imagenet.py result_test/swin.pkl --out-dir result_test</span><br></pre></td></tr></table></figure><p>训练在mmdetection上修改vit-transformer，尝试修改成为transformer-FG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;train.py configs&#x2F;vision_transformer&#x2F;vit-base-p16_ft-64xb64_in1k-384.py  --work-dir work_dir&#x2F;vit_fine_grained --resume-from work_dir&#x2F;vit&#x2F;latest.pth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;mmclassification训练&quot;&gt;&lt;a href=&quot;#mmclassification训练&quot; class=&quot;headerlink&quot; title=&quot;mmclassification训练&quot;&gt;&lt;/a&gt;mmclassification训练&lt;/h3&gt;&lt;h3 id=&quot;t</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%AA%A8%E9%AB%93%E8%A1%80%E7%BB%86%E8%83%9E%E5%88%86%E7%B1%BB%E6%A0%87%E5%87%86/"/>
    <id>http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%AA%A8%E9%AB%93%E8%A1%80%E7%BB%86%E8%83%9E%E5%88%86%E7%B1%BB%E6%A0%87%E5%87%86/</id>
    <published>2021-10-09T08:54:33.465Z</published>
    <updated>2021-10-09T12:32:21.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="骨髓血细胞分类标准"><a href="#骨髓血细胞分类标准" class="headerlink" title="骨髓血细胞分类标准"></a>骨髓血细胞分类标准</h3><p>嗜酸、碱、中主要是针对细胞染色而言的，</p><p>嗜酸性：组织和细胞成分对酸性染料（如伊红）的亲和性</p><p>嗜碱性：组织和细胞成分对碱性染料（含有阳离子着色基团的染料，如苏木精、结晶紫、美蓝等）的亲和性。</p><p>淋巴细胞，胞体小，胞质少，胞核规则，染色质致密。</p><p>单核细胞 胞体较大，胞核有折叠，染色质偏细，较疏松</p><p>中英文对照</p><table><thead><tr><th>Neutrophils</th><th>Eosinophlis</th><th>basophils</th><th>myeloblast</th><th>promyelocyte</th><th>myelocyte</th><th>metamyelocyte</th></tr></thead><tbody><tr><td>嗜中性粒细胞</td><td>嗜酸性粒细胞</td><td>嗜碱性粒细胞</td><td>原始粒细胞</td><td>早幼粒细胞</td><td>中幼粒细胞</td><td>晚幼粒细胞</td></tr></tbody></table><p><a href="https://www.bilibili.com/video/BV1tT4y1F76L?p=1">https://www.bilibili.com/video/BV1tT4y1F76L?p=1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;骨髓血细胞分类标准&quot;&gt;&lt;a href=&quot;#骨髓血细胞分类标准&quot; class=&quot;headerlink&quot; title=&quot;骨髓血细胞分类标准&quot;&gt;&lt;/a&gt;骨髓血细胞分类标准&lt;/h3&gt;&lt;p&gt;嗜酸、碱、中主要是针对细胞染色而言的，&lt;/p&gt;
&lt;p&gt;嗜酸性：组织和细胞成分对酸性染</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ssh%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ssh%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-09T08:54:33.463Z</published>
    <updated>2021-10-09T08:54:33.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ssh配置文件与使用"><a href="#ssh配置文件与使用" class="headerlink" title="ssh配置文件与使用"></a>ssh配置文件与使用</h3><p><a href="https://www.cnblogs.com/xjshi/p/9146296.html">https://www.cnblogs.com/xjshi/p/9146296.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ssh配置文件与使用&quot;&gt;&lt;a href=&quot;#ssh配置文件与使用&quot; class=&quot;headerlink&quot; title=&quot;ssh配置文件与使用&quot;&gt;&lt;/a&gt;ssh配置文件与使用&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xjshi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>损失函数</title>
    <link href="http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/loss%E5%87%BD%E6%95%B0/"/>
    <id>http://abeltian.top/2021/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/loss%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-09T02:29:10.000Z</published>
    <updated>2022-01-19T04:26:13.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="loss函数"><a href="#loss函数" class="headerlink" title="loss函数"></a>loss函数</h3><h3 id="BCE-Loss"><a href="#BCE-Loss" class="headerlink" title="BCE Loss"></a>BCE Loss</h3><p>适用于二分类<br>$$<br>-ylog(\hat{y}) - (1 - y) log(1 - \hat{y})<br>$$</p><h3 id="CE-loss"><a href="#CE-loss" class="headerlink" title="CE loss"></a>CE loss</h3><p>当是多分类时，经过softmax后，只需要让GT对应类别输出尽量为1即可</p><h3 id="Focal-loss"><a href="#Focal-loss" class="headerlink" title="Focal loss"></a>Focal loss</h3><p><code>mmdet/models/losses/focal_loss.py</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;loss函数&quot;&gt;&lt;a href=&quot;#loss函数&quot; class=&quot;headerlink&quot; title=&quot;loss函数&quot;&gt;&lt;/a&gt;loss函数&lt;/h3&gt;&lt;h3 id=&quot;BCE-Loss&quot;&gt;&lt;a href=&quot;#BCE-Loss&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>卷积与梯度</title>
    <link href="http://abeltian.top/2021/10/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E4%B8%8E%E6%A2%AF%E5%BA%A6/"/>
    <id>http://abeltian.top/2021/10/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E4%B8%8E%E6%A2%AF%E5%BA%A6/</id>
    <published>2021-10-04T02:39:42.000Z</published>
    <updated>2021-10-09T08:54:33.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pytorch-卷积与梯度反向传播"><a href="#Pytorch-卷积与梯度反向传播" class="headerlink" title="Pytorch 卷积与梯度反向传播"></a>Pytorch 卷积与梯度反向传播</h3><h3 id="pytorch计算图"><a href="#pytorch计算图" class="headerlink" title="pytorch计算图"></a>pytorch计算图</h3><p><a href="https://zhuanlan.zhihu.com/p/33378444">https://zhuanlan.zhihu.com/p/33378444</a></p><p><a href="https://towardsdatascience.com/pytorch-autograd-understanding-the-heart-of-pytorchs-magic-2686cd94ec95">https://towardsdatascience.com/pytorch-autograd-understanding-the-heart-of-pytorchs-magic-2686cd94ec95</a></p><p><a href="https://zhuanlan.zhihu.com/p/69175484">https://zhuanlan.zhihu.com/p/69175484</a> 这篇写的比较全，光说不练，假把式；光练不说，傻把式；连说带练~~真！把！式！’”</p><p><a href="https://blog.csdn.net/cedi9117/article/details/106955001/">https://blog.csdn.net/cedi9117/article/details/106955001/</a> pytorch tensor计算</p><p>将梯度想象为小格子，因此同一层节点梯度是相加的，不同层的节点梯度是相乘的</p><p><img src="https://pic3.zhimg.com/80/v2-d49100009fa98eb736125ca32f8d084a_720w.jpg" alt="img"></p><p>理解一下<br>$$<br>z = f + g \<br>dz = k(df + dg) \<br>z = f * g * h \<br>z + dz = (f + df)(g + dg)(h + dh) 忽略高阶项<br>$$<br><a href="https://zhuanlan.zhihu.com/p/27783097">https://zhuanlan.zhihu.com/p/27783097</a></p><p>Pytorch是利用Variable与Function来构建计算图的。Variable就像是计算图中的节点，保存计算结果（包括前向传播的激活值，反向传播的梯度），而Function就像计算图中的边，实现Variable的计算，并输出新的Variable。</p><p>torch.autograd.Funtion</p><p>矩阵求导</p><p><a href="https://zhuanlan.zhihu.com/p/262751195">https://zhuanlan.zhihu.com/p/262751195</a></p><p><img src="/home/sty/.config/Typora/typora-user-images/image-20211004160423050.png" alt="image-20211004160423050"></p><p>利用pytorch实现卷积运算 <a href="https://zhuanlan.zhihu.com/p/349683405%EF%BC%8C%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E6%B1%82%E5%92%8C%E6%A0%87%E8%AE%B0">https://zhuanlan.zhihu.com/p/349683405，爱因斯坦求和标记</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Pytorch-卷积与梯度反向传播&quot;&gt;&lt;a href=&quot;#Pytorch-卷积与梯度反向传播&quot; class=&quot;headerlink&quot; title=&quot;Pytorch 卷积与梯度反向传播&quot;&gt;&lt;/a&gt;Pytorch 卷积与梯度反向传播&lt;/h3&gt;&lt;h3 id=&quot;pytor</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python项目框架学习</title>
    <link href="http://abeltian.top/2021/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://abeltian.top/2021/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-28T09:36:18.000Z</published>
    <updated>2022-01-19T04:29:01.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python代码组织结构"><a href="#python代码组织结构" class="headerlink" title="python代码组织结构"></a>python代码组织结构</h3><p><a href="https://blog.csdn.net/weixin_38256474/article/details/81228492">https://blog.csdn.net/weixin_38256474/article/details/81228492</a></p><p>python 模块包(module package)，当目录中包含了<code>__init__.py</code>时，当用import导入该目录时，会执行<code>__init__.py</code>中的代码。该文件的作用相当于将自身整个文件夹当作一个包来管理。</p><p><code>from xxx import *</code>是如何实现的，<code>__init__.py</code>中的<code>__all__</code>变量关联了一个模块列表，制定哪些模块会被import进当前的作用域中。</p><p><strong>python 命名空间</strong></p><p>local namespace 函数或类方法</p><p>global namespace 当前模块</p><p>build_in namespace build_in空间</p><p>对于闭包，若在local namespace找不到变量，则下一个查找目标是父函数的local namespace</p><p><strong>模块内置属性</strong></p><p><code>__name__</code>直接运行本模块，值为<code>__main__</code>, <code>import module</code>为模块名字</p><p><code>__file__</code>当前module的绝对路径</p><p><code>__dict__</code>,<code>__doc__</code>,<code>__package__</code>,<code>__path__</code></p><p><strong>python import运行机制</strong></p><p>step1：创建一个新的、空的module对象（它可能包含多个module）；<br>step2：将该module对象 插入sys.modules中；<br>step3：装载module的代码（如果需要，需先编译）；<br>step4：执行新的module中对应的代码。</p><p>导入模块分为三类，第一类：导入 Python 内置模块，第二类：导入相关的第三方库模块，第三类：导入程序本地的模块 (即当前应用的模块)。导入不同类别模块时，需要使用空行进行分开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置模块</span></span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三方模块</span></span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地模块</span></span><br><span class="line"><span class="keyword">from</span> .xxx <span class="keyword">import</span> xxx</span><br></pre></td></tr></table></figure><p>绝对导入，从项目的根文件夹到要导入模块的完整路径。</p><p>相对导入，相对当前模块路径要导入资源的位置。</p><p>隐式相对导入(python3中不推荐) import module vs from . import module</p><h3 id="python装饰器函数"><a href="#python装饰器函数" class="headerlink" title="python装饰器函数"></a>python装饰器函数</h3><p><a href="https://www.cnblogs.com/f-ck-need-u/p/10198247.html">https://www.cnblogs.com/f-ck-need-u/p/10198247.html</a></p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/10205168.html">https://www.cnblogs.com/f-ck-need-u/p/10205168.html</a></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>如果想要在内函数中修改外函数的值，需要使用 nonlocal 关键字声明变量，闭包主要用于装饰器的实现。</p><h5 id="装饰器-在mmdetection中的使用"><a href="#装饰器-在mmdetection中的使用" class="headerlink" title="装饰器 在mmdetection中的使用"></a>装饰器 在mmdetection中的使用</h5><p>装饰器的关键特性是在被装饰的函数被定义之后立刻执行，通常是在导入(import, from xx import xxx)，即python模块加载时。</p><h5 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h5><p><code>__call__</code> 该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p><p><code>__repr__</code> 会返回和调用者有关的 “类名+object at+内存地址”信息。print(object)，类实例化对象的自我描述信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;python代码组织结构&quot;&gt;&lt;a href=&quot;#python代码组织结构&quot; class=&quot;headerlink&quot; title=&quot;python代码组织结构&quot;&gt;&lt;/a&gt;python代码组织结构&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>pytorch与mmcv源码学习</title>
    <link href="http://abeltian.top/2021/09/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E4%B8%8Emmcv%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://abeltian.top/2021/09/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E4%B8%8Emmcv%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-27T13:16:44.000Z</published>
    <updated>2022-01-19T04:30:36.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MMCV官方文档"><a href="#MMCV官方文档" class="headerlink" title="MMCV官方文档"></a>MMCV官方文档</h3><p><a href="https://mmcv.readthedocs.io/en/latest/api.html#module-mmcv.cnn">https://mmcv.readthedocs.io/en/latest/api.html#module-mmcv.cnn</a></p><p>mmdetection中使用了注册机制，使用字典进行字符串向类的映射，在norm.py中，使用了如下的代码，以norm layer为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/mmcv/cnn/bricks/registry.py</span><br><span class="line">NORM_LAYERS = Registry(<span class="string">&#x27;norm layer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">/mmcv/cnn/bricks/norm.py</span><br><span class="line">NORM_LAYERS.register_module(<span class="string">&#x27;BN&#x27;</span>, module=nn.BatchNorm2d)</span><br><span class="line">NORM_LAYERS.register_module(<span class="string">&#x27;BN1d&#x27;</span>, module=nn.BatchNorm1d)</span><br><span class="line">NORM_LAYERS.register_module(<span class="string">&#x27;BN2d&#x27;</span>, module=nn.BatchNorm2d)</span><br><span class="line"></span><br><span class="line">registry类实现在mmcv/runner/utils/registry.py文件中</span><br></pre></td></tr></table></figure><p>build_norm_layer函数，通过type”BN”返回提前注册的类nn.BatchNorm2d，并用该类根据输入的num_features构造相应的归一化层，默认需要梯度(requires_grad=True)。</p><h3 id="Pytorch源码学习"><a href="#Pytorch源码学习" class="headerlink" title="Pytorch源码学习"></a>Pytorch源码学习</h3><p>nn.Module</p><p>torch.utils.checkpoint 不缓存中间变量，时间换显存空间</p><h3 id="ResNet源码阅读"><a href="#ResNet源码阅读" class="headerlink" title="ResNet源码阅读"></a>ResNet源码阅读</h3><p><img src="https://pic3.zhimg.com/v2-763773acb7949d52c2a1fdd410dd8cf2_r.jpg" alt="preview"></p><p>在mmcv的<code>resnet.py</code>文件中，对于resnet18与34，对应的block为BasicBlock，而50层以上的block为Bottleneck<br>卷积层分为stem与四个stage，stride=(1, 2, 2, 2)，stride=2是第一个<code>3x3</code>的卷积层。在reset中，只有第一个块的stride是2，其余均为1。</p><p>self.downsample在第一层需要对原输入x进行大小与通道数的调整，后续的block不需要进行该操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        identity = self.downsample(x)</span><br></pre></td></tr></table></figure><p>代码中的dcn为可变形卷积(deformable convlution)</p><p><strong>_freeze_stage</strong>，将前几个stage的梯度更新设置为false，model设置为eval()模式。</p><p>block 每一个模块有num_blocks，对于blocks之间的连接，只有第一个block是进行残差学习。</p><p>在每一个block连接中，<code>inplanes = planes * expansion</code>，在每一个<code>res_layer</code>之间的连接中，<code>planes =  base_channels * 2 ** i </code>，在res_layer结束后，将<code>inplanes设置为当前的planes * expansion</code></p><h3 id="model-eval"><a href="#model-eval" class="headerlink" title="model.eval()"></a>model.eval()</h3><p>eval将dropout层设置为无效，batchnorm层的<code>running_mean</code>、<code>running_var</code>不更新。BatchNorm层的均值与方差采用<code>momentum</code>进行更新$\hat{x}_{new} = (1 - momentum) \times \hat{x} + momentum \times x_t$。</p><p><strong>drop_out实现原理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span>(<span class="params">X,drop_prob</span>):</span></span><br><span class="line">    X = X.<span class="built_in">float</span>()</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span>&lt;=drop_prob&lt;=<span class="number">1</span></span><br><span class="line">    keep_prob = <span class="number">1</span>-drop_prob</span><br><span class="line">    <span class="keyword">if</span> keep_prob==<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> torch.torch.zeros_like(X)</span><br><span class="line">    mask = (torch.rand(X.shape)&lt;keep_prob).<span class="built_in">float</span>()</span><br><span class="line">    <span class="keyword">return</span> mask * X / keep_prob</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MMCV官方文档&quot;&gt;&lt;a href=&quot;#MMCV官方文档&quot; class=&quot;headerlink&quot; title=&quot;MMCV官方文档&quot;&gt;&lt;/a&gt;MMCV官方文档&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://mmcv.readthedocs.io/en/latest</summary>
      
    
    
    
    
    <category term="deep learning" scheme="http://abeltian.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>2021秋季lccup战队赛</title>
    <link href="http://abeltian.top/2021/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2021lccup/"/>
    <id>http://abeltian.top/2021/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2021lccup/</id>
    <published>2021-09-26T08:48:23.000Z</published>
    <updated>2021-10-09T08:54:33.460Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/09/30/jiP1m5XHIkVGRvB.png" alt="image-20210929231014229.png"></p><p>比赛的时候是用C++写的，也是按照这个思路，按照行、列、主对角线、次对角线进行分类。这样可以将二维的坐标压缩到一维进行判断，且行，列，对角线的判断方法完全相同。</p><p>判断黑棋第一步赢，与白棋第二步赢比较简单。</p><ul><li>黑棋第一步赢，则放入后黑棋后，连起来为五个黑子。这样的位置大于等于一个即可</li><li>白棋第二步赢，则首先不存在黑棋一步赢的情况，放入白棋后连续白子超过五个，这样的位置需要大于等于两个，因为黑棋第一步可以堵入一个位置。</li></ul><p>判断黑棋第三步赢，则相对复杂些</p><ul><li>如果白棋存在五连的情况，第一步首先要填入白棋的位置，然后按照黑棋一步赢的情况查找可行位置，不过这种位置需要大于等于两个</li><li>填入某个黑色棋子后，可以五连的位置大于等于两个，采用defaultdict(set)来记录某个位置对应可行位置的集合</li><li>如果是三或四个棋子，则坐标的max - min一定要小于等于4，这几个棋子才有可能五连。然后枚举所有可行的最小的位置(区间[max - 4, min])，并定义为start，查找不在[start, start + 4]的空位置，按棋子个数为3，4分情况讨论。</li></ul><p>比赛时候没有想到上述做法，而是直接进行枚举所有三个，四个棋子的情况。三个棋子时有$C_5^3$共10种情况，代码写的很长，还漏了边界case。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gobang</span>(<span class="params">self, pieces: List[List[<span class="built_in">int</span>]]</span>) -&gt; str:</span></span><br><span class="line">        black = [defaultdict(<span class="built_in">set</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">        white = [defaultdict(<span class="built_in">set</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">        <span class="comment"># 行、列、主对角线，次对角线</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_pieces</span>(<span class="params">x, y, c</span>):</span></span><br><span class="line">            p = black</span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">1</span>:</span><br><span class="line">                p = white</span><br><span class="line">            p[<span class="number">0</span>][x].add(y)</span><br><span class="line">            p[<span class="number">1</span>][y].add(x)</span><br><span class="line">            p[<span class="number">2</span>][x - y].add(y)</span><br><span class="line">            p[<span class="number">3</span>][x + y].add(y)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_pos</span>(<span class="params">x, y, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">            <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> y, x</span><br><span class="line">            <span class="keyword">elif</span> k == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> x + y, y</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> x - y, y</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_pos</span>(<span class="params">p, q, space</span>):</span></span><br><span class="line">            pos = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> idx, se <span class="keyword">in</span> p[k].items():</span><br><span class="line">                    vec = <span class="built_in">sorted</span>(<span class="built_in">list</span>(se))</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vec) - space + <span class="number">1</span>):</span><br><span class="line">                        start, end = vec[i], vec[i + space - <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> end - start &gt; <span class="number">4</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment"># s为所有可能五连的起点</span></span><br><span class="line">                        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(end - <span class="number">4</span>, start + <span class="number">1</span>):</span><br><span class="line">                            arr = [v <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(s, s + <span class="number">5</span>) <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> vec[i:i + space] <span class="keyword">and</span> v <span class="keyword">not</span> <span class="keyword">in</span> q[k][idx]]</span><br><span class="line">                            <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">2</span> <span class="keyword">and</span> space == <span class="number">3</span>:</span><br><span class="line">                                x1, y1 = get_pos(idx, arr[<span class="number">0</span>], k)</span><br><span class="line">                                x2, y2 = get_pos(idx, arr[<span class="number">1</span>], k)</span><br><span class="line">                                pos[(x1, y1)].add((x2, y2))</span><br><span class="line">                                pos[(x2, y2)].add((x1, y1))</span><br><span class="line">                            <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">1</span> <span class="keyword">and</span> space == <span class="number">4</span>:</span><br><span class="line">                                x, y = get_pos(idx, arr[<span class="number">0</span>], k)</span><br><span class="line">                                pos[(x, y)].add((x, y))</span><br><span class="line">            <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x, y, c <span class="keyword">in</span> pieces:</span><br><span class="line">            add_pieces(x, y, c)</span><br><span class="line">        <span class="comment"># 黑棋第一步赢，则可放入位置大于等于1</span></span><br><span class="line">        b1_pos = find_pos(black, white, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(b1_pos) &gt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Black&#x27;</span></span><br><span class="line">        <span class="comment"># 白棋第二步赢，则可放入位置大于1</span></span><br><span class="line">        w2_pos = find_pos(white, black, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(w2_pos) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;White&#x27;</span></span><br><span class="line">        <span class="comment"># 白棋如果存在可赢的位置，则需要填入黑棋</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(w2_pos) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> w2_pos.keys():</span><br><span class="line">                add_pieces(x, y, <span class="number">0</span>)</span><br><span class="line">            b3_pos = find_pos(black, white, <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(b3_pos) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Black&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b3_pos = find_pos(black, white, <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> p, cnt <span class="keyword">in</span> b3_pos.items():</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cnt) &gt;= <span class="number">2</span>:</span><br><span class="line">                    print(p, cnt)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;Black&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;None&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/09/30/jiP1m5XHIkVGRvB.png&quot; alt=&quot;image-20210929231014229.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;比赛的时候是用C++写的，也是按照这个思路，按照行、列、主对角线、次</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>initialize神经网络</title>
    <link href="http://abeltian.top/2021/09/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/initialize%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://abeltian.top/2021/09/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/initialize%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2021-09-26T08:48:23.000Z</published>
    <updated>2021-10-02T05:49:06.313Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/f2d800388d1c">https://www.jianshu.com/p/f2d800388d1c</a></p><p><img src="https://upload-images.jianshu.io/upload_images/13575947-357753b087f499e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt="img"></p><p>神经网络是个系统工程，数据、参数、模型内部结构、训练策略、学习率等等，这些因素不管哪一部分出错，它都不会报错，只是会输出一些不是你想要的结果。Batch Normalization </p><p>输出的blob大小为(N, C, H, W)，在每一层Normalization就是基于N * H * W个数值求平均，以及方差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/f2d800388d1c&quot;&gt;https://www.jianshu.com/p/f2d800388d1c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jiansh</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://abeltian.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
