<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TYS的博客</title>
  
  <subtitle>算法小白努力学习中</subtitle>
  <link href="http://abeltian.top/atom.xml" rel="self"/>
  
  <link href="http://abeltian.top/"/>
  <updated>2021-09-10T08:53:11.519Z</updated>
  <id>http://abeltian.top/</id>
  
  <author>
    <name>tys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>点在多边形内部</title>
    <link href="http://abeltian.top/2021/05/21/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/"/>
    <id>http://abeltian.top/2021/05/21/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8/</id>
    <published>2021-05-21T12:36:37.000Z</published>
    <updated>2021-09-10T08:53:11.519Z</updated>
    
    <content type="html"><![CDATA[<h5 id="点在多边形内部"><a href="#点在多边形内部" class="headerlink" title="点在多边形内部"></a>点在多边形内部</h5><p>射线法，从判断点向上做一条射线，当与多边形交点个数为奇数个时，则点在多边形内部。</p><p>边界条件(点在顶点上，点在边上，通过叉积等于0与点积小于等于0来判断）</p><p>边界条件，凸顶点判断一次，凹顶点判断两次</p><p>边界条件，当连线与边重叠时，不进行判断，点一定在多边形外部。</p><p><img src="https://i.loli.net/2021/05/21/CbcMus1FqnoPEjO.png" alt="image-20210521204309172.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((c.x &gt;= a.x &amp;&amp; c.x &lt; b.x) || (c.x &gt;= b.x &amp;&amp; c.x &lt; a.x))</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/21/UNSbcLEqvAFsPDH.png" alt="image-20210521204412305.png"></p><p><img src="https://i.loli.net/2021/05/21/i9zOFl2hYJKLRes.png" alt="image-20210521204008259.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    Point(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) : x(_x), y(_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - b.x * a.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; arr;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(Point c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; j = i++) &#123;</span><br><span class="line">        Point a = arr[j], b = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (dot(c - a, c - b) &lt;= <span class="number">0</span> &amp;&amp; cross(c - a, c - b) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (((c.x &gt;= a.x &amp;&amp; c.x &lt; b.x) || (c.x &gt;= b.x &amp;&amp; c.x &lt; a.x)) &amp;&amp; c.y &lt; a.y + <span class="number">1.0</span> * (b.y - a.y) / (b.x - a.x) * (c.x - a.x)) &#123;</span><br><span class="line">            ans = !ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        freopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, q, x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        arr.push_back(&#123;x, y&#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (in(&#123;x, y&#125;)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;点在多边形内部&quot;&gt;&lt;a href=&quot;#点在多边形内部&quot; class=&quot;headerlink&quot; title=&quot;点在多边形内部&quot;&gt;&lt;/a&gt;点在多边形内部&lt;/h5&gt;&lt;p&gt;射线法，从判断点向上做一条射线，当与多边形交点个数为奇数个时，则点在多边形内部。&lt;/p&gt;
&lt;p&gt;边界</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>素数方法</title>
    <link href="http://abeltian.top/2021/05/20/%E6%95%B0%E8%AE%BA/%E5%85%B3%E4%BA%8E%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://abeltian.top/2021/05/20/%E6%95%B0%E8%AE%BA/%E5%85%B3%E4%BA%8E%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</id>
    <published>2021-05-20T02:29:10.000Z</published>
    <updated>2021-09-10T08:53:11.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于素数的一些方法"><a href="#关于素数的一些方法" class="headerlink" title="关于素数的一些方法"></a>关于素数的一些方法</h3><p>假设N为1e5，对1到N中所有的数做质因子分解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prime[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isp, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = j, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (cur % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    cur /= i;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                prime[j][i] = cnt;</span><br><span class="line">                isp[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到1到N中所有数的因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fact[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; N; j += i) &#123;</span><br><span class="line">        fact[j].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到[1:m]中满足$gcd(n, p) = x$的$p$的数量。</p><p>$$<br>gcd(n, p) = x  \\<br>n = a \cdot x, p = b \cdot x \\<br>gcd(a, b) = 1<br>$$<br>找到[1:b]中gcd(a, b) = 1中数字的数量，计算[1:b]中gcd(a, b) != 1的数量, prime[a]为a的质因数分解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : prime[a]) &#123;</span><br><span class="line">        arr.push_back(it.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = arr.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; sz); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1</span>, sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                mul *= arr[j];</span><br><span class="line">                sign *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sign * b / mul;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://codeforces.com/problemset/problem/1139/D">https://codeforces.com/problemset/problem/1139/D</a></p><p>其中cnt为1到m中gcd(p, x) = y的p的数量。<br>$$<br>f[x] = 1 + \frac{cnt}{m}f[y] + \frac{\frac{m}{x}}{m}f[x]<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于素数的一些方法&quot;&gt;&lt;a href=&quot;#关于素数的一些方法&quot; class=&quot;headerlink&quot; title=&quot;关于素数的一些方法&quot;&gt;&lt;/a&gt;关于素数的一些方法&lt;/h3&gt;&lt;p&gt;假设N为1e5，对1到N中所有的数做质因子分解。&lt;/p&gt;
&lt;figure class</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>组合数学DP</title>
    <link href="http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6DP/"/>
    <id>http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6DP/</id>
    <published>2021-05-20T02:29:10.000Z</published>
    <updated>2021-09-10T08:53:11.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="组合数学DP"><a href="#组合数学DP" class="headerlink" title="组合数学DP"></a>组合数学DP</h4><p>一个挺有意思的题目</p><p><a href="https://cses.fi/problemset/task/1717">https://cses.fi/problemset/task/1717</a></p><p>There are n children at a Christmas party, and each of them has brought a gift. The idea is that everybody will get a gift brought by someone else. In how many ways can the gifts be distributed?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;组合数学DP&quot;&gt;&lt;a href=&quot;#组合数学DP&quot; class=&quot;headerlink&quot; title=&quot;组合数学DP&quot;&gt;&lt;/a&gt;组合数学DP&lt;/h4&gt;&lt;p&gt;一个挺有意思的题目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cses.fi/problemset/t</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>错拍公式</title>
    <link href="http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/"/>
    <id>http://abeltian.top/2021/05/20/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/</id>
    <published>2021-05-20T02:29:10.000Z</published>
    <updated>2021-09-10T08:53:11.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h3><p>错排问题，考虑$n$个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。记作$n$个元素的错排数为$D(n)$。</p><p>递推公式：</p><ul><li><p>选择书的编号为m，剩下n - 1个位置，假设选择k</p></li><li><p>k放入m的位置 则转化为$D(n - 2)$的错排方案数</p></li><li><p>第m本书在位置k不动，此时k不能放在第m个位置，其他n - 2本书也不在自己原本的位置，等价于求$n - 1$个数的错排</p></li></ul><p>$$<br>D(n) = (n - 1) *[D(n- 1) + D(n - 2)]<br>$$</p><p><a href="https://cses.fi/problemset/task/1717">https://cses.fi/problemset/task/1717</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;错排公式&quot;&gt;&lt;a href=&quot;#错排公式&quot; class=&quot;headerlink&quot; title=&quot;错排公式&quot;&gt;&lt;/a&gt;错排公式&lt;/h3&gt;&lt;p&gt;错排问题，考虑$n$个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。记作$</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA注解</title>
    <link href="http://abeltian.top/2021/04/20/JAVA/java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://abeltian.top/2021/04/20/JAVA/java%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-04-20T02:29:10.000Z</published>
    <updated>2021-09-10T08:53:11.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h3><p>注解可以被编译器打包进入class文件，是一种用作标注的元数据。</p><ul><li>由编译器使用的注解@Override让编译器检查该方法是否正确地实现了覆写。这类注解不会被编译进入.class文件，在编译后就被扔掉了</li><li>由工具类处理.class文件使用的注解。</li><li>程序运行期能够读取的注解，加载后一直存在于JVM中，例如@PostConstruct方法在调用构造方法后自动被调用。</li></ul><h4 id="1-定义注解"><a href="#1-定义注解" class="headerlink" title="1.定义注解"></a>1.定义注解</h4><p>java语言使用@interface语法来定义注解(Annotation)</p><h3 id="2-使用注解"><a href="#2-使用注解" class="headerlink" title="2.使用注解"></a>2.使用注解</h3><p>通常注解如何使用由程序自己决定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;java注解&quot;&gt;&lt;a href=&quot;#java注解&quot; class=&quot;headerlink&quot; title=&quot;java注解&quot;&gt;&lt;/a&gt;java注解&lt;/h3&gt;&lt;p&gt;注解可以被编译器打包进入class文件，是一种用作标注的元数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由编译器使用的注</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>wilson定理</title>
    <link href="http://abeltian.top/2021/04/20/%E6%95%B0%E8%AE%BA/wilson%E5%AE%9A%E7%90%86/"/>
    <id>http://abeltian.top/2021/04/20/%E6%95%B0%E8%AE%BA/wilson%E5%AE%9A%E7%90%86/</id>
    <published>2021-04-20T02:29:10.000Z</published>
    <updated>2021-09-10T08:53:11.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="wilson定理"><a href="#wilson定理" class="headerlink" title="wilson定理"></a>wilson定理</h3><p>正整数n &gt; 1， 则n是一个素数当且仅当$(n - 1)! \equiv -1 (mod\ n)$</p><p>如果n为非质数，假设集合A为${1, x_1, x_2,\cdots x_{m - 1}, n - 1}$与n互质。</p><p>对于任意$x_i$，则$x_i \cdot A$集合为${x_i,\ x_i\cdot x_1,\ x_i \cdot x_2,\  \cdots,\  x_i \cdot x_{m - 1},\ x_i \cdot (n - 1)}$, 对于其中$x_i\cdot A$中任意一个元素其膜n的值互不相同，且为集合A中的元素，因此存在$x_i * x_j \equiv 1 (mod\ n)$，因为1和n - 1模n逆元为其本身，$x_i$的逆元为$x_j$<br>$$<br>(1\times x_1 \times x_2 \times \cdots x_m \times n - 1) \cdot (1\times x_1 \times x_2 \times \cdots x_m \times n - 1)  \equiv (1 * 1) \times (x_i * x_j) \cdots \times ((n - 1) * (n - 1)) \equiv 1 (mod \ n) \\<br>令(1\times x_1 \times x_2 \times \cdots x_m \times n - 1) = y \\<br>y^2\equiv 1 (mod\ n)\\<br>y \equiv 1 (mod\ n)\ 或\ y \equiv n - 1 (mod\ n)<br>$$</p><p>$$<br>x_i*x_j \equiv x_i * x_k (mod\ n) \\<br>x_i * (x_j - x_k) \equiv 0 (mod\ n) \\<br>(x_j - x_k) \equiv 0 (mod\ n) \\<br>x_j = x_k<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;wilson定理&quot;&gt;&lt;a href=&quot;#wilson定理&quot; class=&quot;headerlink&quot; title=&quot;wilson定理&quot;&gt;&lt;/a&gt;wilson定理&lt;/h3&gt;&lt;p&gt;正整数n &amp;gt; 1， 则n是一个素数当且仅当$(n - 1)! \equiv -1 (m</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>欧拉函数</title>
    <link href="http://abeltian.top/2021/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <id>http://abeltian.top/2021/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-07T12:53:42.000Z</published>
    <updated>2021-09-10T08:53:11.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>欧拉函数是小于或等于n的正整数中与n互质的数目，$\phi(1) = 1$。</p><p>通式：<br>$$<br>\phi(x)= x \mathop{\Pi}\limits_{i = 1}^{n}(1 - \frac{1}{p_i})<br>$$<br>若n是质数的p的k次幂，$\phi(n) = p^k - p^{k - 1}$，因为除了p的倍数$p * (1,2\dots p^{k - 1})$以外，其他数均与n互质。</p><p>线性筛，每个合数通过其最小的质因数筛掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;欧拉函数&quot;&gt;&lt;a href=&quot;#欧拉函数&quot; class=&quot;headerlink&quot; title=&quot;欧拉函数&quot;&gt;&lt;/a&gt;欧拉函数&lt;/h3&gt;&lt;p&gt;欧拉函数是小于或等于n的正整数中与n互质的数目，$\phi(1) = 1$。&lt;/p&gt;
&lt;p&gt;通式：&lt;br&gt;$$&lt;br&gt;\ph</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>凸包</title>
    <link href="http://abeltian.top/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%87%B8%E5%8C%85/"/>
    <id>http://abeltian.top/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%87%B8%E5%8C%85/</id>
    <published>2021-03-01T08:43:21.000Z</published>
    <updated>2021-09-10T08:53:11.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>二维凸包， 凸多边形是指所有内角大小都在$[0, \pi]$范围内的简单多边形。在平面上能包含所有给定点的最小凸多边形叫做凸包。</p><p><img src="https://i.loli.net/2021/03/01/lnexKVFcdszy1o9.png" alt="image-20210301175049366.png"></p><h4 id="Andrew算法"><a href="#Andrew算法" class="headerlink" title="Andrew算法"></a>Andrew算法</h4><p>$\quad\quad$首先将点集按照x坐标(第一关键字)，y坐标进行升序排列。显然排序后最小的元素和最大的元素一定在凸包上。他们之间的部分可以分成上下两条链分别求解。求下链时只要从小到大遍历排序后的点列，求上链从大到小遍历即可。</p><p>$\quad\quad$在凸包上，我们从一个点出发逆时针走，轨迹总是左拐的，如果出现右拐，则说明该段不在凸包上。采用栈来记录轨迹上已经走过的点，如果即将入栈的点$P$和栈顶点$S_1$构成的向量方向相较$S_2, S_1$构成向量的方向向右旋转，即叉积$\vec{S_2S_1} \times\vec{S_1P} &lt; 0$，则弹出栈顶，直到$\vec{S_2S_1} \times\vec{S_1P} \geq 0$或栈内仅包含一个元素。</p><p><img src="https://i.loli.net/2021/03/01/SntDQRqyGUWZdb7.png" alt="image-20210301193138704.png"></p><p><img src="https://i.loli.net/2021/03/01/dRhNI73XCswi4k9.png" alt="image2"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == rhs.x ? y &lt; rhs.y : x &lt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point&amp; rhs) &#123;</span><br><span class="line">        <span class="function">Point <span class="title">ret</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        ret.x = x - rhs.x;</span><br><span class="line">        ret.y = y - rhs.y;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Point&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * rhs.y - y * rhs.x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; outerTrees(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Point&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr.push_back(&#123;points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(n + <span class="number">5</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt;= <span class="number">2</span> &amp;&amp; ((arr[st[tp]] - arr[st[tp - <span class="number">1</span>]]) ^ (arr[i] - arr[st[tp]])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                used[st[tp--]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st[++tp] = i;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt;= <span class="number">2</span> &amp;&amp; ((arr[st[tp]] - arr[st[tp - <span class="number">1</span>]]) ^ (arr[i] - arr[st[tp]])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                used[st[tp--]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st[++tp] = i;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tp; ++i) &#123;</span><br><span class="line">           ret.push_back(&#123;arr[st[i]].x, arr[st[i]].y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度，排序$O(n\log n)$，上下链求解$O(2n)$</li><li>空间复杂度，栈的最大深度为O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;凸包&quot;&gt;&lt;a href=&quot;#凸包&quot; class=&quot;headerlink&quot; title=&quot;凸包&quot;&gt;&lt;/a&gt;凸包&lt;/h3&gt;&lt;p&gt;二维凸包， 凸多边形是指所有内角大小都在$[0, \pi]$范围内的简单多边形。在平面上能包含所有给定点的最小凸多边形叫做凸包。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="http://abeltian.top/2021/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/"/>
    <id>http://abeltian.top/2021/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</id>
    <published>2021-02-27T03:46:47.000Z</published>
    <updated>2021-09-10T08:53:11.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跳表-Probabilistic-Alternative-to-Balanced-Trees"><a href="#跳表-Probabilistic-Alternative-to-Balanced-Trees" class="headerlink" title="跳表(Probabilistic Alternative to Balanced Trees)"></a>跳表(Probabilistic Alternative to Balanced Trees)</h3><p>​        跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳表的期望空间复杂度为$O(n)$，跳表的查询，插入和删除操作的期望时间复杂度都为$O(logn)$。</p><p>​        链表加多级索引的结构就是跳表。跳表的每一层都是一个有序链表，每层位于第i层的节点有p的概率出现在第i+1层，p为常数。</p><p><img src="https://i.loli.net/2021/02/27/F6PO2UqsjEpv4hJ.png" alt="search_path_on_skiplist.png"></p><h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a><strong>空间复杂度</strong></h5><p>​        第一层的期望值为$n$, 第二层的期望值为$np$, 第三层的期望值为$np^2$，因此空间复杂度的期望值为$\sum\limits_{i = 0}^{+\infty}np^i=\frac{n}{1 - p}$。因为p为常数，因此跳表期望的空间复杂度为$O(n)$。</p><p><strong>时间复杂度</strong></p><p>跳表最后一层节点的个数为$\frac{1}{p}$，因为再上一层的期望值为1(无意义)。因此层数m为<br>$$<br>np^{m - 1}=\frac{1}{p} \\<br>(\frac{1}{p})^m=n \\<br>m = \log_{\frac{1}{p}}n<br>$$<br>​        跳表skiplist的平均查找长度，查找长度指的是查找路径上跨越的跳数，查找过程中的比较次数等于查找长度加1（每比较一次要么向下一层，要么到本层的右侧节点)。每个节点在进行插入的时候，它的层数是由随机函数randomLevel()计算出来的，随机的计算不依赖于其它的节点，每个节点是独立同分布的，每次插入过程都是完全独立的。</p><p>​        为了计算查找长度，我们将逆向还原查找过程，从右下方第一层最后到达的那个节点开始，沿着查找路径向左，向上回溯。假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p><p>如果某一个节点有上层节点的话，则我们需要向上走，整个查找过程类似楼梯的形状，<strong>每个节点第一被访问一定是位于其最顶层</strong>。</p><ul><li>如果节点x有第i+1，那么我们需要向上走，这种情况概率为p</li><li>如果节点没有第i+1层指针，那么我们需要向左走，这种情况的概率为1-p</li></ul><p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度，因此有<br>$$<br>C(k) = (1 - p)*(C(k) + 1) + p * (C(k - 1) + 1) \\<br>C(k) = \frac{1}{p} + C(k - 1) \\<br>C(k) = \frac{k}{p}<br>$$<br>n个节点跳表的层数为$\log_{\frac{1}{p}}n$， 因此所需时间为$\frac{\log_{\frac{1}{p}}n}{p}$，即平均时间复杂度为$O(\log n)$</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>数据结构SkipListNode，skiplist真正有数据只有下面一层的数据节点，每个节点的后继就是level[0],</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkipListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="built_in">vector</span>&lt;SkipListNode *&gt; level;</span><br><span class="line">SkipListNode (<span class="keyword">int</span> _val, <span class="keyword">int</span> sz=<span class="number">32</span>) : val(_val), level(sz, <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SkipListNode *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> level, length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAXL = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> S = <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> PS = S / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    Skiplist() &#123;</span><br><span class="line">        level = length = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="keyword">new</span> SkipListNode(INT_MAX, <span class="number">0</span>);</span><br><span class="line">        head = <span class="keyword">new</span> SkipListNode(INT_MAX);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXL; ++i) &#123; </span><br><span class="line">        head-&gt;level[i] = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SkipListNode* <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        SkipListNode *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123;</span><br><span class="line">                p = p-&gt;level[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;level[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        SkipListNode *p = find(target);</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;SkipListNode *&gt; <span class="title">update</span><span class="params">(MAXL)</span></span>;</span><br><span class="line">        SkipListNode *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123;</span><br><span class="line">                p = p-&gt;level[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lv = randomLevel();</span><br><span class="line">        <span class="keyword">if</span> (lv &gt; level) &#123;</span><br><span class="line">            lv = ++level;</span><br><span class="line">            update[lv - <span class="number">1</span>] = head; </span><br><span class="line">        &#125;</span><br><span class="line">        SkipListNode *newNode = <span class="keyword">new</span> SkipListNode(val, lv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lv - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            p = update[i];</span><br><span class="line">            newNode-&gt;level[i] = p-&gt;level[i];</span><br><span class="line">            p-&gt;level[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        ++length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;SkipListNode *&gt; <span class="title">update</span><span class="params">(MAXL + <span class="number">1</span>)</span></span>;</span><br><span class="line">        SkipListNode *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) &#123;</span><br><span class="line">                p = p-&gt;level[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;level[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;level[i] != p) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            update[i]-&gt;level[i] = p-&gt;level[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">0</span> &amp;&amp; head-&gt;level[level - <span class="number">1</span>] == tail) --level;</span><br><span class="line">        --length;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lv &lt; MAXL &amp;&amp; (rand() &amp; S) &lt; PS) ++lv;</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p><p><a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf</a></p><p><a href="https://oi-wiki.org/ds/skiplist/#_4">https://oi-wiki.org/ds/skiplist/#_4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;跳表-Probabilistic-Alternative-to-Balanced-Trees&quot;&gt;&lt;a href=&quot;#跳表-Probabilistic-Alternative-to-Balanced-Trees&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反射</title>
    <link href="http://abeltian.top/2021/02/24/JAVA/JAVA%E5%8F%8D%E5%B0%84/"/>
    <id>http://abeltian.top/2021/02/24/JAVA/JAVA%E5%8F%8D%E5%B0%84/</id>
    <published>2021-02-24T12:51:45.000Z</published>
    <updated>2021-09-10T08:53:11.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA-反射"><a href="#JAVA-反射" class="headerlink" title="JAVA 反射"></a>JAVA 反射</h3><p>反射是为了解决运行期，对某个对象一无所知的情况下，调用其方法，JVM为每一个加载的class创建一个Class类型的实例，并关联起来。</p><p>通过Class实例获取class信息的方法称为反射(Reflection)</p><h4 id="1-访问字段"><a href="#1-访问字段" class="headerlink" title="1. 访问字段"></a>1. 访问字段</h4><ul><li><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p></li><li><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p></li><li><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p></li><li><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p></li><li><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。****</p></li></ul><h4 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><h4 id="3-调用构造方法、获取继承关系"><a href="#3-调用构造方法、获取继承关系" class="headerlink" title="3.调用构造方法、获取继承关系"></a>3.调用构造方法、获取继承关系</h4><h4 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JAVA-反射&quot;&gt;&lt;a href=&quot;#JAVA-反射&quot; class=&quot;headerlink&quot; title=&quot;JAVA 反射&quot;&gt;&lt;/a&gt;JAVA 反射&lt;/h3&gt;&lt;p&gt;反射是为了解决运行期，对某个对象一无所知的情况下，调用其方法，JVM为每一个加载的class创建一个</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://abeltian.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA_Spring</title>
    <link href="http://abeltian.top/2021/02/24/JAVA/JAVA-Spring/"/>
    <id>http://abeltian.top/2021/02/24/JAVA/JAVA-Spring/</id>
    <published>2021-02-24T12:17:40.000Z</published>
    <updated>2021-09-10T08:53:11.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IOC-Inversion-of-Control控制反转"><a href="#IOC-Inversion-of-Control控制反转" class="headerlink" title="IOC(Inversion of Control控制反转)"></a>IOC(Inversion of Control控制反转)</h3><p>应用本身不负责依赖对象的创建和维护，依赖对象的创建和维护是由外部容器负责的称为控制反转。</p><p>IOC容器管理的对象称为Bean，Bean是由Spring容器初始化，装配及管理的对象。</p><p><img src="https://i.loli.net/2021/02/24/pkob3n8iRSvwZmW.jpg" alt="IOC_DI.JPG"></p><h3 id="DI-Dependency-Injection依赖注入"><a href="#DI-Dependency-Injection依赖注入" class="headerlink" title="DI(Dependency Injection依赖注入)"></a>DI(Dependency Injection依赖注入)</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;IOC-Inversion-of-Control控制反转&quot;&gt;&lt;a href=&quot;#IOC-Inversion-of-Control控制反转&quot; class=&quot;headerlink&quot; title=&quot;IOC(Inversion of Control控制反转)&quot;&gt;&lt;/a&gt;I</summary>
      
    
    
    
    <category term="JAVA" scheme="http://abeltian.top/categories/JAVA/"/>
    
    
    <category term="JAVA Spring" scheme="http://abeltian.top/tags/JAVA-Spring/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://abeltian.top/2021/02/22/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://abeltian.top/2021/02/22/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-22T12:03:14.000Z</published>
    <updated>2021-09-10T08:53:11.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式本质上是面向对象设计原则的实际运用。</p><h4 id="1-1设计模式分类"><a href="#1-1设计模式分类" class="headerlink" title="1.1设计模式分类"></a>1.1设计模式分类</h4><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><h4 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2.设计模式"></a>2.设计模式</h4><ul><li>代理模式：<a href="https://www.cnblogs.com/daniels/p/8242592.html">https://www.cnblogs.com/daniels/p/8242592.html</a></li></ul><p><img src="https://images2017.cnblogs.com/blog/1071931/201801/1071931-20180108134122472-1822105846.png" alt="img"></p><ul><li>中介隔离作用， 代理类对象可以在客户类和委托对象之间起到中介的作用。</li><li>开闭原则，增加功能。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。可以通过给代理类增加额外的功能来扩展委托类的功能。</li><li>java动态代理 <a href="https://blog.csdn.net/yaomingyang/article/details/80981004">https://blog.csdn.net/yaomingyang/article/details/80981004</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h3&gt;&lt;p&gt;设计模式本质上是面向对象设计原则的实际运用。&lt;/p&gt;
&lt;h4 id=&quot;1-1设计模式分类&quot;&gt;&lt;a href=&quot;#1-1设计模</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://abeltian.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Miller-Rabin素数探测</title>
    <link href="http://abeltian.top/2021/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Miller-Rabin%E7%B4%A0%E6%95%B0%E6%8E%A2%E6%B5%8B/"/>
    <id>http://abeltian.top/2021/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Miller-Rabin%E7%B4%A0%E6%95%B0%E6%8E%A2%E6%B5%8B/</id>
    <published>2021-02-15T13:30:13.000Z</published>
    <updated>2021-09-10T08:53:11.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Miller-Rabin素数探测"><a href="#Miller-Rabin素数探测" class="headerlink" title="Miller-Rabin素数探测"></a>Miller-Rabin素数探测</h3><p>费马小定理，如果p为质数，且$gcd(a,p)=1$，那么$a^{p - 1} \equiv 1 (mod\ p)$， 如果p为质数，且a，p互质，那么a的p-1次方除以p的余数等于1。</p><p>二次探测定理， 如果p是素数，且x是小于p的正整数，且$x^2 \equiv 1 (mod\ p)$，那么$x = 1$或者$x =p - 1$。</p><p>Miller-Rabin素数探测，将p-1(偶数)表示为$d \times 2^r$，其中d为奇数，如果p为素数，那么存在某个$0 \le i &lt; r$使得$a^{d*2^{r - i}} mod\ n = n - 1$，或者$a^d = 1$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">a = a * a % p;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是long long会发生溢出，则需要在模运算意义下计算快速积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TwiceDetect</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = __builtin_ctz(b);</span><br><span class="line">    ll d = b &gt;&gt; t;</span><br><span class="line">    ll x, y;</span><br><span class="line">    x = y = qpow(a, d, p);</span><br><span class="line">    <span class="keyword">while</span> (r--) &#123;</span><br><span class="line">        y = x * x % p;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != p - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//是合数返回1</span></span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> y != <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">2</span> || p % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        ll base = prime[i];</span><br><span class="line">        <span class="keyword">if</span> (p == base) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (TwiceDetect(base, p - <span class="number">1</span>, p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Miller-Rabin素数探测&quot;&gt;&lt;a href=&quot;#Miller-Rabin素数探测&quot; class=&quot;headerlink&quot; title=&quot;Miller-Rabin素数探测&quot;&gt;&lt;/a&gt;Miller-Rabin素数探测&lt;/h3&gt;&lt;p&gt;费马小定理，如果p为质数，且</summary>
      
    
    
    
    
    <category term="Data Stucture" scheme="http://abeltian.top/tags/Data-Stucture/"/>
    
  </entry>
  
  <entry>
    <title>线段树I</title>
    <link href="http://abeltian.top/2021/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91I/"/>
    <id>http://abeltian.top/2021/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91I/</id>
    <published>2021-02-05T10:03:40.000Z</published>
    <updated>2021-09-10T08:53:11.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树本质上开了O(4n)的空间来维护了数组区间的性质。根节点从下标1开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p为当前l, r区间对应的下标， l为当前区键的左侧下标，r为右侧下标</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="comment">//更新a[p]</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    build(p &lt;&lt; <span class="number">1</span>, l , mid);</span><br><span class="line">    build(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    a[p] = f(a[p &lt;&lt; <span class="number">1</span>], a[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>惰性更新，当更新区间包含了当前的区间[l, r]，只需要更新当前的节点并进行标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线段树&quot;&gt;&lt;a href=&quot;#线段树&quot; class=&quot;headerlink&quot; title=&quot;线段树&quot;&gt;&lt;/a&gt;线段树&lt;/h3&gt;&lt;p&gt;线段树本质上开了O(4n)的空间来维护了数组区间的性质。根节点从下标1开始&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>可持久化并查集</title>
    <link href="http://abeltian.top/2021/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://abeltian.top/2021/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-02-04T09:15:35.000Z</published>
    <updated>2021-09-10T08:53:11.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h3><p>可持久化并查集 = 可持久化 + 并查集 = 主席树 + 并查集</p><p><a href="https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths-ii/">leetcode 1724 检查边长度限制的路径是否存在 II</a></p><p>主席树方便用来维护历史的版本信息，可以支持回退， 访问之前版本的数据结构。</p><p>并查集，常用的两种优化方法是路径压缩，按秩合并。在可持久化并查集中只会用到按秩合并，即深度小的点向深度大的点合并，保证单次查询的时间复杂度为$ologn$</p><ul><li>可持久化并查集进本操作，状态定义</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> rt[N] <span class="comment">// 保存每一个版本的头结点</span></span><br><span class="line"><span class="keyword">int</span> ls[N &lt;&lt; <span class="number">5</span>], rs[N &lt;&lt; <span class="number">5</span>] <span class="comment">// 每个节点的左右孩子</span></span><br><span class="line"><span class="keyword">int</span> fa[N &lt;&lt; <span class="number">5</span>], sz[N &lt;&lt; <span class="number">5</span>] <span class="comment">// 节点的父亲、树的高度</span></span><br></pre></td></tr></table></figure><ul><li><p>建立基础主席树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">t = ++tot;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">fa[t] = l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">build(ls[t], l, mid);</span><br><span class="line">build(rs[t], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找某一个元素在主席树中的下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// t为某一历史版本的根节点下标， x为待查找的元素</span></span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query(ls[t], l, mid, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(rs[t], mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找版本号为t元素x的祖先</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = query(t, l, r, x); <span class="comment">// 查询x的下标</span></span><br><span class="line"><span class="keyword">if</span> (fa[p] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> find(t, l, r, fa[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按秩合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改x节点的父亲为father</span></span><br><span class="line">    <span class="keyword">int</span> t = ++tot;</span><br><span class="line">    ls[t] = ls[pre], rs[t] = rs[pre];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        fa[t] = father;</span><br><span class="line">        sz[t] = sz[pre];</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) ls[t] = unite(ls[pre], l, mid, x, father);</span><br><span class="line">    <span class="keyword">else</span> rs[t] = unite(rs[pre], mid + <span class="number">1</span>, r, x, father);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新合并后父节点的深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">sz[t]++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid) update(ls[t], l, mid, x);</span><br><span class="line"><span class="keyword">else</span> update(rs[t], mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全部代码如下,  java用时329ms通过了全部测试用例， 但是用c++超时了…..不开o2优化太坑人了。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistanceLimitedPathsExist</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line">    <span class="keyword">int</span> tot, n;</span><br><span class="line">    <span class="keyword">int</span> rt[N], ls[N &lt;&lt; <span class="number">5</span>], rs[N &lt;&lt; <span class="number">5</span>], fa[N &lt;&lt; <span class="number">5</span>], sz[N &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        t = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            fa[t] = l;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        build(ls[t], l, mid);</span><br><span class="line">        build(rs[t], mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query(ls[t], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(rs[t], mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = query(t, l, r, x); </span><br><span class="line">        <span class="keyword">if</span> (fa[p] == x) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">return</span> find(t, l, r, fa[p]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改x节点的父亲为father</span></span><br><span class="line">        <span class="keyword">int</span> t = ++tot;</span><br><span class="line">        ls[t] = ls[pre], rs[t] = rs[pre];</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            fa[t] = father;</span><br><span class="line">            sz[t] = sz[pre];</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) ls[t] = unite(ls[pre], l, mid, x, father);</span><br><span class="line">        <span class="keyword">else</span> rs[t] = unite(rs[pre], mid + <span class="number">1</span>, r, x, father);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sz[t]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) update(ls[t], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> update(rs[t], mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DistanceLimitedPathsExist(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edgeList) &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">memset</span>(rt, <span class="number">0</span>, <span class="keyword">sizeof</span>(rt));</span><br><span class="line">        <span class="built_in">memset</span>(ls, <span class="number">0</span>, <span class="keyword">sizeof</span>(ls));</span><br><span class="line">        <span class="built_in">memset</span>(rs, <span class="number">0</span>, <span class="keyword">sizeof</span>(rs));</span><br><span class="line">        <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa));</span><br><span class="line">        <span class="built_in">memset</span>(sz, <span class="number">0</span>, <span class="keyword">sizeof</span>(sz));</span><br><span class="line">        sort(edgeList.begin(), edgeList.end(), [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        build(rt[<span class="number">0</span>], <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeList.size(); ++i) &#123;</span><br><span class="line">            rt[i + <span class="number">1</span>] = rt[i];</span><br><span class="line">            <span class="keyword">int</span> x = edgeList[i][<span class="number">0</span>], y = edgeList[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> posx = find(rt[i], <span class="number">0</span>, n - <span class="number">1</span>, x), posy = find(rt[i], <span class="number">0</span>, n - <span class="number">1</span>, y);</span><br><span class="line">            <span class="keyword">if</span> (fa[posx] != fa[posy]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sz[posx] &gt; sz[posy]) swap(posx, posy);</span><br><span class="line">                rt[i + <span class="number">1</span>] = unite(rt[i], <span class="number">0</span>, n - <span class="number">1</span>, fa[posx], fa[posy]);</span><br><span class="line">                <span class="keyword">if</span> (sz[posx] == sz[posy]) update(rt[i + <span class="number">1</span>], <span class="number">0</span>, n - <span class="number">1</span>, fa[posy]);</span><br><span class="line">            &#125;</span><br><span class="line">            dis.push_back(edgeList[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = upper_bound(dis.begin(), dis.end(), limit - <span class="number">1</span>) - dis.begin();</span><br><span class="line">        <span class="keyword">int</span> version = rt[num];</span><br><span class="line">        <span class="keyword">int</span> posx = find(version, <span class="number">0</span>, n - <span class="number">1</span>, p);</span><br><span class="line">        <span class="keyword">int</span> posy = find(version, <span class="number">0</span>, n - <span class="number">1</span>, q);</span><br><span class="line">        <span class="keyword">if</span> (fa[posx] == fa[posy]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;可持久化并查集&quot;&gt;&lt;a href=&quot;#可持久化并查集&quot; class=&quot;headerlink&quot; title=&quot;可持久化并查集&quot;&gt;&lt;/a&gt;可持久化并查集&lt;/h3&gt;&lt;p&gt;可持久化并查集 = 可持久化 + 并查集 = 主席树 + 并查集&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>主席树</title>
    <link href="http://abeltian.top/2021/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://abeltian.top/2021/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%B8%AD%E6%A0%91/</id>
    <published>2021-02-03T02:28:14.000Z</published>
    <updated>2021-09-10T08:53:11.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主席树（可持久化线段树）"><a href="#主席树（可持久化线段树）" class="headerlink" title="主席树（可持久化线段树）"></a>主席树（可持久化线段树）</h2><p>问题描述：</p><blockquote><p>给定N个数（int范围内），一共M次询问，每次都要询问区间[[l,r]的第k大的数。 其中N, M, l, r均不超过$2\times10^5$，保证询问有答案</p></blockquote><p>​        主席树本名可持久化线段树，也就是说，主席树是基于线段树发展而来的一种数据结构。其前缀”可持久化”意在给线段树增加一些历史点来维护历史数据，使得我们能在较短时间内查询历史数据，图示如下。</p><p><img src="https://i.loli.net/2021/02/03/B5S7PmvArU9FDkw.png" alt="hjt.png"></p><p>当每插入一个数据时，会修改$logn$个节点，因为主席树的左右子树节点编号不能够计算得到，而是需要记录下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">200010</span></span><br><span class="line"><span class="keyword">int</span> rt[N]                  <span class="comment">// 记录插入第i个数后的根节点</span></span><br><span class="line"><span class="keyword">int</span> ls[N &lt;&lt; <span class="number">5</span>], rs[N &lt;&lt; <span class="number">5</span>] <span class="comment">// 记录左儿子，右儿子</span></span><br><span class="line"><span class="keyword">int</span> sum[N &lt;&lt; <span class="number">5</span>]            <span class="comment">// 记录当前节点区间的元素个数</span></span><br></pre></td></tr></table></figure><ul><li><p>将数组复制一份，进行排序，去掉重复的数字离散化。</p></li><li><p>以离散化后的数组为基础建立一个全零的线段树，称为基础主席树</p></li><li><p>对原数据中每一个[1,i]区间统计，有序地插入新节点，i每增加1，就会多一个数，仅需对主席树对应的节点增加1即可</p></li><li><p>对于查询[l, r]中第k小值的操作，找到[l, r]对应的根节点，按照线段树操作的方法即可</p></li></ul><p>建立基础主席树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">u = ++tot;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">build(ls[u], l, mid);</span><br><span class="line">build(rs[u], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向主席树中加入元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = ++tot;</span><br><span class="line">ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> cur;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) ls[cur] = modify(ls[cur], l, mid);</span><br><span class="line">    <span class="keyword">else</span> rs[cur] = modify(rs[cur], mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询区间第k大，注意区间下标是从1开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, x = sum[ls[v]] - sum[ls[u]];</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= x) ans = query(ls[u], ls[v], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> ans = query(rs[u], rs[v], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主席树（可持久化线段树）&quot;&gt;&lt;a href=&quot;#主席树（可持久化线段树）&quot; class=&quot;headerlink&quot; title=&quot;主席树（可持久化线段树）&quot;&gt;&lt;/a&gt;主席树（可持久化线段树）&lt;/h2&gt;&lt;p&gt;问题描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定N个</summary>
      
    
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://abeltian.top/2021/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://abeltian.top/2021/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-02-02T09:39:39.000Z</published>
    <updated>2021-09-10T08:53:11.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一片介绍rank-dense-rank-很好的文章"><a href="#一片介绍rank-dense-rank-很好的文章" class="headerlink" title="一片介绍rank() dense_rank()很好的文章"></a>一片介绍rank() dense_rank()很好的文章</h3><p><a href="https://blog.csdn.net/u011726005/article/details/94592866">https://blog.csdn.net/u011726005/article/details/94592866</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一片介绍rank-dense-rank-很好的文章&quot;&gt;&lt;a href=&quot;#一片介绍rank-dense-rank-很好的文章&quot; class=&quot;headerlink&quot; title=&quot;一片介绍rank() dense_rank()很好的文章&quot;&gt;&lt;/a&gt;一片介绍rank</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://abeltian.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>博弈--极大极小博弈树</title>
    <link href="http://abeltian.top/2021/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%8D%9A%E5%BC%88%E6%A0%91/"/>
    <id>http://abeltian.top/2021/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%8D%9A%E5%BC%88%E6%A0%91/</id>
    <published>2021-01-31T10:04:02.000Z</published>
    <updated>2021-09-10T08:53:11.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h3><p>博弈的两种的分类：</p><ul><li><p>动态博弈是指在博弈中，两个参与人有行动的先后顺序，且后行动者能够观察到先行动者所选择的行动。</p></li><li><p>静态博弈是指在博弈中，两个参与人同时选择或不同时选择时，后行动者并不知道先行动者采取什么样的具体行动。</p></li></ul><h4 id="1-极大极小博弈树"><a href="#1-极大极小博弈树" class="headerlink" title="1. 极大极小博弈树"></a>1. 极大极小博弈树</h4><p>​        由于动态博弈参与者的行动有先后顺序，因此参与者的行动构成的为树状结构。</p><p>​        博弈通常是双方对抗，甚至是零和的博弈。也就是说，对对方最有利的决策，反过来就是对我方最不利的局面。在轮到我们做出决策的时候，我们通常希望最大化我们的收益，叫做<strong>极大层，</strong>此时树的节点叫做<strong>极大层节点</strong>；在对手做决策的时候，对手希望最小化我们的收益，叫做<strong>极小层，</strong>此时树的节点叫做<strong>极小层节点</strong>。由于双方是交替做出决策，因此<strong>极大层、极小层</strong>通常是交替出现，这样的数据结构就叫做<strong>极大极小树（Min-Max Tree）</strong>。</p><p><img src="https://i.loli.net/2021/01/31/vz42OSdexlP86EZ.jpg" alt="max-min-tree.png"></p><p><img src="C:\Users\sty\AppData\Roaming\Typora\typora-user-images\max-min-tree.png" alt="preview"></p><p>「必胜态」和「必败态」的概念：</p><ul><li>一个状态为「必胜态」，当且仅当其相邻状态中至少有一个「必败态」。这里相邻的状态的定义为：在当前状态中进行决策的玩家可以到达的所有状态。也就是说，玩家可以选择移动到一个「必败态」，使得对手必败，因此当前状态是必胜的。</li><li>一个状态为「必败态」，当且仅当其相邻的所有状态都是「必胜态」。这里的道理是类似的，如果所有相邻状态都是「必胜态」，那么对手必胜，当前玩家必败。</li></ul><h4 id="2-从已知状态进行搜索"><a href="#2-从已知状态进行搜索" class="headerlink" title="2.从已知状态进行搜索"></a>2.从已知状态进行搜索</h4><p>从已知的最终状态进行倒推之前状态的可能性，考虑已有的可能的几种状态</p><p>leetcode 913 猫和老鼠</p><ul><li>此步老鼠胜利，上一步为老鼠行动，则上一步老鼠为必胜态</li><li>此步老鼠胜利，上一步为猫行动，则上一步猫行动状态的出度减一，(因为猫走该步后不肯能胜利)，只有当猫行动后所有的子状态均为老鼠的必胜态时，即出度为0时，此时猫所处的状态为必败态。</li><li>此步猫胜利，上一步为猫行动，则上一步猫的状态为必胜态。</li><li>此步猫胜利，上一步为老鼠行动，同上。</li></ul><p>状态定义 f[i][j][0]为老鼠处于i，猫处于j，此时为老鼠行动，上一步为猫行动。 老鼠胜利：1， 猫胜利： 2， 平局： 0，最终返回初始状态的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;博弈&quot;&gt;&lt;a href=&quot;#博弈&quot; class=&quot;headerlink&quot; title=&quot;博弈&quot;&gt;&lt;/a&gt;博弈&lt;/h3&gt;&lt;p&gt;博弈的两种的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态博弈是指在博弈中，两个参与人有行动的先后顺序，且后行动者能够观察到先行动者所选择的行</summary>
      
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/categories/Alogrithm/"/>
    
    
    <category term="Data Structure" scheme="http://abeltian.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得算法</title>
    <link href="http://abeltian.top/2021/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/exgcd/"/>
    <id>http://abeltian.top/2021/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/exgcd/</id>
    <published>2021-01-26T04:49:27.000Z</published>
    <updated>2021-09-10T08:53:11.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>在求最大公约数时，基于一个基本的事实$(a, b) = (b, a - \lfloor \frac{a}{b}\rfloor b) = (b, a\ mod \ b)$，直到$b = 0$，此时$(a, 0) = a$。这种求最大公约数的算法叫做辗转相除法，又叫做欧几里得算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">a %= b;</span><br><span class="line">swap(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>裴蜀定理</strong>：假设$a, b$是不全为0的整数，则存在整数$x, y$使得$ax + by = gcd(a, b)$。</p><p>简单证明：<br>$$<br>gcd(a, b) = gcd(b, a\ mod\ b) = gcd(b, a - kb) = gcd(r_1, r_2) = \dots = gcd(r_n, 0)<br>$$<br>其中$r_1, r_2 \dots r_n$都可以写成$x_ia + y_ib$的形式，因此存在$ax + by = gcd(a, b)$</p><p>扩展欧几里得算法在求解最大公约数的同时，计算了一组适于裴蜀定理的系数。<br>递推关系的推导，$(a, b) = (b, a\ mod\ b) = (b, a - \lfloor \frac{a}{b} \rfloor b)$，因此存在四个整数$x, y, x’, y’$使得<br>$$<br>ax + by = bx’ + (a - \lfloor \frac{a}{b} \rfloor b)y’ \\<br>a(x - y’) + b(y - (x’ - \lfloor \frac{a}{b} \rfloor)y’) = 0 \\<br>x = y’, y = x’ - \lfloor \frac{a}{b} \rfloor y’<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ex_gcd(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法可以改写为迭代的形式，递推公式<br>$$<br>\left{ \begin{array}{rcl}<br>{\rm{x}} = y’ \\<br>{y = x’ - \lfloor \frac{a}{b} \rfloor y’}<br>\end{array} \right.<br>$$<br>将其写为矩阵的形式</p><p>$$<br>\left( \begin{array}{rcl}<br>x \\<br>y<br>\end{array} \right) = \left( \begin{array}{rcl}<br>0&amp;1 \\<br>1&amp;{ -\lfloor \frac{a}{b} \rfloor}<br>\end{array} \right)\left( \begin{array}{rcl}<br>{x’} \\<br>{y’}<br>\end{array} \right)<br>$$</p><ul><li>初始矩阵为单位矩阵</li><li>$<br>\left( \begin{array}{rcl}<br>x&amp;m\\<br>y&amp;n<br>\end{array} \right) = \left( \begin{array}{rcl}<br>x&amp;m\\<br>y&amp;n<br>\end{array} \right)\left( \begin{array}{rcl}<br>0&amp;1\\<br>1&amp;{ - d}<br>\end{array} \right) = \left( \begin{array}{rcl}<br>m&amp;{x - dm}\\<br>n&amp;{y - dn}<br>\end{array} \right)$</li><li>当b=0时，计算结束，此时x, y为满足裴蜀定理的系数，最大公约数为a。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;扩展欧几里得算法&quot;&gt;&lt;a href=&quot;#扩展欧几里得算法&quot; class=&quot;headerlink&quot; title=&quot;扩展欧几里得算法&quot;&gt;&lt;/a&gt;扩展欧几里得算法&lt;/h3&gt;&lt;p&gt;在求最大公约数时，基于一个基本的事实$(a, b) = (b, a - \lfloor \f</summary>
      
    
    
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
  <entry>
    <title>乘法逆元</title>
    <link href="http://abeltian.top/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    <id>http://abeltian.top/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</id>
    <published>2021-01-25T14:11:43.000Z</published>
    <updated>2021-09-10T08:53:11.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><h4 id="1-逆元的定义"><a href="#1-逆元的定义" class="headerlink" title="1. 逆元的定义"></a>1. 逆元的定义</h4><p>如果一个线性同余方程$ax \equiv 1 (mod\ b)$，则称$x$为$a\ mod\ b$的逆元，记作$a^{-1}$。</p><p>模运算规则与基本四则运算类似，但是除法例外。在ACM竞赛中，除法取模的运算要用到求逆元，从而得到$(a / b) \% c = (a * x) \% c$</p><p>证明：已知$(b * x) \% c = 1$，假设$(a / b) \% c = y_1, (a * x) \% c = y_2$</p><p>则</p><ul><li>$a / b = k_1*c + y_1\quad(1)$ </li><li>$a*x = k_2 * c + y_2\quad(2)$</li><li>$(1) -(2)$$\quad \rightarrow \quad a/b - a*x = (k_1 - k_2)*c + (y_1 - y_2)$ </li><li>左右同时乘以b $\quad \rightarrow \quad$  $a - a * x * b = k * c * b + (y1 - y2) * b$ </li><li>左右模上c $\quad \rightarrow \quad (y1 - y2) * b \% c = 0$</li><li>因为$b \neq 0$, 所以$y_1 = y_2$</li></ul><h4 id="2-求逆元"><a href="#2-求逆元" class="headerlink" title="2. 求逆元"></a>2. 求逆元</h4><p>费马小定理，若p为素数，且$gcd(a, p) = 1$，则$a^{p - 1} \equiv 1 (mod\ p)$</p><p>证明：</p><ul><li>构造一个序列$A={1, 2, 3, \dots p - 1}$， 这个序列有如下的性质:</li><li>$\mathop{\Pi}\limits_{i = 1}^{n}A_i = \mathop{\Pi}\limits_{i = 1}^{n}(A_i \times a)$</li><li>对于任意$i, j \in n $，$(A_i * a )\% p \neq (A_j * a )\% p$，因为$(A_i - A_j) * a \% p = 0$，则$A_i - A_j = 0$</li><li>因此$(p - 1)! \equiv (p - 1)! * a^{p - 1}\ (mod\ p) \quad \rightarrow a^{p - 1} \equiv 1 \ mod(\ p)$ </li></ul><h4 id="2-1-扩展欧几里得算法"><a href="#2-1-扩展欧几里得算法" class="headerlink" title="2.1 扩展欧几里得算法"></a>2.1 扩展欧几里得算法</h4><p><a href="https://abeltian.top/2021/01/26/exgcd/">扩展欧几里得算法</a></p><p>求解同余方程$ax \equiv 1 (mod\ b)$的最小整数解</p><p>假设采用扩展欧几里得算法求得一组$x_0, y_0$满足$ax_0 +by_0 = gcd(a, b)$，则该方程的任意解可以表示为$x = x_0 + bt, y = y_0-at$，对于任意t均成立，最小整数解可以表示为$x = ((x_0\ mod\ b) + b) mod\ b$</p><h4 id="2-2快速幂算法"><a href="#2-2快速幂算法" class="headerlink" title="2.2快速幂算法"></a>2.2快速幂算法</h4><p>根据费马小定理，$1 \equiv a^{p -1} (mod\ p)$，因此$x = a^{p - 2}$，可以采用快速幂算法进行计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = (ret * a) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-线性求逆元"><a href="#2-3-线性求逆元" class="headerlink" title="2.3 线性求逆元"></a>2.3 线性求逆元</h4><p>求出$1, 2, \dots, n$中每个数关于p的逆元。</p><ul><li>显然$1{-1} \equiv 1 (mod\ p)$</li><li>令$k = \lfloor\frac{p}{i} \rfloor, j = p\ mod\ i$, 因此有$p = ki + j$，在模p的意义下就有$ki + j \equiv 0\ (mod\ p)$</li><li>左右同乘以$i^{-1}, j^{-1}$，有$kj^{-1} + i^{-1}=0$</li><li>$i^{-1}=-kj^{-1} = (p - k)j^{-1}$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> expr mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll fac[N], R[N], inv[N];</span><br><span class="line">fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = R[<span class="number">0</span>] = R[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">fac[i] = <span class="number">1L</span>L * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[i] = <span class="number">1L</span>L * (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    R[i] = <span class="number">1L</span>L * R[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1L</span>L * fac[n] * R[m] % mod * R[n - m] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-线性求任意n个数的逆元"><a href="#2-4-线性求任意n个数的逆元" class="headerlink" title="2.4 线性求任意n个数的逆元"></a>2.4 线性求任意n个数的逆元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> LL mod = <span class="number">99997867</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">LL fac[N], rf[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = ret * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    rf[N - <span class="number">1</span>] = qpow(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        rf[i] = rf[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">comb</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * rf[n - m] % mod * rf[m] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;乘法逆元&quot;&gt;&lt;a href=&quot;#乘法逆元&quot; class=&quot;headerlink&quot; title=&quot;乘法逆元&quot;&gt;&lt;/a&gt;乘法逆元&lt;/h3&gt;&lt;h4 id=&quot;1-逆元的定义&quot;&gt;&lt;a href=&quot;#1-逆元的定义&quot; class=&quot;headerlink&quot; title=&quot;1. </summary>
      
    
    
    
    <category term="Data Structure" scheme="http://abeltian.top/categories/Data-Structure/"/>
    
    
    <category term="Alogrithm" scheme="http://abeltian.top/tags/Alogrithm/"/>
    
  </entry>
  
</feed>
